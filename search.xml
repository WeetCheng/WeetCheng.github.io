<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C字符串和string类]]></title>
    <url>%2F2018%2F10%2F18%2FC%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8Cstring%2F</url>
    <content type="text"><![CDATA[C风格字符串是指形如”hello world”这样的，以’\0’作为字符串结束符的传统的字符串。 string字符串则是指C++中的string类对象。string类对象本质上是对C风格字符串的封装，从而方便程序员使用。 常用C风格字符串函数使用C风格字符串函数，需要包含以下其中一个 12#include &lt;string.h&gt; #include &lt;cstring&gt; 常用的C风格字符串处理函数有 函数名 作用 char *strcpy(char *dest, const char *src); 将字符串从src处复制到dest处 char *strncpy(char *dest, const char *src, size_t n); 同上，不过最多复制n个字节 void *memset(void *s, int c, size_t n); 将s处开始的n个字节设为c void *memcpy(void *dest, const void *src, size_t n); 从src处复制n个字节到dest处 void *memmove(void *dest, const void *src, size_t n); 从src处复制n个字节到dest处 char *strcat(char *dest, const char *src); 将src的字符串接到dest后面 char *strncat(char *dest, const char *src, size_t n); 同上，不过最多接n个字节 int strcmp(const char *s1, const char *s2); 比较两个字符串，按ASCII比较 int strncmp(const char *s1, const char *s2, size_t n); 同上，不过最多比较n个字符 char *strstr(const char *haystack, const char *needle); 找出子串needle在主串haystack的位置 char *strcasestr(const char *haystack, const char *needle); 同上，不过忽略子串和主串大小写的不同 C风格字符串转换成数字 函数名 作用 atoi atol atoll atof strtod strtol strtoul]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++输入输出]]></title>
    <url>%2F2018%2F09%2F26%2FC%E5%92%8CC%2B%2B%2FC%2B%2B%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[cincin 不读取换行符，换行符仍保留在缓冲区中。 getline循环getline+cin会出问题，因为cin会留下换行符，导致getline直接读了该换行符，而不是重新读入数据 map的使用华为 合并表记录 int整数转成string1string str = to_string(num); 两种迭代方式12345678910//迭代方式一：for(map&lt;int, int&gt;::iterator iter = mapValue.begin(); iter != mapValue.end(); iter++)&#123; cout &lt;&lt; iter-&gt;first &lt;&lt; ' ' &lt;&lt; iter-&gt;second &lt;&lt; endl;&#125;//迭代方式二：for (auto &amp;&amp;item : mapValue)&#123; cout &lt;&lt; item.first &lt;&lt; ' ' &lt;&lt; item.second &lt;&lt; endl;&#125; sort函数自定义compare函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;sstream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;/* isFronter就是一个自定义的sort的compare函数，return true的情况排序时排在前面 false的情况排在后面 */bool isFronter(const string &amp;s1,const string &amp;s2)&#123; if(s1.size() &lt; s2.size()) return true; else if(s1.size() &gt; s2.size()) return false; else &#123; const char *a = s1.data(); const char *b = s2.data(); if(strcmp(a, b) &gt; 0) return true; else return false; &#125;&#125;int main(int argc, char *argv[])&#123; string str; while(getline(cin, str)) &#123; stringstream ss(str); string strTmp; vector&lt;string&gt; input; while(ss &gt;&gt; strTmp) &#123; input.push_back(strTmp); &#125; sort(input.begin(), input.end(), isFronter); for(int i = 0; i &lt; input.size() - 1; i++) &#123; cout &lt;&lt; input[i] &lt;&lt; " "; &#125; cout &lt;&lt; input[input.size() - 1] &lt;&lt; endl; &#125; return 0;&#125; 字符串按指定分隔符分割1. 直接使用strtok函数分割char*类型的字符串 1234567891011121314#include &lt;iostream&gt;using namespace std;int main() &#123; char s[] = "my name is lmm"; char *p; const char *delim = " "; p = strtok(s, delim); // 两次strtok，第一次要输入s， while(p) &#123; cout &lt;&lt; p &lt;&lt; endl; p = strtok(NULL, delim);// 后面循环的时候，输入NULL作为参数 &#125; return 0;&#125; 2. 借助strtok分割string类型的字符串，将结果保存在vector中 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;string&gt; split(const string&amp; str, const string&amp; delim) &#123; vector&lt;string&gt; res; if("" == str) return res; //先将要切割的字符串从string类型转换为char*类型 char * strs = new char[str.length() + 1] ; //不要忘了 strcpy(strs, str.c_str()); char * d = new char[delim.length() + 1]; strcpy(d, delim.c_str()); char *p = strtok(strs, d); while(p) &#123; string s = p; //分割得到的字符串转换为string类型 res.push_back(s); //存入结果数组 p = strtok(NULL, d); &#125; return res;&#125; 3. 借助于string类的find和substr函数 12345678910111213141516171819vector&lt;string&gt; split(const string&amp; str,const string&amp; delim) &#123; //将分割后的子字符串存储在vector中 vector&lt;string&gt; res; if("" == str) return res; string strs = str + delim; //*****扩展字符串以方便检索最后一个分隔出的字符串 size_t pos; size_t size = strs.size(); for (int i = 0; i &lt; size; ++i) &#123; pos = strs.find(delim, i); //pos为分隔符第一次出现的位置，从i到pos之前的字符串是分隔出来的字符串 if( pos &lt; size) &#123; //如果查找到，如果没有查找到分隔符，pos为string::npos string s = strs.substr(i, pos - i);//*****从i开始长度为pos-i的子字符串 res.push_back(s);//两个连续空格之间切割出的字符串为空字符串，这里没有判断s是否为空，所以最后的结果中有空字符的输出， i = pos + delim.size() - 1; &#125; &#125; return res; &#125; 4. stringstream加getline实现 123456789101112vector&lt;string&gt; spilt(string str, char del)&#123; vector&lt;string&gt; target; string strTmp; stringstream ss(str); while(getline(ss, strTmp, del)) &#123; target.push_back(strTmp); &#125; return target;&#125; vector的初始化1234// 一维vector初始化vector&lt;int&gt; height(Num, 0);// 二维vector初始化vector&lt;vector&lt;int&gt; &gt; map(rows, vector&lt;int&gt;(cols, 0));]]></content>
  </entry>
  <entry>
    <title><![CDATA[SSH原理]]></title>
    <url>%2F2018%2F09%2F23%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2FSSH%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[空类]]></title>
    <url>%2F2018%2F09%2F21%2FC%E5%92%8CC%2B%2B%2F%E7%A9%BA%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[空类的概念空类，即没有静态成员变量的类或者结构体。 C++中有一个规则，为了保证每个对象分配的地址各不相同，任何对象或者子对象的大小至少占用一个字节的空间，因此空类至少会被分配一个字节。 为什么分配一个字节之后，可以保证每个对象的地址不同呢？ 答：这里要注意区分地址和空间的区别。 地址指的是一个对象的起始地址，空间指的是这个对象占用的地址块。假设给对象分配了地址A，但没有分配空间，那么操作系统的内存管理器无法管理分配0空间的情况，下次有可能会给别的对象也分配到地址A上，导致两个不同的对象指向同一个地址。而，如果分配了地址，又分配了空间，那么内存管理器中有相关的记录，就不可能分配相同的地址和空间给其他对象了。 空基类优化空基类优化，即一个字节都不给空基类分配。 在一些情况下，会执行空基类优化，有些情况又不会执行空基类优化，判断是否执行的标准在于： 准则：假设类Derived继承自空基类Empty，并且Derived类的第一个非静态成员变量的类型是空基类Empty，或者空基类Empty的派生类，那么不执行空基类优化，因为如果被优化，两个连续的空基类可能会出现相同的地址。 注意：这条判断准则是全文最关键的一句话，所有分析都遵循这条准则。 Empty base optimization is prohibited if one of the empty base classes is also the type or the base of the type of the first non-static data member, since the two base subobjects of the same type are required to have different addresses within the object representation of the most derived type.——CppReference 例程： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;iostream&gt;using namespace std;// 设置内存空间按1字节对齐，这样方便分析是否有执行空基类优化#pragma pack(1) class Empty &#123;&#125;;class Derived1 : public Empty &#123;&#125;;class Derived2 : public Empty&#123;public: int32_t i32;&#125;;class Derived3 : public Derived1 &#123;&#125;;class Derived4 : public Derived1&#123;public: int32_t i32;&#125;;class Derived5 : public Empty &#123;public: Empty e; &#125;;class Derived6: public Empty&#123;public: static Empty se;&#125;;Derived6::Empty se &#123;&#125;;class Derived7 : public Empty&#123;public: int32_t i32; Empty e;&#125;;class Derived8: public Empty&#123; Empty a; int32_t i32; Empty b;&#125;;class Derived9 : public Empty&#123; Derived2 a; Derived2 b;&#125;;class Empty1 &#123;&#125;;class MultiDerived : public Empty, public Empty1 &#123;&#125;;class MultiDerived1 : public Empty &#123;&#125;;class MultiDerived2 : public Empty &#123;&#125;;class MultiDerived3 : public MultiDerived1, public MultiDerived2 &#123;&#125;;class NotEmpty &#123;public: int32_t i32;&#125;;class MultiDerived4 : public MultiDerived1, public NotEmpty&#123;public: Empty e;&#125;;class MultiDerived5 : public NotEmpty, public MultiDerived1&#123;public: Empty e;&#125;;class MultiDerived6 : public NotEmpty, public MultiDerived1 &#123;&#125;;class Foo&#123;public: Empty e[4]; Derived2 d;&#125;;class Foo1Helper : public Empty&#123;public: std::int8_t i8[3];&#125;;class Foo1 : public Empty&#123;public: Foo1Helper d;&#125;;class Foo2 : public Empty&#123;public: Foo f;&#125;;int main(int argc, char *argv[])&#123; cout &lt;&lt; "size of Empty:" &lt;&lt; sizeof(Empty) &lt;&lt; endl; cout &lt;&lt; "size of Derived1:" &lt;&lt; sizeof(Derived1) &lt;&lt; endl; cout &lt;&lt; "size of Derived2:" &lt;&lt; sizeof(Derived2) &lt;&lt; endl; cout &lt;&lt; "size of Derived3:" &lt;&lt; sizeof(Derived3) &lt;&lt; endl; cout &lt;&lt; "size of Derived4:" &lt;&lt; sizeof(Derived4) &lt;&lt; endl; cout &lt;&lt; "size of Derived5:" &lt;&lt; sizeof(Derived5) &lt;&lt; endl; cout &lt;&lt; "size of Derived6:" &lt;&lt; sizeof(Derived6) &lt;&lt; endl; cout &lt;&lt; "size of Derived7:" &lt;&lt; sizeof(Derived7) &lt;&lt; endl; cout &lt;&lt; "size of Derived8:" &lt;&lt; sizeof(Derived8) &lt;&lt; endl; cout &lt;&lt; "size of Derived9:" &lt;&lt; sizeof(Derived9) &lt;&lt; endl; cout &lt;&lt; "size of MultiDerived:" &lt;&lt; sizeof(MultiDerived) &lt;&lt; endl; cout &lt;&lt; "size of MultiDerived1:" &lt;&lt; sizeof(MultiDerived1) &lt;&lt; endl; cout &lt;&lt; "size of MultiDerived2:" &lt;&lt; sizeof(MultiDerived2) &lt;&lt; endl; cout &lt;&lt; "size of MultiDerived3:" &lt;&lt; sizeof(MultiDerived3) &lt;&lt; endl; cout &lt;&lt; "size of MultiDerived4:" &lt;&lt; sizeof(MultiDerived4) &lt;&lt; endl; cout &lt;&lt; "size of MultiDerived5:" &lt;&lt; sizeof(MultiDerived5) &lt;&lt; endl; cout &lt;&lt; "size of MultiDerived6:" &lt;&lt; sizeof(MultiDerived6) &lt;&lt; endl; cout &lt;&lt; "size of Foo:" &lt;&lt; sizeof(Foo) &lt;&lt; endl; cout &lt;&lt; "size of Foo1:" &lt;&lt; sizeof(Foo1) &lt;&lt; endl; cout &lt;&lt; "size of Foo2:" &lt;&lt; sizeof(Foo2) &lt;&lt; endl; return 0;&#125; 运行结果为： size of Empty:1size of Derived1:1size of Derived2:4size of Derived3:1size of Derived4:4size of Derived5:2size of Derived6:1size of Derived7:5size of Derived8:7size of Derived9:9size of MultiDerived:1size of MultiDerived1:1size of MultiDerived2:1size of MultiDerived3:2size of MultiDerived4:5size of MultiDerived5:5size of MultiDerived6:4size of Foo:8size of Foo1:4size of Foo2:9 我挑选几个比较重要的例子来解释，如何根据判断准则来计算： （注意，程序中我已经设为按1字节对齐了，而不是默认的内存对齐方式！） Derived9123456789101112#pragma pack(1) // 设为按1字节对齐class Empty &#123;&#125;;class Derived2 : public Empty&#123;public: int32_t i32;&#125;;class Derived9 : public Empty&#123; Derived2 a; Derived2 b;&#125;; 准则：假设类Derived继承自空基类Empty，并且Derived类的第一个非静态成员变量的类型是空基类Empty，或者空基类Empty的派生类，那么不执行空基类优化，因为如果被优化，两个连续的空基类可能会出现相同的地址。 分析过程： 1）Derived9继承自空基类Empty，并且Derived9类的第一个非静态成员变量是Derived2类，Derived2类是空基类Empty的派生类，因此不执行优化，故class Derived9 : public Empty这里的Empty被保留下来，分配1字节。 2）Derived9的基类子对象已经构造好了，接下来给Derived9的成员变量分配空间。第一个是Derived2 a，调用Derived2 a的构造函数发现，Derived2继承自空基类Empty，但Derived2的第一个非静态成员变量是int_32t型，不是空基类或者空基类的派生类，因此执行空基类优化，其空基类子对象Empty不分配空间了，只分配了int32_t大小的空间。 3）同理，Derived2 b也只分配了int32_t大小的空间。 4）故此，Derived9的内存空间占用为1 + 4 + 4 = 9。（再次强调，我在程序中已经设为1字节对齐了，如果默认对齐方式的话，占用的空间将会是12） MultiDerived1234#pragma pack(1) // 设为按1字节对齐class Empty &#123;&#125;;class Empty1 &#123;&#125;;class MultiDerived : public Empty, public Empty1 &#123;&#125;; 编译器不会给两个不同的基类的子对象分配相同的地址，因此这里是可以优化了，但最后又必须保证至少有一个字节。因此内存占用空间为1;。 MultiDerived4、5、6123456789101112131415161718192021#pragma pack(1) // 设为按1字节对齐class MultiDerived1 : public Empty &#123;&#125;;class MultiDerived2 : public Empty &#123;&#125;;class MultiDerived3 : public MultiDerived1, public MultiDerived2 &#123;&#125;;class NotEmpty &#123;public: int32_t i32;&#125;;class MultiDerived4 : public MultiDerived1, public NotEmpty&#123;public: Empty e;&#125;;class MultiDerived5 : public NotEmpty, public MultiDerived1&#123;public: Empty e;&#125;;class MultiDerived6 : public NotEmpty, public MultiDerived1 &#123;&#125;; 分析： 1）MultiDerived4继承自两个不同的基类MultiDerived1，NotEmpty，编译器不会给两个不同的基类分配相同的地址，因此可以进行空基类优化。MultiDerived1被优化后，不占用空间，而NotEmpty占用4个字节，成员变量Empty占用1个字节，因此整个MultiDerived4占用的空间为5个字节。 2）MultiDerived5同上 3）MultiDerived6也一样，只不过没有Empty成员变量，所以只占用4个字节。 Foo1、2123456789101112131415161718192021222324252627282930#pragma pack(1) // 设为按1字节对齐class Derived2 : public Empty&#123;public: int32_t i32;&#125;;class Foo&#123;public: Empty e[4]; Derived2 d;&#125;;class Foo1Helper : public Empty&#123;public: std::int8_t i8[3];&#125;;class Foo1 : public Empty&#123;public: Foo1Helper d;&#125;;class Foo2 : public Empty&#123;public: Foo f;&#125;; 分析： 1）Foo中，Empty成员数组没办法优化，占4个字节。Derived2 d的空基类可以优化，Derived2 d占4个字节。故Foo占8个字节 2）Foo1继承自空基类，并且其第一个非静态成员变量Foo1Helper d是空基类Empty的派生类，不能优化class Foo1 : public Empty这里的Empty。然后构造成员变量Foo1Helper d，其继承自空基类，但第一个非静态成员变量int8_t不是空基类，或者空基类的派生类，因此class Foo1Helper : public Empty的Empty可以优化掉。故Foo1占用的空间为Foo1的基类Empty + Derived2的int32_t成员变量 = 1 + 4 = 5个字节 3）Foo2继承自空基类，并且其第一个非静态成员变量Foo的第一个非静态成员变量是Empty e[4]，是空基类，因此不能优化class Foo2 : public Empty这里的Empty。然后构造成员变量Foo，由1）中的分析已经知道，其占用8个字节。因此Foo2占用的空间为Foo2的基类Empty + Empty e[4] + Derived2 d = 1 + 4 + 4 = 9 空类的作用如果不希望某个类被复制或拷贝，那么可以利用空类来达到这个目的。现实中也是存在的，很多东西是独一无二的，不可能有一模一样的，因此是不可复制的，如果进行复制，编译器应该报错。 1234class Uncopyable&#123; &#125; 总结几个注意点： 1）准则：假设类Derived继承自空基类Empty，并且Derived类的第一个非静态成员变量的类型是空基类Empty，或者空基类Empty的派生类，那么不执行空基类优化，因为如果被优化，两个连续的空基类可能会出现相同的地址。 2）编译器不会给两个不同的基类的子对象分配相同的地址 3）在找第一个非静态成员变量时，是一直往底层走的，就像Foo2的分析中，第一个非静态成员变量可以说是Foo，但往底层说的话，其实是Empty e[4]。所以才会说class Foo2 : public Empty的Empty不能优化掉 参考文献[1] 空类（empty class） [2] CppReference 能力有限，不对之处，还请指教]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[overload override overwrite]]></title>
    <url>%2F2018%2F09%2F21%2FC%E5%92%8CC%2B%2B%2Foverload-override-overwrite%2F</url>
    <content type="text"><![CDATA[overload函数重载。多个函数函数名相同，但参数列表不同。特点： (1) 同一类中 (2) 函数名相同 (3) 参数列表不同 override函数覆盖。派生类函数覆盖基类虚函数。特点： (1) 分别位于派生类和基类中 (2) 函数名相同 (3) 参数列表相同 (4) 基类函数必须为虚函数 overwrite函数重写。派生类函数隐藏基类函数。特点： (1) 分别位于派生类和基类中 (2) 函数名相同 (3) 参数列表相同且基类函数不是虚函数 或者 参数列表不同且基类函数是虚函数 或者 参数列表不同且基类函数不是虚函数。 三者如何执行重载：看参数 覆盖：指针所指内容的实际类型是什么类的就调用什么类的函数 隐藏：指针是什么类就调用什么类的函数 总结overload和另外两个(override和overwrite)最大的区别在于它是针对同一类中的函数。而另外两个是针对派生类和基类之间的函数。 override和overwrite都要求函数名相同，但分别对参数列表是否相同，基类函数是否为虚函数 共计四种情况区分。 override：参数列表相同，基类函数为虚函数（占据其中一种情况） overwrite：参数列表相同且基类函数不是虚函数 或者 参数列表不同且基类函数是虚函数 或者 参数列表不同且基类函数不是虚函数。（占据其中三种情况） 参考文献[1] CSDN 天下无霜]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL]]></title>
    <url>%2F2018%2F09%2F20%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2FMySQL%2F</url>
    <content type="text"><![CDATA[安装MySQL 环境：deepin15.5 安装方式1：通过apt-get方式(需要先配置apt repository) 1. 下载MySQL apt repository的配置deb包 配置deb包下载地址 2. 安装配置deb包 12# 进入配置deb包所在目录$ sudo dpkg -i mysql-apt-config_0.8.10-1_all.deb # 这是我下载的版本 3. 更新apt repository 1$ sudo apt-get update 4. apt下载mysql-server 1sudo apt-get install mysql-server 5. apt下载mysql-workbench 1sudo apt-get install mysql-workbench 环境：deepin15.5 安装方式2：通过tar.gz压缩包来安装 1. 下载MySQL压缩包 mysql-8.0.12-linux-glibc2.12-x86_64.tar.xz 2. 解压并移动到/usr/local/mysql 123$ tar -zxvf mysql-8.0.12-linux-glibc2.12-x86_64.tar.xz$ mv mysql-8.0.12-linux-glibc2.12-x86_64 /usr/local/mysql$ cd /usr/local/mysql 3. 创建用户组和用户 123456# 先查看是否已经有mysql用户组和用户名$ groups mysqlmysql:mysql# 如果没有mysql用户组和用户，则创建$ groupadd mysql$ useradd -r -g mysql mysql 4. 修改/usr/local/mysql目录的权限 1234567# 切换到root用户$ sudo -i# 将/usr/local/mysql目录设置为mysql:mysql$ chown mysql:mysql ./# 创建mysql-files目录并设置权限$ mkdir mysql-files$ chmod 750 mysql-files 5. 初始化数据库 1$ bin/mysqld --initialize --user=mysql 初始化过程生成了一个临时密码：&amp;t+5f1iPriUu。记得保存改密码，后面要用到。 6. 安装SSL服务 12$ apt install openssl$ bin/mysql_ssl_rsa_setup 7. 复制服务文件 1cp support-files/mysql.server /etc/init.d/mysql.server 使用MySQL1. 开启服务 1$ bin/mysqld --user=mysql &amp; 2. 使用用户root登陆 123# 使用前面生成的临时密码登陆root$ bin/mysql -uroot -pEnter passwd:&amp;t+5f1iPriUu 3. 更改root用户密码 用临时密码登陆之后需要先修改成自己的密码之后才能使用。我使用的是方案二。 (1) 方案一：限制本地登陆 12mysql&gt; ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;新密码&apos;;mysql&gt; flush privileges; (2) 方案二：可以任意IP与第三方客户端登陆 12345678910#修改root的密码与加密方式mysql&gt; ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;新的密码&apos; PASSWORD EXPIRE NEVER; #切换到mysql库mysql&gt; use mysql; #更改可以登录的IP为任意IPmysql&gt; update user set host=&apos;%&apos; where user = &apos;root&apos;; #再次更改root用户密码，使其可以在任意IP访问mysql&gt; ALTER USER &apos;root&apos;@&apos;%&apos; IDENTIFIED WITH mysql_native_password BY &apos;2344&apos;;#刷新权限mysql&gt; flush privileges; 4. 创建mysql的快捷方式 创建快捷方式，从而可以在任何目录下都可以直接运行mysql 1234# 创建快捷方式$ ln -s /usr/local/mysql/bin/mysql /usr/local/bin/mysql# 运行$ mysql -uroot -p MySQL图形界面MySQL workbench: MySQL官方的图形界面软件，不过我在deepin下使用偶尔会出现乱码，而且弹出警告说未识别的操作系统 Dbeaver：第三方的图形界面软件，支持多种不同的DBMS。 安装Dbeaver 12# 安装社区版本(community edtion)$ sudo apt-get install dbeaver-ce 参考文献[1] 如何在Linux上安装MySQL8.0.11 [2] Linux下安装MySQL]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>后台</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[现代C++]]></title>
    <url>%2F2018%2F09%2F20%2FC%E5%92%8CC%2B%2B%2F%E7%8E%B0%E4%BB%A3C%2B%2B%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[字符串操作(待完成)]]></title>
    <url>%2F2018%2F09%2F19%2F%E6%97%A5%E5%B8%B8%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C-%E5%BE%85%E5%AE%8C%E6%88%90%2F</url>
    <content type="text"><![CDATA[将字符串转成整型数 stoi——string转int，同时可以指定转成xxx进制 atoi——char [] 转int]]></content>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逆波兰表达式]]></title>
    <url>%2F2018%2F09%2F19%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[概念逆波兰表达式将所有的操作符置于操作数的后面，即后缀表达式。 计算方法原理：使用栈实现后缀表达式的计算 1.碰到数字，就进栈 2.碰到操作符，就从栈中弹出两个操作数，与操作符共同形成一个操作表达式，计算结果重新入栈 3.最后表达式的结果留在栈中 [“2”, “1”, “+”, “3”, ““] -&gt; ((2 + 1) 3) -&gt; 9 [“4”, “13”, “5”, “/“, “+”] -&gt; (4 + (13 / 5)) -&gt; 6 编程实现1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: int evalRPN(vector&lt;string&gt; &amp;tokens) &#123; stack&lt;int&gt; operands; int length = tokens.size(); if(length &lt;= 0) return 0; int rhs, lhs, result; for (int i = 0; i &lt; length; ++i) &#123; if(tokens[i] == "+" || tokens[i] == "-" || tokens[i] == "*" || tokens[i] == "/") &#123; if(operands.size() &lt; 2) return 0; rhs = operands.top(); operands.pop(); lhs = operands.top(); operands.pop(); if(tokens[i] == "+") result = lhs + rhs; else if(tokens[i] == "-") result = lhs - rhs; else if(tokens[i] == "*") result = lhs * rhs; else if(tokens[i] == "/") result = lhs / rhs; operands.push(result); &#125; else operands.push(stoi(tokens[i])); &#125; return operands.top(); &#125;&#125;;]]></content>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序的partition实现]]></title>
    <url>%2F2018%2F09%2F18%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84partition%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[实现一大话数据结构的实现（p418） 1234567891011121314/* 取最左边的值为pivot，在交换过程中实际的pivot值一直在改变，最终停下来的位置就是pivot的位置 */int partition(SqList *L, int low, int high)&#123; int pivotkey; pivotkey = L-&gt;r[low]; while(low &lt; high) &#123; while(low &lt; high &amp;&amp; L-&gt;r[high] &gt;= pivotkey) high--; swap(L, low, high); while(low &lt; high &amp;&amp; L-&gt;r[low] &lt;= pivotkey) low++; &#125; &#125; 实现二数据结构与算法分析的实现（p182） 1234567891011121314151617/* 取最左边，中间，最右边三者的中间值作为pivot，并且将pivot调到最右边去每次移动两个索引，交换，最后将基准值交换到partition完成的地方 */int i, j;ElementType pivot;pivot = median3(A, left, right);i = left;j = right - 1;for(;;)&#123; while(A[++i] &lt; pivot); while(A[--j] &gt; pivot); if(i &lt; j) swap(&amp;A[i], &amp; A[j]); else break; swap(&amp;A[i], &amp;A[right - 1])&#125; 实现三leetcode某道题出现的解法：Kth Largest Element in an Array-time) 1234567891011121314/* 取最右边的值为pivot，每次都将大于pivot的值交换到左边 最终将基准值交换到partition完成的地方 */int partition(int []a, int low, int high)&#123; int i = low; int j = high; int pivot = a[high]; while(i &lt; j) &#123; if(a[i++] &gt; pivot) swap(a, --i, --j); &#125; swap(a, i, high)&#125;]]></content>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-蓝牙键盘]]></title>
    <url>%2F2018%2F09%2F17%2F%E6%97%A5%E5%B8%B8%2Flinux-%E8%93%9D%E7%89%99%E9%94%AE%E7%9B%98%2F</url>
    <content type="text"><![CDATA[Linux下蓝牙键盘的配对使用 查看本机是否有蓝牙适配器1$ lsusb 设置蓝牙123456789101112# 进入蓝牙控制器$ bluetoothctl# 打开蓝牙[bluetooth]# power on[bluetooth]# default-agent# 配对蓝牙键盘[bluetooth]# pairable on[bluetooth]# scan on[bluetooth]# pair 34:88:5D:7E:42:04[bluetooth]# trust 34:88:5D:7E:42:04# 连接[bluetooth]# connect 34:88:5D:7E:42:04]]></content>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unix环境高级编程_阅读]]></title>
    <url>%2F2018%2F09%2F12%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2Funix%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E9%98%85%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[进程控制的三个主要函数：fork，exec和waitpid]]></content>
      <tags>
        <tag>编程</tag>
        <tag>unix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tinyhttpd解读]]></title>
    <url>%2F2018%2F08%2F22%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2Ftinyhttp%2F</url>
    <content type="text"><![CDATA[tinyhttp的作用]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim技巧]]></title>
    <url>%2F2018%2F07%2F28%2F%E6%97%A5%E5%B8%B8%2Fvim-skills%2F</url>
    <content type="text"><![CDATA[vim图 功能 快捷键 vim上下两行交换 ddp vim左右两个字符交换 xp 替换一个字符 r 删除一个字符，并进入编辑状态 s 删除一个字符，仍处于命令状态 x 正向修改一个单词，并进入编辑状态 cw 正向修改一个单词，仍处于命令状态 dw 正向修改n个单词，比如3个单词 c3w或者d3w 逆向修改n个单词，比如3个单词 c3b或者c3b 修改光标所在位置至行尾 c$或者C 修改光标所在位置至行首 c0 删除一行，并进入编辑状态 cc 删除一行，仍处于命令状态 dd 一个字母大小写转换 ~ 替换一个字符，并进入编辑状态 R 替换一个字符，仍处于命令状态 r 向下移动n行，比如3行 3j 向上移动n行，比如3行 3k 向左移动n个字符，比如3个字符 3h 向右移动n个字符 3l 向左移动n个单词 3b 向右移动n个单词 3w 移动到行首 ^ 移动到行尾 $ 移动到文件头 gg 移动到文件尾 G 移动到第n行，比如第3行 3gg]]></content>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表问题集锦]]></title>
    <url>%2F2018%2F07%2F27%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E9%93%BE%E8%A1%A8%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6%2F</url>
    <content type="text"><![CDATA[转载自：http://wuchong.me/blog/2014/03/25/interview-link-questions/ 作者：Jark’s Blog 链表问题在面试过程中也是很重要也很基础的一部分，链表本身很灵活，很考查编程功底，所以是很值得考的地方。我将复习过程中觉得比较好的链表问题整理了下。 下面是本文所要用到链表节点的定义：1234struct Node&#123; int data; Node* next;&#125;; 1. 在O(1)时间删除链表节点题目描述：给定链表的头指针和一个节点指针，在O(1)时间删除该节点。[Google面试题] 分析：本题与《编程之美》上的「从无头单链表中删除节点」类似。主要思想都是「狸猫换太子」，即用下一个节点数据覆盖要删除的节点，然后删除下一个节点。但是如果节点是尾节点时，该方法就行不通了。 代码如下：12345678910//O(1)时间删除链表节点，从无头单链表中删除节点void deleteRandomNode(Node *cur)&#123; assert(cur != NULL); assert(cur-&gt;next != NULL); //不能是尾节点 Node* pNext = cur-&gt;next; cur-&gt;data = pNext-&gt;data; cur-&gt;next = pNext-&gt;next; delete pNext;&#125; 2. 单链表的转置题目描述：输入一个单向链表，输出逆序反转后的链表 分析：链表的转置是一个很常见、很基础的数据结构题了，非递归的算法很简单，用三个临时指针 pre、head、next 在链表上循环一遍即可。递归算法也是比较简单的，但是如果思路不清晰估计一时半会儿也写不出来吧。 下面是循环版本和递归版本的链表转置代码：123456789101112131415161718192021222324252627//单链表的转置,循环方法Node* reverseByLoop(Node *head)&#123; if(head == NULL || head-&gt;next == NULL) return head; Node *pre = NULL; Node *next = NULL; while(head != NULL) &#123; next = head-&gt;next; head-&gt;next = pre; pre = head; head = next; &#125; return pre;&#125;//单链表的转置,递归方法Node* reverseByRecursion(Node *head)&#123; //第一个条件是判断异常，第二个条件是结束判断 if(head == NULL || head-&gt;next == NULL) return head; Node *newHead = reverseByRecursion(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = NULL; return newHead; //返回新链表的头指针&#125; 3. 求链表倒数第k个节点题目描述：输入一个单向链表，输出该链表中倒数第k个节点，链表的倒数第0个节点为链表的尾指针。 分析：设置两个指针 p1、p2，首先 p1 和 p2 都指向 head，然后 p2 向前走 k 步，这样 p1 和 p2 之间就间隔 k 个节点，最后 p1 和 p2 同时向前移动，直至 p2 走到链表末尾。 代码如下：12345678910111213141516171819//倒数第k个节点Node* theKthNode(Node *head,int k)&#123; if(k &lt; 0) return NULL; //异常判断 Node *slow,*fast; slow = fast = head; int i = k; for(;i&gt;0 &amp;&amp; fast!=NULL;i--) &#123; fast = fast-&gt;next; &#125; if(i &gt; 0) return NULL; //考虑k大于链表长度的case while(fast != NULL) &#123; slow = slow-&gt;next; fast = fast-&gt;next; &#125; return slow;&#125; 4. 求链表的中间节点题目描述：求链表的中间节点，如果链表的长度为偶数，返回中间两个节点的任意一个，若为奇数，则返回中间节点。 分析：此题的解决思路和第3题「求链表的倒数第 k 个节点」很相似。可以先求链表的长度，然后计算出中间节点所在链表顺序的位置。但是如果要求只能扫描一遍链表，如何解决呢？最高效的解法和第3题一样，通过两个指针来完成。用两个指针从链表头节点开始，一个指针每次向后移动两步，一个每次移动一步，直到快指针移到到尾节点，那么慢指针即是所求。 代码如下：12345678910111213141516//求链表的中间节点Node* theMiddleNode(Node *head)&#123; if(head == NULL) return NULL; Node *slow,*fast; slow = fast = head; //如果要求在链表长度为偶数的情况下，返回中间两个节点的第一个，可以用下面的循环条件 //while(fast &amp;&amp; fast-&gt;next != NULL &amp;&amp; fast-&gt;next-&gt;next != NULL) while(fast != NULL &amp;&amp; fast-&gt;next != NULL) &#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; &#125; return slow;&#125; 5. 判断单链表是否存在环题目描述：输入一个单向链表，判断链表是否有环？ 分析：通过两个指针，分别从链表的头节点出发，一个每次向后移动一步，另一个移动两步，两个指针移动速度不一样，如果存在环，那么两个指针一定会在环里相遇。 代码如下：1234567891011121314151617//判断单链表是否存在环,参数circleNode是环内节点，后面的题目会用到bool hasCircle(Node *head,Node *&amp;circleNode)&#123; Node *slow,*fast; slow = fast = head; while(fast != NULL &amp;&amp; fast-&gt;next != NULL) &#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if(fast == slow) &#123; circleNode = fast; return true; &#125; &#125; return false;&#125; 6. 找到环的入口点题目描述：输入一个单向链表，判断链表是否有环。如果链表存在环，如何找到环的入口点？ 解题思路： 由上题可知，按照 p2 每次两步，p1 每次一步的方式走，发现 p2 和 p1 重合，确定了单向链表有环路了。接下来，让p2回到链表的头部，重新走，每次步长不是走2了，而是走1，那么当 p1 和 p2 再次相遇的时候，就是环路的入口了。 为什么？：假定起点到环入口点的距离为 a，p1 和 p2 的相交点M与环入口点的距离为b，环路的周长为L，当 p1 和 p2 第一次相遇的时候，假定 p1 走了 n 步。那么有： p1走的路径： a+b ＝ n；p2走的路径： a+b+kL = 2n； p2 比 p1 多走了k圈环路，总路程是p1的2倍 根据上述公式可以得到 k*L=a+b=n显然，如果从相遇点M开始，p1 再走 n 步的话，还可以再回到相遇点，同时p2从头开始走的话，经过n步，也会达到相遇点M。 显然在这个步骤当中 p1 和 p2 只有前 a 步走的路径不同，所以当 p1 和 p2 再次重合的时候，必然是在链表的环路入口点上。 代码如下：123456789101112131415161718192021222324//找到环的入口点Node* findLoopPort(Node *head)&#123; //如果head为空，或者为单结点，则不存在环 if(head == NULL || head-&gt;next == NULL) return NULL; Node *slow,*fast; slow = fast = head; //先判断是否存在环 while(fast != NULL &amp;&amp; fast-&gt;next != NULL) &#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if(fast == slow) break; &#125; if(fast != slow) return NULL; //不存在环 fast = head; //快指针从头开始走，步长变为1 while(fast != slow) //两者相遇即为入口点 &#123; fast = fast-&gt;next; slow = slow-&gt;next; &#125; return fast;&#125; 7. 编程判断两个链表是否相交题目描述：给出两个单向链表的头指针（如下图所示）， 比如h1、h2，判断这两个链表是否相交。这里为了简化问题，我们假设两个链表均不带环。 解题思路： 直接循环判断第一个链表的每个节点是否在第二个链表中。但，这种方法的时间复杂度为O(Length(h1) * Length(h2))。显然，我们得找到一种更为有效的方法，至少不能是O（N^2）的复杂度。 针对第一个链表直接构造hash表，然后查询hash表，判断第二个链表的每个节点是否在hash表出现，如果所有的第二个链表的节点都能在hash表中找到，即说明第二个链表与第一个链表有相同的节点。时间复杂度为为线性：O(Length(h1) + Length(h2))，同时为了存储第一个链表的所有节点，空间复杂度为O(Length(h1))。是否还有更好的方法呢，既能够以线性时间复杂度解决问题，又能减少存储空间？ 转换为环的问题。把第二个链表接在第一个链表后面，如果得到的链表有环，则说明两个链表相交。如何判断有环的问题上面已经讨论过了，但这里有更简单的方法。因为如果有环，则第二个链表的表头一定也在环上，即第二个链表会构成一个循环链表，我们只需要遍历第二个链表，看是否会回到起始点就可以判断出来。这个方法的时间复杂度是线性的，空间是常熟。 进一步考虑“如果两个没有环的链表相交于某一节点，那么在这个节点之后的所有节点都是两个链表共有的”这个特点，我们可以知道，如果它们相交，则最后一个节点一定是共有的。而我们很容易能得到链表的最后一个节点，所以这成了我们简化解法的一个主要突破口。那么，我们只要判断两个链表的尾指针是否相等。相等，则链表相交；否则，链表不相交。所以，先遍历第一个链表，记住最后一个节点。然后遍历第二个链表，到最后一个节点时和第一个链表的最后一个节点做比较，如果相同，则相交，否则，不相交。这样我们就得到了一个时间复杂度，它为O((Length(h1) + Length(h2))，而且只用了一个额外的指针来存储最后一个节点。这个方法时间复杂度为线性O(N)，空间复杂度为O(1)，显然比解法三更胜一筹。 解法四的代码如下：123456789101112131415//判断两个链表是否相交bool isIntersect(Node *h1,Node *h2)&#123; if(h1 == NULL || h2 == NULL) return false; //异常判断 while(h1-&gt;next != NULL) &#123; h1 = h1-&gt;next; &#125; while(h2-&gt;next != NULL) &#123; h2 = h2-&gt;next; &#125; if(h1 == h2) return true; //尾节点是否相同 else return false;&#125; 8. 扩展：链表有环，如何判断相交题目描述：上面的问题都是针对链表无环的，那么如果现在，链表是有环的呢?上面的方法还同样有效么? 分析：如果有环且两个链表相交，则两个链表都有共同一个环，即环上的任意一个节点都存在于两个链表上。因此，就可以判断一链表上俩指针相遇的那个节点，在不在另一条链表上。 代码如下：1234567891011121314151617//判断两个带环链表是否相交bool isIntersectWithLoop(Node *h1,Node *h2)&#123; Node *circleNode1,*circleNode2; if(!hasCircle(h1,circleNode1)) //判断链表带不带环，并保存环内节点 return false; //不带环，异常退出 if(!hasCircle(h2,circleNode2)) return false; Node *temp = circleNode2-&gt;next; while(temp != circleNode2) &#123; if(temp == circleNode1) return true; temp = temp-&gt;next; &#125; return false;&#125; 9. 扩展：两链表相交的第一个公共节点题目描述：如果两个无环单链表相交，怎么求出他们相交的第一个节点呢？ 分析：采用对齐的思想。计算两个链表的长度 L1 , L2，分别用两个指针 p1 , p2 指向两个链表的头，然后将较长链表的 p1（假设为 p1）向后移动L2 - L1个节点，然后再同时向后移动p1 , p2，直到 p1 = p2。相遇的点就是相交的第一个节点。 代码如下：12345678910111213141516171819202122232425//求两链表相交的第一个公共节点Node* findIntersectNode(Node *h1,Node *h2)&#123; int len1 = listLength(h1); //求链表长度 int len2 = listLength(h2); //对齐两个链表 if(len1 &gt; len2) &#123; for(int i=0;i&lt;len1-len2;i++) h1=h1-&gt;next; &#125; else &#123; for(int i=0;i&lt;len2-len1;i++) h2=h2-&gt;next; &#125; while(h1 != NULL) &#123; if(h1 == h2) return h1; h1 = h1-&gt;next; h2 = h2-&gt;next; &#125; return NULL;&#125; 10. 总结可以发现，在链表的问题中，通过两个的指针来提高效率是很值得考虑的一个解决方案，所以一定要记住这种解题思路。记住几种典型的链表问题解决方案，很多类似的题目都可以转换到熟悉的问题再解决。 参考文献程序员编程艺术：第九章、闲话链表追赶问题判断单链表是否存在环，判断两个链表是否相交问题详解面试算法之链表操作集锦]]></content>
      <tags>
        <tag>转载</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法问题集锦]]></title>
    <url>%2F2018%2F07%2F24%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6%2F</url>
    <content type="text"><![CDATA[1. 二叉树的性质性质1 在二叉树的第 i 层至多有 2^(i - 1)个结点。(i&gt;=1) 性质2 深度为 k 的二叉树至多有 2^k - 1个结点(k &gt;=1) 性质3 对任何一棵二叉树T, 如果其叶结点数为n0, 度为2的结点数为 n2,则n0＝n2＋1。 性质4 具有 n (n&gt;=0) 个结点的完全二叉树的深度为[log2(n)]＋1 性质5 如将一棵有n个结点的完全二叉树自顶向下，同层自左向右连续为结点编号0,1, …, n-1，则有： ​ 1）若i = 0, 则 i 无双亲, 若i &gt; 0, 则 i 的双亲为」(i -1)/2」 ​ 2）若2i+1 &lt; n, 则i 的左子女为 2i+1，若2i+2 &lt; n, 则 i 的右子女为2i+2 ​ 3）若结点编号i为偶数，且i != 0,则左兄弟结点i-1. ​ 4）若结点编号i为奇数，且i != n-1,则右兄弟结点为i+1. ​ 5）结点i 所在层次为」log2(i+1) 」 2. 广义表广义表是线性表的推广。一般我们的线性表的元素都是基本数据类型或者结构体之类的不可分割的原子，但是广义表推而广之，其元素既可以是各不可分割的院子，也可以是子表(线性表，或者广义表等数据结构)。 3. 以下容器vector 底层数据结构为数组，支持快速随机访问list 底层数据结构为双向链表，支持快速增删map、set都是STL关联容器，支持快速增删 4. 后缀表达式计算方法——数字入栈（遇到运算符就出栈两个）后缀表达式：9 3 1 - 3 * + 10 2 / +规则：从左到右遍历表达式的每个数字和符号，遇到数字就进栈，遇到符号时，则将栈顶两个数字出栈，进行运算，运算结果重新入栈，知道最后栈为空。 5. 中缀表达式转后缀表达式——符号入栈（高优先级或者前辈先出栈）已知中缀表达式：9 + ( 3 - 1) * 3 + 10 / 2,将其转成后缀表达式规则：从左到右遍历表达式的每个数字和符号，遇到数字就输出（成为后缀表达式的一部分）；遇到符号，则判断其与栈顶符号的优先级，如果是右括号或者优先级≤栈顶符号的话（级别高的先出栈，或者级别相同，那么前辈先出栈，晚辈过来填坑），则让栈顶元素一次出栈，并输出，并将当前符号入栈 6. 循环队列如果是用数组来实现循环队列的话： 1) 何时为空？ 当rear = = front时，队列为空 2)何时为满？ 当(rear+1)%MAXSIZE = = front时，队列满 3) 怎么增加？ 如果rear+1 == MAXSIZE，则让rear = 0；否则，直接rear++即可 4) 怎么删除？ 如果如果front+1 == MAXSIZE，则让front = 0；否则，直接front++即可 5) 队列长度 (rear - front + MAXSIZE) % MAXSIZE]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统问题集锦]]></title>
    <url>%2F2018%2F07%2F24%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6%2F</url>
    <content type="text"><![CDATA[基本特征 并发——同一时刻仿佛多个程序在跑 共享——同一资源被多个并发进程共同使用 虚拟——一个物理实体转换成多个逻辑实体；时分复用，空分复用技术 异步——进程不是一次性走完，而是走走停停 基本功能 进程管理——进程控制，进程同步，进程通信，死锁处理，处理机调度 内存管理——内存分配，地址映射，内存保护与共享，虚拟内存 文件管理——文件存储空间的管理，目录管理，文件读写管理和保护 设备管理——缓冲管理]]></content>
      <tags>
        <tag>操作系统</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 虚函数表解析]]></title>
    <url>%2F2018%2F07%2F23%2FC%E5%92%8CC%2B%2B%2FC%2B%2B%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[转载自：https://coolshell.cn/articles/12165.html 作者：陈皓 附录二的例程非常重要！！！ C++中的虚函数的作用主要是实现了多态的机制。关于多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。所谓泛型技术，说白了就是试图使用不变的代码来实现可变的算法。比如：模板技术，RTTI技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到运行时决议。 关于虚函数的使用方法，我在这里不做过多的阐述。大家可以看看相关的C++的书籍。在这篇文章中，我只想从虚函数的实现机制上面为大家 一个清晰的剖析。 当然，相同的文章在网上也出现过一些了，但我总感觉这些文章不是很容易阅读，大段大段的代码，没有图片，没有详细的说明，没有比较，没有举一反三。不利于学习和阅读，所以这是我想写下这篇文章的原因。也希望大家多给我提意见。 言归正传，让我们一起进入虚函数的世界。 虚函数表对C++ 了解的人都应该知道虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的。简称为V-Table。在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数。这样，在有虚函数的类的实例中这个表被分配在了这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得由为重要了，它就像一个地图一样，指明了实际所应该调用的函数。 这里我们着重看一下这张虚函数表。C++的编译器应该是保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证取到虚函数表的有最高的性能——如果有多层继承或是多重继承的情况下）。 这意味着我们通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。 听我扯了那么多，我可以感觉出来你现在可能比以前更加晕头转向了。 没关系，下面就是实际的例子，相信聪明的你一看就明白了。 假设我们有这样的一个类： 1234567class Base &#123; public: virtual void f() &#123; cout &lt;&lt; "Base::f" &lt;&lt; endl; &#125; virtual void g() &#123; cout &lt;&lt; "Base::g" &lt;&lt; endl; &#125; virtual void h() &#123; cout &lt;&lt; "Base::h" &lt;&lt; endl; &#125; &#125;; 按照上面的说法，我们可以通过Base的实例来得到虚函数表。 下面是实际例程： 123456789101112typedef void(*Fun)(void); Base b; Fun pFun = NULL; cout &lt;&lt; "虚函数表地址：" &lt;&lt; (int*)(&amp;b) &lt;&lt; endl;cout &lt;&lt; "虚函数表 — 第一个函数地址：" &lt;&lt; (int*)*(int*)(&amp;b) &lt;&lt; endl; // Invoke the first virtual functionpFun = (Fun)*((int*)*(int*)(&amp;b));pFun(); 实际运行经果如下：(Windows XP+VS2003, Linux 2.6.22 + GCC 4.1.3) 虚函数表地址：0012FED4虚函数表 — 第一个函数地址：0044F148Base::f 通过这个示例，我们可以看到，我们可以通过强行把&amp;b转成int ，取得虚函数表的地址，然后，再次取址就可以得到第一个虚函数的地址了，也就是Base::f()，这在上面的程序中得到了验证（把int 强制转成了函数指针）。通过这个示例，我们就可以知道如果要调用Base::g()和Base::h()，其代码如下： 123(Fun)*((int*)*(int*)(&amp;b)+0); // Base::f()(Fun)*((int*)*(int*)(&amp;b)+1); // Base::g()(Fun)*((int*)*(int*)(&amp;b)+2); // Base::h() 这个时候你应该懂了吧。什么？还是有点晕。也是，这样的代码看着太乱了。没问题，让我画个图解释一下。如下所示： 注意：在上面这个图中，我在虚函数表的最后多加了一个结点，这是虚函数表的结束结点，就像字符串的结束符“/0”一样，其标志了虚函数表的结束。这个结束标志的值在不同的编译器下是不同的。在WinXP+VS2003下，这个值是NULL。而在Ubuntu 7.10 + Linux 2.6.22 + GCC 4.1.3下，这个值是如果1，表示还有下一个虚函数表，如果值是0，表示是最后一个虚函数表。 下面，我将分别说明“无覆盖”和“有覆盖”时的虚函数表的样子。没有覆盖父类的虚函数是毫无意义的。我之所以要讲述没有覆盖的情况，主要目的是为了给一个对比。在比较之下，我们可以更加清楚地知道其内部的具体实现。 一般继承（无虚函数覆盖）下面，再让我们来看看继承时的虚函数表是什么样的。假设有如下所示的一个继承关系： 请注意，在这个继承关系中，子类没有重载任何父类的函数。那么，在派生类的实例中，其虚函数表如下所示： 对于实例：Derive d; 的虚函数表如下： 我们可以看到下面几点：1）虚函数按照其声明顺序放于表中。2）父类的虚函数在子类的虚函数前面。 我相信聪明的你一定可以参考前面的那个程序，来编写一段程序来验证。 一般继承（有虚函数覆盖）覆盖父类的虚函数是很显然的事情，不然，虚函数就变得毫无意义。下面，我们来看一下，如果子类中有虚函数重载了父类的虚函数，会是一个什么样子？假设，我们有下面这样的一个继承关系。 为了让大家看到被继承过后的效果，在这个类的设计中，我只覆盖了父类的一个函数：f()。那么，对于派生类的实例，其虚函数表会是下面的一个样子： 我们从表中可以看到下面几点，1）覆盖的f()函数被放到了虚表中原来父类虚函数的位置。2）没有被覆盖的函数依旧。 这样，我们就可以看到对于下面这样的程序， 123Base *b = new Derive(); b-&gt;f(); 由b所指的内存中的虚函数表的f()的位置已经被Derive::f()函数地址所取代，于是在实际调用发生时，是Derive::f()被调用了。这就实现了多态。 多重继承（无虚函数覆盖）下面，再让我们来看看多重继承中的情况，假设有下面这样一个类的继承关系。注意：子类并没有覆盖父类的函数。 对于子类实例中的虚函数表，是下面这个样子： 我们可以看到：1） 每个父类都有自己的虚表。2） 子类的成员函数被放到了第一个父类的表中。（所谓的第一个父类是按照声明顺序来判断的） 这样做就是为了解决不同的父类类型的指针指向同一个子类实例，而能够调用到实际的函数。 多重继承（有虚函数覆盖）下面我们再来看看，如果发生虚函数覆盖的情况。 下图中，我们在子类中覆盖了父类的f()函数。 下面是对于子类实例中的虚函数表的图： 我们可以看见，三个父类虚函数表中的f()的位置被替换成了子类的函数指针。这样，我们就可以任一静态类型的父类来指向子类，并调用子类的f()了。如： 1234567891011Derive d;Base1 *b1 = &amp;d;Base2 *b2 = &amp;d;Base3 *b3 = &amp;d;b1-&gt;f(); //Derive::f()b2-&gt;f(); //Derive::f()b3-&gt;f(); //Derive::f() b1-&gt;g(); //Base1::g()b2-&gt;g(); //Base2::g()b3-&gt;g(); //Base3::g() 安全性每次写C++的文章，总免不了要批判一下C++。这篇文章也不例外。通过上面的讲述，相信我们对虚函数表有一个比较细致的了解了。水可载舟，亦可覆舟。下面，让我们来看看我们可以用虚函数表来干点什么坏事吧。 一、通过父类型的指针访问子类自己的虚函数我们知道，子类没有重载父类的虚函数是一件毫无意义的事情。因为多态也是要基于函数重载的。虽然在上面的图中我们可以看到Base1的虚表中有Derive的虚函数，但我们根本不可能使用下面的语句来调用子类的自有虚函数： 12Base1 *b1 = new Derive();b1-&gt;f1(); //编译出错 任何妄图使用父类指针想调用子类中的未覆盖父类的成员函数的行为都会被编译器视为非法，所以，这样的程序根本无法编译通过。但在运行时，我们可以通过指针的方式访问虚函数表来达到违反C++语义的行为。（关于这方面的尝试，通过阅读后面附录的代码，相信你可以做到这一点） 二、访问non-public的虚函数另外，如果父类的虚函数是private或是protected的，但这些非public的虚函数同样会存在于虚函数表中，所以，我们同样可以使用访问虚函数表的方式来访问这些non-public的虚函数，这是很容易做到的。 如： 1234567891011121314151617class Base &#123; private: virtual void f() &#123; cout &lt;&lt; "Base::f" &lt;&lt; endl; &#125; &#125;; class Derive : public Base&#123; &#125;; typedef void(*Fun)(void); void main() &#123; Derive d; Fun pFun = (Fun)*((int*)*(int*)(&amp;d)+0); pFun();&#125; 结束语C++这门语言是一门Magic的语言，对于程序员来说，我们似乎永远摸不清楚这门语言背着我们在干了什么。需要熟悉这门语言，我们就必需要了解C++里面的那些东西，需要去了解C++中那些危险的东西。不然，这是一种搬起石头砸自己脚的编程语言。 附录一：VC中查看虚函数表我们可以在VC的IDE环境中的Debug状态下展开类的实例就可以看到虚函数表了（并不是很完整的） 附录 二：例程下面是一个关于多重继承的虚函数表访问的例程： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;iostream&gt;using namespace std; class Base1 &#123;public: virtual void f() &#123; cout &lt;&lt; "Base1::f" &lt;&lt; endl; &#125; virtual void g() &#123; cout &lt;&lt; "Base1::g" &lt;&lt; endl; &#125; virtual void h() &#123; cout &lt;&lt; "Base1::h" &lt;&lt; endl; &#125; &#125;; class Base2 &#123;public: virtual void f() &#123; cout &lt;&lt; "Base2::f" &lt;&lt; endl; &#125; virtual void g() &#123; cout &lt;&lt; "Base2::g" &lt;&lt; endl; &#125; virtual void h() &#123; cout &lt;&lt; "Base2::h" &lt;&lt; endl; &#125;&#125;; class Base3 &#123;public: virtual void f() &#123; cout &lt;&lt; "Base3::f" &lt;&lt; endl; &#125; virtual void g() &#123; cout &lt;&lt; "Base3::g" &lt;&lt; endl; &#125; virtual void h() &#123; cout &lt;&lt; "Base3::h" &lt;&lt; endl; &#125;&#125;; class Derive : public Base1, public Base2, public Base3 &#123;public: virtual void f() &#123; cout &lt;&lt; "Derive::f" &lt;&lt; endl; &#125; virtual void g1() &#123; cout &lt;&lt; "Derive::g1" &lt;&lt; endl; &#125;&#125;; typedef void(*Fun)(void); int main()&#123; Fun pFun = NULL; Derive d;// 如果是在64位下运行，那么将int换成long，因为int只有4字节(32位)，long才有64位。 int** pVtab = (int**)&amp;d; //Base1's vtable //pFun = (Fun)*((int*)*(int*)((int*)&amp;d+0)+0); pFun = (Fun)pVtab[0][0]; pFun(); //pFun = (Fun)*((int*)*(int*)((int*)&amp;d+0)+1); pFun = (Fun)pVtab[0][1]; pFun(); //pFun = (Fun)*((int*)*(int*)((int*)&amp;d+0)+2); pFun = (Fun)pVtab[0][2]; pFun(); //Derive's vtable //pFun = (Fun)*((int*)*(int*)((int*)&amp;d+0)+3); pFun = (Fun)pVtab[0][3]; pFun(); //The tail of the vtable pFun = (Fun)pVtab[0][4]; cout&lt;&lt;pFun&lt;&lt;endl; //Base2's vtable //pFun = (Fun)*((int*)*(int*)((int*)&amp;d+1)+0); pFun = (Fun)pVtab[1][0]; pFun(); //pFun = (Fun)*((int*)*(int*)((int*)&amp;d+1)+1); pFun = (Fun)pVtab[1][1]; pFun(); pFun = (Fun)pVtab[1][2]; pFun(); //The tail of the vtable pFun = (Fun)pVtab[1][3]; cout&lt;&lt;pFun&lt;&lt;endl; //Base3's vtable //pFun = (Fun)*((int*)*(int*)((int*)&amp;d+1)+0); pFun = (Fun)pVtab[2][0]; pFun(); //pFun = (Fun)*((int*)*(int*)((int*)&amp;d+1)+1); pFun = (Fun)pVtab[2][1]; pFun(); pFun = (Fun)pVtab[2][2]; pFun(); //The tail of the vtable pFun = (Fun)pVtab[2][3]; cout&lt;&lt;pFun&lt;&lt;endl; return 0;&#125; 运行结果如下： 12345678910111213Derive::fBase1::gBase1::hDerive::g11Derive::fBase2::gBase2::h1Derive::fBase3::gBase3::h1 可以看到其结果与理论分析非常吻合！ 注：本文年代久远，所有的示例都是在32位机上跑的。如果要在64位机器上跑，将上面函数表的地址的int改成long（见上面代码注释） (全文完) 关注CoolShell微信公众账号可以在手机端搜索文章 （转载本站文章请注明作者和出处 酷 壳 – CoolShell ，请勿用于任何商业用途） ——=== 访问 酷壳404页面 寻找遗失儿童。 ===——]]></content>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法]]></title>
    <url>%2F2018%2F07%2F20%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2Falgorithms%2F</url>
    <content type="text"><![CDATA[计数排序(Counting Sort)是一种O(n)的排序算法，其思路是开一个长度为maxValue-minValue+1的数组，然后 分配。扫描一遍原始数组，以当前值-minValue作为下标，将该下标的计数器增1。 收集。扫描一遍计数器数组，按顺序把值收集起来。 举个例子，nums=[2, 1, 3, 1, 5], 首先扫描一遍获取最小值和最大值，maxValue=5, minValue=1，于是开一个长度为5的计数器数组counter， 分配。统计每个元素出现的频率，得到counter=[2, 1, 1, 0, 1]，例如counter[0]表示值0+minValue=1出现了2次。 收集。counter[0]=2表示1出现了两次，那就向原始数组写入两个1，counter[1]=1表示2出现了1次，那就向原始数组写入一个2，依次类推，最终原始数组变为[1,1,2,3,5]，排序好了。 计数排序本质上是一种特殊的桶排序，当桶的个数最大的时候，就是计数排序。 动态规划和分治法 动态规划和分治法都是将复杂问题分成子问题，最后再组合子问题，从而求出原问题。 区别在于： 分治法假设子问题之间是相互独立的，如果划分出来的子问题不是相互独立的，那么使用分治法将会有不少子问题重复计算了，效率也就提不上来。 动态规划则可以解决子问题之间相互重叠的情况，可以保证每个子问题只会计算一遍，从而提高效率。]]></content>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[插入排序和希尔排序]]></title>
    <url>%2F2018%2F07%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2Fsort%2F</url>
    <content type="text"><![CDATA[插入排序和希尔排序属于同一类，希尔排序是在插入排序的基础上改进的：是缩小增量的多次插入排序 插入排序 插入排序的思路是： 1.读取元素A[i]，保存到Tmp 2.让Tmp跟A[i]前面的元素比较，如果Tmp比较小，就让被比较的元素往前挪 3.直到Tmp≥某个元素之后，停止挪动，把Tmp的值存到该元素前面 123456789101112void InsertionSort( ElementType A[ ], int Length )&#123; int i, j; ElementType Tmp; for(i = 1; i &lt; Length; i++) // A[0]前面没有元素了，不用插入，因此从下标1开始 &#123; Tmp = A[i]; for(j = i; j &gt; 0 &amp;&amp; Tmp &lt; A[j - 1]; j--) A[j] = A[j - 1]; A[j] = Tmp; &#125;&#125; 希尔排序 动态图可以查看https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html 增量从Length/2开始，不断缩小。 （1）4-排序 i从增量4开始，不断加1，直到最后一个元素的下标 然后对i所指的元素所在的分组进行插入排序 123456789101112131415void Shellsort( ElementType A[ ], int Length )&#123; int i, j, Increment; for(Increment = Length/2; Increment &gt; 0; Increment /= 2) &#123; ElementType Tmp; for(i = Increment; i &lt; Length; i++) // 从Increment到最后一个元素，对每个元素 &#123; Tmp = A[i]; for(j = i; j &gt;= Increment &amp;&amp; Tmp &lt; A[j - Increment]; j -= Increment) A[j] = A[j - Increment]; A[j] = Tmp; &#125; &#125;&#125; 可以看到希尔排序与插入排序是非常相似的。 当Increment=1时，执行的就是插入排序。 这里需要理解的是i的取值，i从Increment取到Length-1。]]></content>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[漫画：快速排序]]></title>
    <url>%2F2018%2F07%2F12%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2Fquick-sort-carton%2F</url>
    <content type="text"><![CDATA[快速排序快速排序是一种“分而治之”的排序算法，通过随机选择“分区点”来避免出现最坏的情况。 随机选择“分区点”。 按照“分区点”的高度划条线。 高出“分区点”的元素需要向右移动。 低于“分区点”的元素需要向左移动。 移动元素。 重复上述的步骤分别对位于“分区点”两边的元素进行排序。]]></content>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红黑树]]></title>
    <url>%2F2018%2F07%2F12%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2Fred-black-tree%2F</url>
    <content type="text"><![CDATA[红色树除了满足二叉树的规则外，还要满足一下规则： 1.节点是红色或黑色。 2.根节点是黑色。 3.每个叶子节点都是黑色的空节点（NIL节点）。 4 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点) 5.从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。 下图中这棵树，就是一颗典型的红黑树： 红黑树插入时，都以红色作为新节点的颜色，因为用黑色百分百破坏规则5，用红色则有可能会破坏规则4。 当红黑树的平衡被破坏时，一般有两种调节的方法： 变色 旋转 左旋转 右旋转]]></content>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[B树，B+树，B*树]]></title>
    <url>%2F2018%2F07%2F12%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2Fb-tree-2%2F</url>
    <content type="text"><![CDATA[转载自：B树、B+树、B*树 作者：xx1994 B-树，就是B树，B树的原英文名是B-tree,所以很多翻译为B-树,就会很多人误以为B-树是一种树、B树是另外一种树。其实，B-tree就是B树。 B树是一种多叉平衡查找树，我们之前所介绍的红黑树是二叉查找树结构，B树由于是多叉结构，对于元素数量非常多的情况下，树的深度不会像二叉结构那么大，可以保证查询效率。 B树的性质（m阶的B树） 树中每个结点最多含有m个孩子（m&gt;=2）； 除根结点和叶子结点外，其它每个结点至少有[ceil(m / 2)]个孩子（其中ceil(x)是一个取上限的函数）； 根结点至少有2个孩子（除非B树只包含一个结点：根结点）； 所有叶子结点都出现在同一层，叶子结点不包含任何关键字信息(可以看做是外部结点或查询失败的结点，指向这些结点的指针都为null)；（注：叶子节点只是没有孩子和指向孩子的指针，这些节点也存在，也有元素。类似红黑树中，每一个NULL指针即当做叶子结点，只是没画出来而已）。 每个非终端结点中包含有n个关键字信息： (n，P0，K1，P1，K2，P2，……，Kn，Pn)。其中：a) Ki (i=1…n)为关键字，且关键字按顺序升序排序K(i-1)&lt; Ki。b) Pi为指向子树根的结点，且指针P(i-1)指向子树种所有结点的关键字均小于Ki，但都大于K(i-1)。c) 关键字的个数n必须满足： [ceil(m / 2)-1]&lt;= n &lt;= m-1。比如有j个孩子的非叶结点恰好有j-1个关键码。 B树的插入根据B树的性质，一个m阶的B树需要满足： 树中每个结点含有最多含有m个孩子，即m满足：ceil(m/2)&lt;=m&lt;=m。 除根结点和叶子结点外，其它每个结点至少有[ceil(m / 2)]个孩子（其中ceil(x)是一个取上限的函数）； 除根结点之外的结点的关键字的个数n必须满足： [ceil(m / 2)-1]&lt;= n &lt;= m-1（叶子结点也必须满足此条关于关键字数的性质）。 针对一棵高度为h的m阶B树，插入一个元素时，首先在B树中是否存在，如果不存在，一般在叶子结点中插入该新的元素，此时分3种情况： 如果叶子结点空间足够，即该结点的关键字数小于m-1，则直接插入在叶子结点的左边或右边； 如果空间满了以致没有足够的空间去添加新的元素，即该结点的关键字数已经有了m个，则需要将该结点进行“分裂”，将一半数量的关键字元素分裂到新的其相邻右结点中，中间关键字元素上移到父结点中，而且当结点中关键元素向右移动了，相关的指针也需要向右移。 此外，如果在上述中间关键字上移到父结点的过程中，导致根结点空间满了，那么根结点也要进行分裂操作，这样原来的根结点中的中间关键字元素向上移动到新的根结点中，因此导致树的高度增加一层。 插入以下字符字母到一棵空的5阶B 树中：C N G A H E K Q M F W L T Z D P R X Y S分析： 根据上面的性质总结，5阶的B树，非根节点关键字个数n满足2&lt;=n&lt;=4,每个节点最多含有5个孩子，除根节点叶子节点之外，其他节点至少3个孩子。 关键字个数最大4，先取前4个插入到相同的节点中。 ​ ​ ​ 插入H，因为步骤一后空间不够，就需要将中间关键字元素上移到父结点中，树增加一层 ​ ​ ​ 在步骤二的图中，可以继续插入E,K,Q三个节点，继续插就得分裂 ​ ​ ​ 插入M将进行分裂，M刚好是中间元素，直接上移到父节点中，HK、NQ分开为两个节点 ​ ​ ​ 如步骤四的图中可以继续插入F,W,L,T ​ ​ ​ 在步骤五之后，插入Z就得进行分裂，T上移到父节点 ​ ​ ​ 如步骤六的图中插入D,进行分裂，D上移到父节点中，然后插入后续的P,R,X,Y节点没有分裂 ​ ​ ​ 插入最后一个S，含有N,P,Q,R的节点需要分裂，Q上移，导致父节点D,G,M,T也满了，也需要进行分裂，继续将中间元素M上移，产生新的节点，树高度再加一层。 ​ ​ ​ B树的删除首先查找B树中要删除的元素，若元素存在，则进行删除。删除该元素后，需要判断该元素是否有左右孩子节点 如果有，则上移孩子节点中的相近元素(左孩子中最右边的节点或者右孩子中最左边的节点)到父节点中去，移动之后的情况。 如果没有，直接删除，移动之后的情况。 删除元素，然后进行元素移动之后，如果节点关键字数目不满足条件(小于ceil(m/2)-1),则需要看其相邻的兄弟节点是否丰满(关键字个数大于ceil(m/2)-1) 如果丰满，则向父节点借一个元素来满足 如果其相邻兄弟都刚脱贫，即借了之后其结点数目小于ceil(m/2)-1，则该结点与其相邻的某一兄弟结点进行“合并”成一个结点，以此来满足条件。 对刚刚插入的树进行删除操作，依次删除H,T,R,E 删除H,在叶子节点H,K,L中，删除后还剩两个关键字，能够满足不小于ceil(m/2)-1=2，进行简单的删除元素后面的元素向前移动即可。 ​ ​ ​ 删除T,QT节点不满足关键字要求，需要上移孩子节点中相近元素W ​ ​ ​ 删除R,删除后RS节点只剩一个关键字，根据上面的分析，兄弟节点丰满，就向父节点借一个W,同时X需要上移到父节点中去。 ​ ​ ​ 删除E,删除后EF节点只剩一个关键字，根据上面分析，兄弟节点刚脱贫，则需要跟相邻兄弟节点合并，D在两个需要合并的节点之间，所以需要下移到之前的AC节点中，将仅剩的F进行合并，形成ACDF节点 ​ ​ ​ ​ 但是我们发现中间有一个节点只包含一个关键字，并且该节点非根节点，这个就需要进行修改。接下来进行分析：如果相邻兄弟节点丰满，可以从父节点中进行借一个元素，但是我们右边的QX节点并不丰满，所以只能下移M节点，减少树的高度。最终图如下： ​ ​ ​ B+树B树的一种变形树，m阶的B+树和m阶的B树区别： 所有叶子节点包含全部关键字信息，及指向含有这些关键字记录的指针，且叶子节点中关键字进行有序链接 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层； B+树比B树更适合操作系统的文件索引和数据库索引的原因： B+树的磁盘读写代价更低，B+树的内部节点没有指向关键字具体信息的指针，因此内部节点相对B树更小。如果把所有同一内部节点的关键字放在同一块磁盘中，盘块所能容纳的关键字数量也就越多，一次性读入内存中的需要查找的关键字也就越多，相对IO读写次数降低 举个例子，假设磁盘中的一个盘块容纳16bytes，而一个关键字2bytes，一个关键字具体信息指针2bytes。一棵9阶B-tree(一个结点最多8个关键字)的内部结点需要2个盘块。而B+树内部结点只需要1个盘快。当需要把内部结点读入内存中的时候，B 树就比B+ 树多一次盘块查找时间(在磁盘中就是盘片旋转的时间)。 B+树的查询效率更加稳定由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。 总而言之，B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。正是为了解决这个问题，B+树应运而生。B+树只要遍历叶子节点就可以实现整棵树的遍历，支持基于范围的查询，而B树不支持range-query这样的操作（或者说效率太低）。 B*树B*树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针； B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针。 B*树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针。 总结 B-树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中； B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点 中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中； B*树：在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3； 借鉴于July大神的分析]]></content>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[B树]]></title>
    <url>%2F2018%2F07%2F12%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2Fb-tree-1%2F</url>
    <content type="text"><![CDATA[下面来具体介绍一下B-树（Balance Tree），一个m阶的B树具有如下几个特征： 1.根结点至少有两个子女。 2.每个中间节点都包含k-1个元素和k个孩子，其中 m/2 &lt;= k &lt;= m 3.每一个叶子节点都包含k-1个元素，其中 m/2 &lt;= k &lt;= m 4.所有的叶子节点都位于同一层。 5.每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。 举个最简单的例子， 3阶B树，又称2-3树 其根节点有三种情况：叶节点，2-节点，3-节点（叶节点，2 ~ M-节点） 其非根节点有两种情况：2-节点，3-节点（⌈M/2⌉ ~ M-节点） 4阶B树 其根节点有四种情况：叶节点，2-节点，3-节点，4-节点（叶节点，2 ~ M-节点） 其非根节点有三种情况：2-节点，3-节点，4-节点（⌈M/2⌉ ~ M-节点） 5阶B树 其根节点有五种情况：叶节点，2-节点，3-节点，4-节点，5-节点（叶节点，2 ~ M-节点） 其非根节点有三种情况：3-节点，4-节点，5-节点（⌈M/2⌉ ~ M-节点） 6阶B树 其根节点有6种情况：叶节点，2-节点，3-节点，4-节点，5-节点，6-节点（叶节点，2 ~ M-节点） 其非根节点有四种情况：3-节点，4-节点，5-节点，6-节点（⌈M/2⌉ ~ M-节点） 综上所述，可知，M阶B树的节点类型为 根节点要么没有儿子，要么有2～M个儿子 非根节点类型有⌈M/2⌉ -节点 …. M节点。]]></content>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树讲解]]></title>
    <url>%2F2018%2F07%2F12%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2Fbinary-tree-2%2F</url>
    <content type="text"><![CDATA[转载自：多动态图详细讲解二叉搜索树 作者：luffic 在计算机科学中，二叉搜索树（Binary Search Tree）（有时称为有序或排序的二叉树）是一种能存储特定数据类型的容器。二叉搜索树允许快速查找、添加或者删除某一个节点，并且它是动态的集合。二叉搜索树按照关键字顺序地保存节点，因此查找和其他操作可以使用二叉搜索原理：当在树（或者寻找插入新节点的地方）中查找节点时，它从根节点遍历到叶节点，与每个节点的关键字进行比较，然后基于比较结果，决定继续在左子树或者右子树中进行搜索。平均而言，每次比较将跳过树的大约一半的元素，这使得每次查找，插入或删除一个节点所花费的时间与树的节点个数的对数成（树的高度）正比，比线性表的性能要好很多。 定义二叉搜索树是以一棵二叉树来组织，每个节点就是一个对象，包括key、卫星数据，除此之外还包括一些为了维持树结构所需要的信息：left、right、parent，分别指向左孩子、右孩子、父节点。其中如果孩子节点或者父节点不存在时，用NIL表示。根节点是树中唯一一个父节点为NIL的节点。 二叉搜索树具有以下性质： 如果节点的左子树不空，则左子树上所有结点的值均小于等于它的根结点的值； 如果节点的右子树不空，则右子树上所有结点的值均大于等于它的根结点的值； 任意节点的左、右子树也分别为二叉查找树； 二叉树 比如在上图中根节点的关键字为6，左子树有关键字2、4和5，均不大于6；右子树有关键字7和8，均不小于6。这个性质对树中的每个节点都成立，也就是说，二叉搜索树的定义是递归的。 在讨论二叉搜索树的操作之前，先看看二叉搜索树的遍历。二叉搜索树可以使用先序遍历（preorder tree walk）、中序遍历（inorder tree walk）和后序遍历（postorder tree walk）。这样命名的依据是根据输出关键字相对于左右子树的位置。以中序遍历为例，伪代码如下： 12345CopyINORDER-TREE-WALK(x) if x != nil // 如果节点不为空 INORDER-TREE-WALK(x.left) // 首先递归地遍历左孩子，直到左孩子为空 print x.key // 输出当前节点（显然第一次运行到这里时，它是最小值，因为它是整棵树的最左节点） INORDER-TREE-WALK(x.right) // 递归地遍历右孩子 对于上图中的二叉搜索树，动态过程如下，这样输出结果为：2，4，5，6，7，8，即按照从小到大的顺序排列。因为输出时一直遍历左孩子，知道遇到第一个左孩子为空的节点，将它输出，然后出栈返回继续输出。 查询二叉搜索树还应该可以完成MINIMUM，MAXIMUM，SUCCESSOR和PREDECESSOR操作，即求最小值，最大值，后继和前驱，并且这些操作都可以在o(lgn)的时间内完成。 查找指定关键字TREE-SEARCH操作在二叉树中查找一个具有指定的关键字的节点，输入树的根节点指针和关键字k，如果存在，返回节点指针，否则，返回nil。 1234567CopyTREE-SEARCH(x, k) if x == nil or k == x.key //如不存在或者找到，直接返回 return x if k &lt; x.key //如果小于当前节点，根据性质，在左子树中搜索 return TREE-SEARCH(x.left, k) else //如果大于等于当前节点，根据性质，在右子树中搜索 return TREE-SEARCH(x.right, k) 比如查找关键字为5的节点，首先从根节点6开始，与5进行比较，因为5小于6，因此在节点6的左子树继续搜索。到达节点4时因为5大于4，所以在4节点的右子树搜索，这样就顺利找到了节点5，此时函数将返回指向节点5的指针。如果找不到目标节点，TREE-SEARCH函数将返回nil。整个搜索过程如下： 搜索过程 最小/最大关键字通过从树根开始，沿着left孩子向下搜索，直到遇到nil，那么根据二叉搜索树的性质，如果节点x没有左子树，而x的右子树的关键字肯定都大于x.key，因此此时当前节点一定是整个树中的最小值。 1234CopyTREE-MINIMUM(x) while x.left != nil // 沿着左子树一直深入搜索下去，直到遇到左子树为空的节点，此时当前节点为最小值 x = x.left return x 同理，最大关键字的伪代码如下： 1234CopyTREE-MAXIMUM(x) while x.right != nil // 沿着右子树一直深入搜索下去，直到遇到右子树为空的节点，此时当前节点为最大值 x = x.right return x 求取最大、最小关键字的时间复杂度仅为o(lgn)，即与树的高度成正比，因为查找过程自上而下形成一条线，线的最大长度为数的高度，如求取最小值的过程： 求取最小值 前驱/后继给定二叉搜索树的一个节点，有事需要按照中序遍历的次序查找它的后继，如果所有的关键字互不相同，则一个节点x的后继一定是大于x.key的最小关键字。 12345678CopyTREE-SUCCESSOR(x) if x.right != nil //case 1:如果右子树不为空，则后继一定是右子树的最小值，即大于x的最小值（右子树的值都大于x节点） return TREE-MINIMUM(x.right) y = x.p // case 2:右子树为空时 while y != nil and x == y.right x = y // 变量x代表节点原始x的祖先，如果找到x，它是父节点的左孩子，则循环终止 y = y.p // y 代表节点x的父节点，如果x是y的左孩子，循环终止，并且返回y return y 1.对于第一种情况比较简单，如果x右子树不为空，那它的后继就是右子树的最左节点，对应伪代码case 1，例如下图寻找68的后继，即寻找68的右子树的最小节点72，同时它也是右子树的最左节点。 寻找68的后继 2.第二种情况是x的右子树为空，注意x的后继始终是大于x的最小值（或者不存在），所以当x的右子树不存在时大于x的最小值在哪儿呢？我们只需要简单的从x开始沿树而上，找到第一个这样一个节点：它的父节点为空（即根节点）或者它的左孩子是x节点的祖先节点（不一定是直接祖先）。例如下图中为了寻找17的后继，沿着树上升，首先以此遇到了节点13，11，它们均不符合条件，因为它们不是父节点的左孩子。当遇到节点10时，此时x指向节点10，y指向节点19，并且节点10是节点19的左孩子，符合条件，所以返回节点y，它是节点x的后继。 寻找17的后继 再举一个例子，下图为了找15的后继，仍然沿着树上升，直到遇到节点10（此时伪代码中的变量x指向节点10）：它是15的祖先，而且是左孩子。所以此时返回节点10的父节点19，即节点15的后继。 寻找15的后继 一个二叉搜索树中除了最大节点外，都有后继。对于前驱节点，和后继节点原理一样，这里不再赘述。 插入插入操作会引起二叉搜索树集合的动态变化，因此需要一定的修改来维持二叉搜索树。由于二叉搜索树的性质，即左孩子小于等于父节点，右孩子大于等于父节点，因此插入操作相对简单。 将一个节点插入到二叉搜索树中，需要调用TREE-INSERT，该过程以节点z作为输入，其中z.left = nil, z.right = nil, z.key = 将要插入数据的关键字： 12345678910111213141516CopyTREE-INSERT(T, z) y = nil x = T.root while x != nil //循环结束后，x一定为空，此时x即为节点z要插入的地方 y = x //在这里给y赋值，保证循环结束后y始终是x的父节点 if z.key &lt; x.key x = x.left else x = x.right z.p = y // y始终是x的父节点，为了插入z，需要让z的父节点指向x的父节点，即指向y if y == nil // 如果y为空，说明插入时是一棵空的树，需要将树根指向z T.root = z elseif z.key &lt; y.key // 判断节点z是y的左孩子还是右孩子 y.left = z else y.right = z 上述伪代码从树根开始，指针x记录了一条向下的简单路径，通过while循环比较z.key和x.key的大小，使指针x和指针y向下移动，循环结束时则找到一个空的x并作为一个槽，将节点z放到这里（插入），同时保持节点y为节点x的父节点，这样可以很方便的决定插入之后将z作为它的左孩子还是右孩子。举一个例子： 上图为了在树中插入节点46，首先x指向根节点，节点46与根节点68（x节点）比较，小于68，因此指针x指向根节点（x节点）的左孩子62，然后一直下移。注意当x指向45的时候，节点46大于45，因此将x指向节点45的右孩子，此时x为nil了，循环结束，也就找到了节点46的位置：节点45的右孩子。然后进行一些操作将节点46插入到树中即可。 删除从二叉搜索树中删除一个节点z稍微有点棘手，但总的来说可以分为三种情况： 如果z没有孩子节点，那么简单的将它删除，并修改它的父节点，用nil作为孩子节点代替z即可。 如果z只有一个孩子，那么将这个孩子提升到z的位置，并修改它的父节点，用z的孩子代替z即可。 如果z有两个孩子，那么用z的后继y（此时z的后继y一定在z的右子树中，因为z的右孩子不为空）来占据z的位置，此时z的原来的右子树部分称为y的新的右子树，并且z的左子树称为y的新的左子树。这种情况稍微麻烦，因为还与y是否为z的右孩子相关。 第一种情况：节点z没有孩子这种情况比较简单，我们直接删除节点z即可，并不会影响到二叉搜索树的性质： 用动图来表示就是： 第二种情况：节点z只有一个孩子这种情况也比较简单，直接用节点z的孩子代替节点z即可。其实第一种情况和第二种情况可以归为一个：节点z的孩子个数小于2个，直接用节点z的孩子代替节点z即可，只是节点z没有孩子时是用的nil代替节点z，这里为了更加清楚地说明分了三种情况。 例如如下图，当节点42只有左孩子时，直接将42的父节点6的右孩子指向节点29，将节点29的父节点设置为节点6即可： 或者只有右孩子时也是如此，直接将94的左孩子指向78，78的父节点指向94即可： 第三种情况：节点z有两个孩子这种情况稍微复杂一点，因为此时我们需要找到节点z的后继y，而后继节点y又分为y是节点z的直接右孩子或者不是。 z的后继y是 z的右孩子此时可以直接用后继y代替z，而且y的左孩子此时一定为空（因为后继的左孩子一定为空），再用z的左孩子代替y的原来为空的左孩子即可。用动图表示删除节点67就是： z的后继y不是 z的右孩子在这种情况下我们先用y的右孩子x代替y，然后再用y代替z: 用动图表示删除节点50就是用74代替73，即将73的父节点82的右孩子指向74,74的父节点设置为82，然后再用73代替50，即将50左孩子31设置为73的左孩子，50的右孩子82设置为73的右孩子： 为了实现删除过程的伪代码，我们需要定义一个子过程TRANSPLANT，它是用为了用以v为根的子树替换以u为根的子树，让u的双亲节点变为v的双亲节点，即让v称为u的双亲节点的孩子： 123456789CopyTRANSPLANT(T, u, v) if u.p == nil // 当u位树的根节点时，直接将树的根节点指向v T.root = v elseif u == u.p.left // 如果u是左孩子，则u的父节点的左孩子指向v u.p.left = v else // 如果u是右孩子，则u的父节点的右孩子指向v u.p.right = v if v != nil v.p = u.p // 将v的父节点设为u的父节点 然后实现具体的删除过程： 12345678910111213CopyTREE-DELETE(T, z) if z.left == nil // 如果左孩子为空，则直接用右孩子代替z即可，而不管右孩子是否为空（右孩子为空时对应情况一否则对应情况二） TRANSPLANT(T, z, z.right) elseif z.right == nil // 右孩子为空，直接用做孩子代替z TRANSPLANT(T, z, z.left) else y = TREE-MINIMUM(z.right) // 左右孩子均不为空，找到z的后继y，即z的右子树的最小值，对应第三种情况 if y.p != z // 如果z的后继y不是z的右孩子，对应第三种情况的2 TRANSPLANT(T, y, y.right) // 用y的右孩子代替y y.right = z.right // 将y的右孩子指向z的右孩子 y.right.p = y // 将y的右孩子(原来的z的右孩子)的父节点设为y TRANSPLANT(T, z, y) // 用y代替z y.left = z.left y.left.p = p 因此总的来说，删除操作可以分为两大类： z的孩子总数小于2时，直接用z的孩子代替z即完成了对z的删除。 z有两个孩子时：2.1. z的后继y是z的右孩子：直接用y代替z即可（别忘了将z的左孩子的父节点设置为y）。2.2. z的后继y不是z的右孩子：先用y的右孩子x代替y，再用y代替z。 总结因为二叉搜索树的性质，即可以在每个比较之后将数据规模变为原来的一半，因此平均情况下每一个操作都可以在o(lgn)的时间内完成，即花费时间与树的高度成正比。但在最坏的情况下，二叉搜索树就退化为一个链表，此时的时间复杂度退化到了o(n)。但很多改进版的二叉查找树可以使树高为o(lgn)，如SBT，AVL树，红黑树等。 参考文献 算法导论 维基百科 visualgo ⬆️]]></content>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AVL树精简版]]></title>
    <url>%2F2018%2F07%2F11%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2Favl-tree-simplify%2F</url>
    <content type="text"><![CDATA[四种情况： 左旋转 右旋转 左右旋转 右左旋转]]></content>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AVL树]]></title>
    <url>%2F2018%2F07%2F11%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2Favl-tree%2F</url>
    <content type="text"><![CDATA[转载自：AVL树(一)之 图文解析 和 C语言的实现 作者：skywang12345 概要本章介绍AVL树。和前面介绍”二叉查找树“的流程一样，本章先对AVL树的理论知识进行简单介绍，然后给出C语言的实现。本篇实现的二叉查找树是C语言版的，后面章节再分别给出C++和Java版本的实现。建议：若您对”二叉查找树”不熟悉，建议先学完”二叉查找树“再来学习AVL树。 目录 AVL树的介绍 AVL树的C实现3. AVL树的C实现(完整源码) AVL树的C测试程序 转载请注明出处：http://www.cnblogs.com/skywang12345/p/3576969.html 更多内容: 数据结构与算法系列 目录 (01) AVL树(一)之 图文解析 和 C语言的实现(02) AVL树(二)之 C++的实现(03) AVL树(三)之 Java的实现 AVL树的介绍AVL树是根据它的发明者G.M. Adelson-Velsky和E.M. Landis命名的。它是最先发明的自平衡二叉查找树，也被称为高度平衡树。相比于”二叉查找树”，它的特点是：AVL树中任何节点的两个子树的高度最大差别为1。 (关于树的高度等基本概念，请参考”二叉查找树(一)之 图文解析 和 C语言的实现 “) 上面的两张图片，左边的是AVL树，它的任何节点的两个子树的高度差别都&lt;=1；而右边的不是AVL树，因为7的两颗子树的高度相差为2(以2为根节点的树的高度是3，而以8为根节点的树的高度是1)。 AVL树的查找、插入和删除在平均和最坏情况下都是O(logn)。如果在AVL树中插入或删除节点后，使得高度之差大于1。此时，AVL树的平衡状态就被破坏，它就不再是一棵二叉树；为了让它重新维持在一个平衡状态，就需要对其进行旋转处理。学AVL树，重点的地方也就是它的旋转算法；在后文的介绍中，再来对它进行详细介绍。 AVL树的C实现1. 节点 1.1 定义 12345678typedef int Type;typedef struct AVLTreeNode&#123; Type key; // 关键字(键值) int height; struct AVLTreeNode *left; // 左孩子 struct AVLTreeNode *right; // 右孩子&#125;Node, *AVLTree; AVL树的节点包括的几个组成对象:(01) key – 是关键字，是用来对AVL树的节点进行排序的。(02) left – 是左孩子。(03) right – 是右孩子。(04) height – 是高度。 1.2 节点的创建 123456789101112131415161718192021/* * 创建AVL树结点。 * * 参数说明： * key 是键值。 * left 是左孩子。 * right 是右孩子。 */static Node* avltree_create_node(Type key, Node *left, Node* right)&#123; Node* p; if ((p = (Node *)malloc(sizeof(Node))) == NULL) return NULL; p-&gt;key = key; p-&gt;height = 0; p-&gt;left = left; p-&gt;right = right; return p;&#125; 1.3 树的高度 123456789#define HEIGHT(p) ( (p==NULL) ? 0 : (((Node *)(p))-&gt;height) )/* * 获取AVL树的高度 */int avltree_height(AVLTree tree)&#123; return HEIGHT(tree);&#125; 关于高度，有的文章中将”空二叉树的高度定义为-1”，而本文采用维基百科)上的定义：树的高度为最大层次。即空的二叉树的高度是0，非空树的高度等于它的最大层次(根的层次为1，根的子节点为第2层，依次类推)。 1.4 比较大小 1#define MAX(a, b) ( (a) &gt; (b) ? (a) : (b) ) 2. 旋转前面说过，如果在AVL树中进行插入或删除节点后，可能导致AVL树失去平衡。这种失去平衡的可以概括为4种姿态：LL(左左)，LR(左右)，RR(右右)和RL(右左)。下面给出它们的示意图： 上图中的4棵树都是”失去平衡的AVL树”，从左往右的情况依次是：LL、LR、RL、RR。除了上面的情况之外，还有其它的失去平衡的AVL树，如下图： 上面的两张图都是为了便于理解，而列举的关于”失去平衡的AVL树”的例子。总的来说，AVL树失去平衡时的情况一定是LL、LR、RL、RR这4种之一，它们都由各自的定义： (1) LL：LeftLeft，也称为”左左”。插入或删除一个节点后，根节点的左子树的左子树还有非空子节点，导致”根的左子树的高度”比”根的右子树的高度”大2，导致AVL树失去了平衡。​ 例如，在上面LL情况中，由于”根节点(8)的左子树(4)的左子树(2)还有非空子节点”，而”根节点(8)的右子树(12)没有子节点”；导致”根节点(8)的左子树(4)高度”比”根节点(8)的右子树(12)”高2。 (2) LR：LeftRight，也称为”左右”。插入或删除一个节点后，根节点的左子树的右子树还有非空子节点，导致”根的左子树的高度”比”根的右子树的高度”大2，导致AVL树失去了平衡。​ 例如，在上面LR情况中，由于”根节点(8)的左子树(4)的左子树(6)还有非空子节点”，而”根节点(8)的右子树(12)没有子节点”；导致”根节点(8)的左子树(4)高度”比”根节点(8)的右子树(12)”高2。 (3) RL：RightLeft，称为”右左”。插入或删除一个节点后，根节点的右子树的左子树还有非空子节点，导致”根的右子树的高度”比”根的左子树的高度”大2，导致AVL树失去了平衡。​ 例如，在上面RL情况中，由于”根节点(8)的右子树(12)的左子树(10)还有非空子节点”，而”根节点(8)的左子树(4)没有子节点”；导致”根节点(8)的右子树(12)高度”比”根节点(8)的左子树(4)”高2。 (4) RR：RightRight，称为”右右”。插入或删除一个节点后，根节点的右子树的右子树还有非空子节点，导致”根的右子树的高度”比”根的左子树的高度”大2，导致AVL树失去了平衡。​ 例如，在上面RR情况中，由于”根节点(8)的右子树(12)的右子树(14)还有非空子节点”，而”根节点(8)的左子树(4)没有子节点”；导致”根节点(8)的右子树(12)高度”比”根节点(8)的左子树(4)”高2。 前面说过，如果在AVL树中进行插入或删除节点后，可能导致AVL树失去平衡。AVL失去平衡之后，可以通过旋转使其恢复平衡，下面分别介绍”LL(左左)，LR(左右)，RR(右右)和RL(右左)”这4种情况对应的旋转方法。 2.1 LL的旋转 LL失去平衡的情况，可以通过一次旋转让AVL树恢复平衡。如下图： 图中左边是旋转之前的树，右边是旋转之后的树。从中可以发现，旋转之后的树又变成了AVL树，而且该旋转只需要一次即可完成。对于LL旋转，你可以这样理解为：LL旋转是围绕”失去平衡的AVL根节点”进行的，也就是节点k2；而且由于是LL情况，即左左情况，就用手抓着”左孩子，即k1”使劲摇。将k1变成根节点，k2变成k1的右子树，”k1的右子树”变成”k2的左子树”。 LL的旋转代码 123456789101112131415161718/* * LL：左左对应的情况(左单旋转)。 * * 返回值：旋转后的根节点 */static Node* left_left_rotation(AVLTree k2)&#123; AVLTree k1; k1 = k2-&gt;left; k2-&gt;left = k1-&gt;right; k1-&gt;right = k2; k2-&gt;height = MAX( HEIGHT(k2-&gt;left), HEIGHT(k2-&gt;right)) + 1; k1-&gt;height = MAX( HEIGHT(k1-&gt;left), k2-&gt;height) + 1; return k1;&#125; 2.2 RR的旋转 理解了LL之后，RR就相当容易理解了。RR是与LL对称的情况！RR恢复平衡的旋转方法如下： 图中左边是旋转之前的树，右边是旋转之后的树。RR旋转也只需要一次即可完成。 RR的旋转代码 123456789101112131415161718/* * RR：右右对应的情况(右单旋转)。 * * 返回值：旋转后的根节点 */static Node* right_right_rotation(AVLTree k1)&#123; AVLTree k2; k2 = k1-&gt;right; k1-&gt;right = k2-&gt;left; k2-&gt;left = k1; k1-&gt;height = MAX( HEIGHT(k1-&gt;left), HEIGHT(k1-&gt;right)) + 1; k2-&gt;height = MAX( HEIGHT(k2-&gt;right), k1-&gt;height) + 1; return k2;&#125; 2.3 LR的旋转 LR失去平衡的情况，需要经过两次旋转才能让AVL树恢复平衡。如下图： 第一次旋转是围绕”k1”进行的”RR旋转”，第二次是围绕”k3”进行的”LL旋转”。 LR的旋转代码 1234567891011/* * LR：左右对应的情况(左双旋转)。 * * 返回值：旋转后的根节点 */static Node* left_right_rotation(AVLTree k3)&#123; k3-&gt;left = right_right_rotation(k3-&gt;left); return left_left_rotation(k3);&#125; 2.4 RL的旋转RL是与LR的对称情况！RL恢复平衡的旋转方法如下： 第一次旋转是围绕”k3”进行的”LL旋转”，第二次是围绕”k1”进行的”RR旋转”。 RL的旋转代码 1234567891011/* * RL：右左对应的情况(右双旋转)。 * * 返回值：旋转后的根节点 */static Node* right_left_rotation(AVLTree k1)&#123; k1-&gt;right = left_left_rotation(k1-&gt;right); return right_right_rotation(k1);&#125; 3. 插入插入节点的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/* * 将结点插入到AVL树中，并返回根节点 * * 参数说明： * tree AVL树的根结点 * key 插入的结点的键值 * 返回值： * 根节点 */Node* avltree_insert(AVLTree tree, Type key)&#123; if (tree == NULL) &#123; // 新建节点 tree = avltree_create_node(key, NULL, NULL); if (tree==NULL) &#123; printf("ERROR: create avltree node failed!\n"); return NULL; &#125; &#125; else if (key &lt; tree-&gt;key) // 应该将key插入到"tree的左子树"的情况 &#123; tree-&gt;left = avltree_insert(tree-&gt;left, key); // 插入节点后，若AVL树失去平衡，则进行相应的调节。 if (HEIGHT(tree-&gt;left) - HEIGHT(tree-&gt;right) == 2) &#123; if (key &lt; tree-&gt;left-&gt;key) tree = left_left_rotation(tree); else tree = left_right_rotation(tree); &#125; &#125; else if (key &gt; tree-&gt;key) // 应该将key插入到"tree的右子树"的情况 &#123; tree-&gt;right = avltree_insert(tree-&gt;right, key); // 插入节点后，若AVL树失去平衡，则进行相应的调节。 if (HEIGHT(tree-&gt;right) - HEIGHT(tree-&gt;left) == 2) &#123; if (key &gt; tree-&gt;right-&gt;key) tree = right_right_rotation(tree); else tree = right_left_rotation(tree); &#125; &#125; else //key == tree-&gt;key) &#123; printf("添加失败：不允许添加相同的节点！\n"); &#125; tree-&gt;height = MAX( HEIGHT(tree-&gt;left), HEIGHT(tree-&gt;right)) + 1; return tree;&#125; 4. 删除删除节点的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899/* * 删除结点(z)，返回根节点 * * 参数说明： * ptree AVL树的根结点 * z 待删除的结点 * 返回值： * 根节点 */static Node* delete_node(AVLTree tree, Node *z)&#123; // 根为空 或者 没有要删除的节点，直接返回NULL。 if (tree==NULL || z==NULL) return NULL; if (z-&gt;key &lt; tree-&gt;key) // 待删除的节点在"tree的左子树"中 &#123; tree-&gt;left = delete_node(tree-&gt;left, z); // 删除节点后，若AVL树失去平衡，则进行相应的调节。 if (HEIGHT(tree-&gt;right) - HEIGHT(tree-&gt;left) == 2) &#123; Node *r = tree-&gt;right; if (HEIGHT(r-&gt;left) &gt; HEIGHT(r-&gt;right)) tree = right_left_rotation(tree); else tree = right_right_rotation(tree); &#125; &#125; else if (z-&gt;key &gt; tree-&gt;key)// 待删除的节点在"tree的右子树"中 &#123; tree-&gt;right = delete_node(tree-&gt;right, z); // 删除节点后，若AVL树失去平衡，则进行相应的调节。 if (HEIGHT(tree-&gt;left) - HEIGHT(tree-&gt;right) == 2) &#123; Node *l = tree-&gt;left; if (HEIGHT(l-&gt;right) &gt; HEIGHT(l-&gt;left)) tree = left_right_rotation(tree); else tree = left_left_rotation(tree); &#125; &#125; else // tree是对应要删除的节点。 &#123; // tree的左右孩子都非空 if ((tree-&gt;left) &amp;&amp; (tree-&gt;right)) &#123; if (HEIGHT(tree-&gt;left) &gt; HEIGHT(tree-&gt;right)) &#123; // 如果tree的左子树比右子树高； // 则(01)找出tree的左子树中的最大节点 // (02)将该最大节点的值赋值给tree。 // (03)删除该最大节点。 // 这类似于用"tree的左子树中最大节点"做"tree"的替身； // 采用这种方式的好处是：删除"tree的左子树中最大节点"之后，AVL树仍然是平衡的。 Node *max = avltree_maximum(tree-&gt;left); tree-&gt;key = max-&gt;key; tree-&gt;left = delete_node(tree-&gt;left, max); &#125; else &#123; // 如果tree的左子树不比右子树高(即它们相等，或右子树比左子树高1) // 则(01)找出tree的右子树中的最小节点 // (02)将该最小节点的值赋值给tree。 // (03)删除该最小节点。 // 这类似于用"tree的右子树中最小节点"做"tree"的替身； // 采用这种方式的好处是：删除"tree的右子树中最小节点"之后，AVL树仍然是平衡的。 Node *min = avltree_maximum(tree-&gt;right); tree-&gt;key = min-&gt;key; tree-&gt;right = delete_node(tree-&gt;right, min); &#125; &#125; else &#123; Node *tmp = tree; tree = tree-&gt;left ? tree-&gt;left : tree-&gt;right; free(tmp); &#125; &#125; return tree;&#125;/* * 删除结点(key是节点值)，返回根节点 * * 参数说明： * tree AVL树的根结点 * key 待删除的结点的键值 * 返回值： * 根节点 */Node* avltree_delete(AVLTree tree, Type key)&#123; Node *z; if ((z = avltree_search(tree, key)) != NULL) tree = delete_node(tree, z); return tree;&#125; 注意：关于AVL树的”前序遍历”、”中序遍历”、”后序遍历”、”最大值”、”最小值”、”查找”、”打印”、”销毁”等接口与”二叉查找树“基本一样，这些操作在”二叉查找树”中已经介绍过了，这里就不再单独介绍了。当然，后文给出的AVL树的完整源码中，有给出这些API的实现代码。这些接口很简单，Please RTFSC(Read The Fucking Source Code)！ AVL树的C实现(完整源码)AVL树的头文件(avltree.h) 123456789101112131415161718192021222324252627282930313233343536373839404142434445 1 #ifndef _AVL_TREE_H_ 2 #define _AVL_TREE_H_ 3 4 typedef int Type; 5 6 typedef struct AVLTreeNode&#123; 7 Type key; // 关键字(键值) 8 int height; 9 struct AVLTreeNode *left; // 左孩子10 struct AVLTreeNode *right; // 右孩子11 &#125;Node, *AVLTree;12 13 // 获取AVL树的高度14 int avltree_height(AVLTree tree);15 16 // 前序遍历"AVL树"17 void preorder_avltree(AVLTree tree);18 // 中序遍历"AVL树"19 void inorder_avltree(AVLTree tree);20 // 后序遍历"AVL树"21 void postorder_avltree(AVLTree tree);22 23 void print_avltree(AVLTree tree, Type key, int direction);24 25 // (递归实现)查找"AVL树x"中键值为key的节点26 Node* avltree_search(AVLTree x, Type key);27 // (非递归实现)查找"AVL树x"中键值为key的节点28 Node* iterative_avltree_search(AVLTree x, Type key);29 30 // 查找最小结点：返回tree为根结点的AVL树的最小结点。31 Node* avltree_minimum(AVLTree tree);32 // 查找最大结点：返回tree为根结点的AVL树的最大结点。33 Node* avltree_maximum(AVLTree tree);34 35 // 将结点插入到AVL树中，返回根节点36 Node* avltree_insert(AVLTree tree, Type key);37 38 // 删除结点(key是节点值)，返回根节点39 Node* avltree_delete(AVLTree tree, Type key);40 41 // 销毁AVL树42 void destroy_avltree(AVLTree tree);43 44 45 #endif AVL树的实现文件(avltree.c) View Code AVL树的测试程序(avltree_test.c) View Code AVL树的C测试程序AVL树的测试程序运行结果如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344== 依次添加: 3 2 1 4 5 6 7 16 15 14 13 12 11 10 8 9 == 前序遍历: 7 4 2 1 3 6 5 13 11 9 8 10 12 15 14 16 == 中序遍历: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 == 后序遍历: 1 3 2 5 6 4 8 10 9 12 11 14 16 15 13 7 == 高度: 5== 最小值: 1== 最大值: 16== 树的详细信息: 7 is root 4 is 7's left child 2 is 4's left child 1 is 2's left child 3 is 2's right child 6 is 4's right child 5 is 6's left child13 is 7's right child11 is 13's left child 9 is 11's left child 8 is 9's left child10 is 9's right child12 is 11's right child15 is 13's right child14 is 15's left child16 is 15's right child== 删除根节点: 8== 高度: 5== 中序遍历: 1 2 3 4 5 6 7 9 10 11 12 13 14 15 16 == 树的详细信息: 7 is root 4 is 7's left child 2 is 4's left child 1 is 2's left child 3 is 2's right child 6 is 4's right child 5 is 6's left child13 is 7's right child11 is 13's left child 9 is 11's left child10 is 9's right child12 is 11's right child15 is 13's right child14 is 15's left child16 is 15's right child 下面，我们对测试程序的流程进行分析！ 1. 新建AVL树 新建AVL树的根节点root。 2. 依次添加”3,2,1,4,5,6,7,16,15,14,13,12,11,10,8,9” 到AVL树中，过程如下。2.01 添加3,2添加3,2都不会破坏AVL树的平衡性。 2.02 添加1添加1之后，AVL树失去平衡(LL)，此时需要对AVL树进行旋转(LL旋转)。旋转过程如下： 2.03 添加4添加4不会破坏AVL树的平衡性。 2.04 添加5添加5之后，AVL树失去平衡(RR)，此时需要对AVL树进行旋转(RR旋转)。旋转过程如下： 2.05 添加6添加6之后，AVL树失去平衡(RR)，此时需要对AVL树进行旋转(RR旋转)。旋转过程如下： 2.06 添加7添加7之后，AVL树失去平衡(RR)，此时需要对AVL树进行旋转(RR旋转)。旋转过程如下： 2.07 添加16添加16不会破坏AVL树的平衡性。 2.08 添加15添加15之后，AVL树失去平衡(RR)，此时需要对AVL树进行旋转(RR旋转)。旋转过程如下： 2.09 添加14添加14之后，AVL树失去平衡(RL)，此时需要对AVL树进行旋转(RL旋转)。旋转过程如下： 2.10 添加13添加13之后，AVL树失去平衡(RR)，此时需要对AVL树进行旋转(RR旋转)。旋转过程如下： 2.11 添加12添加12之后，AVL树失去平衡(LL)，此时需要对AVL树进行旋转(LL旋转)。旋转过程如下： 2.12 添加11添加11之后，AVL树失去平衡(LL)，此时需要对AVL树进行旋转(LL旋转)。旋转过程如下： 2.13 添加10添加10之后，AVL树失去平衡(LL)，此时需要对AVL树进行旋转(LL旋转)。旋转过程如下： 2.14 添加8添加8不会破坏AVL树的平衡性。 2.15 添加9但是添加9之后，AVL树失去平衡(LR)，此时需要对AVL树进行旋转(LR旋转)。旋转过程如下： 3. 打印树的信息输出下面树的信息： 前序遍历:7 4 2 1 3 6 5 13 11 9 8 10 12 15 14 16中序遍历:1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16后序遍历:1 3 2 5 6 4 8 10 9 12 11 14 16 15 13 7高度: 5最小值: 1最大值: 16 4. 删除节点8 删除操作并不会造成AVL树的不平衡。 删除节点8之后，在打印该AVL树的信息。高度: 5中序遍历: 1 2 3 4 5 6 7 9 10 11 12 13 14 15 16]]></content>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[赫夫曼编码]]></title>
    <url>%2F2018%2F07%2F09%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2Fhuffman-code%2F</url>
    <content type="text"><![CDATA[转载自：https://blog.csdn.net/wtfmonking/article/details/17150499 作者：WTF 1、基本概念a、路径和路径长度 若在一棵树中存在着一个结点序列 k1，k2，……，kj， 使得 ki是ki+1 的双亲（1&lt;=i&lt;j），则称此结点序列是从 k1 到 kj 的路径。 从 k1 到 kj 所经过的分支数称为这两点之间的路径长度，它等于路径上的结点数减1. b、结点的权和带权路径长度 在许多应用中，常常将树中的结点赋予一个有着某种意义的实数，我们称此实数为该结点的权，(如下面一个树中的蓝色数字表示结点的权) 结点的带权路径长度规定为从树根结点到该结点之间的路径长度与该结点上权的乘积。 c、树的带权路径长度 树的带权路径长度定义为树中所有叶子结点的带权路径长度之和，公式为： 其中，n表示叶子结点的数目，wi 和 li 分别表示叶子结点 ki 的权值和树根结点到 ki 之间的路径长度。 如下图中树的带权路径长度 WPL = 9 x 2 + 12 x 2 + 15 x 2 + 6 x 3 + 3 x 4 + 5 x 4 = 122 d、哈夫曼树 哈夫曼树又称最优二叉树。它是 n 个带权叶子结点构成的所有二叉树中，带权路径长度 WPL 最小的二叉树。 如下图为一哈夫曼树示意图。 2、构造哈夫曼树假设有n个权值，则构造出的哈夫曼树有n个叶子结点。 n个权值分别设为 w1、w2、…、wn，则哈夫曼树的构造规则为： (1) 将w1、w2、…，wn看成是有n 棵树的森林(每棵树仅有一个结点)； (2) 在森林中选出两个根结点的权值最小的树合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和； (3)从森林中删除选取的两棵树，并将新树加入森林； (4)重复(2)、(3)步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树。 如：对 下图中的六个带权叶子结点来构造一棵哈夫曼树，步骤如下： 注意：为了使得到的哈夫曼树的结构尽量唯一，通常规定生成的哈夫曼树中每个结点的左子树根结点的权小于等于右子树根结点的权。 具体算法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//2、根据数组 a 中 n 个权值建立一棵哈夫曼树，返回树根指针PBTreeNode CreateHuffman(ElemType a[], int n)&#123; int i, j; struct BTreeNode **b, *q; b = malloc(n*sizeof(struct BTreeNode)); for (i = 0; i &lt; n; i++) //初始化b指针数组，使每个指针元素指向a数组中对应的元素结点 &#123; b[i] = malloc(sizeof(struct BTreeNode)); b[i]-&gt;data = a[i]; b[i]-&gt;left = b[i]-&gt;right = NULL; &#125; for (i = 1; i &lt; n; i++)//进行 n-1 次循环建立哈夫曼树 &#123; //k1表示森林中具有最小权值的树根结点的下标，k2为次最小的下标 int k1 = -1, k2; for (j = 0; j &lt; n; j++)//让k1初始指向森林中第一棵树，k2指向第二棵 &#123; if (b[j] != NULL &amp;&amp; k1 == -1) &#123; k1 = j; continue; &#125; if (b[j] != NULL) &#123; k2 = j; break; &#125; &#125; for (j = k2; j &lt; n; j++)//从当前森林中求出最小权值树和次最小 &#123; if (b[j] != NULL) &#123; if (b[j]-&gt;data &lt; b[k1]-&gt;data) &#123; k2 = k1; k1 = j; &#125; else if (b[j]-&gt;data &lt; b[k2]-&gt;data) k2 = j; &#125; &#125; //由最小权值树和次最小权值树建立一棵新树，q指向树根结点 q = malloc(sizeof(struct BTreeNode)); q-&gt;data = b[k1]-&gt;data + b[k2]-&gt;data; q-&gt;left = b[k1]; q-&gt;right = b[k2]; b[k1] = q;//将指向新树的指针赋给b指针数组中k1位置 b[k2] = NULL;//k2位置为空 &#125; free(b); //删除动态建立的数组b return q; //返回整个哈夫曼树的树根指针&#125; 3、哈夫曼编码在电报通信中，电文是以二进制的0、1序列传送的，每个字符对应一个二进制编码，为了缩短电文的总长度，采用不等长编码方式，构造哈夫曼树， 将每个字符的出现频率作为字符结点的权值赋予叶子结点，每个分支结点的左右分支分别用0和1编码，从树根结点到每个叶子结点的路径上 所经分支的0、1编码序列等于该叶子结点的二进制编码。如上文所示的哈夫曼编码如下： a 的编码为：00 b 的编码为：01 c 的编码为：100 d 的编码为：1010 e 的编码为：1011 f 的编码为：11 4、哈夫曼树的操作运算以上文的哈夫曼树作为具体实例，用详细的程序展示哈夫曼树的操作运算 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115//// Created by cheng on 18-7-9.//#include "huffman.h"//1、输出二叉树，可在前序遍历的基础上修改。采用广义表格式，元素类型为intvoid PrintBTree_int(struct BTreeNode* BT)&#123; if (BT != NULL) &#123; printf("%d", BT-&gt;data); //输出根结点的值 if (BT-&gt;left != NULL || BT-&gt;right != NULL) &#123; printf("("); PrintBTree_int(BT-&gt;left); //输出左子树 if (BT-&gt;right != NULL) printf(","); PrintBTree_int(BT-&gt;right); //输出右子树 printf(")"); &#125; &#125;&#125;//2、根据数组 a 中 n 个权值建立一棵哈夫曼树，返回树根指针PBTreeNode CreateHuffman(ElemType a[], int n)&#123; int i, j; struct BTreeNode **b, *q; b = malloc(n*sizeof(struct BTreeNode)); for (i = 0; i &lt; n; i++) //初始化b指针数组，使每个指针元素指向a数组中对应的元素结点 &#123; b[i] = malloc(sizeof(struct BTreeNode)); b[i]-&gt;data = a[i]; b[i]-&gt;left = b[i]-&gt;right = NULL; &#125; for (i = 1; i &lt; n; i++)//进行 n-1 次循环建立哈夫曼树 &#123; //k1表示森林中具有最小权值的树根结点的下标，k2为次最小的下标 int k1 = -1, k2; for (j = 0; j &lt; n; j++)//让k1初始指向森林中第一棵树，k2指向第二棵 &#123; if (b[j] != NULL &amp;&amp; k1 == -1) &#123; k1 = j; continue; &#125; if (b[j] != NULL) &#123; k2 = j; break; &#125; &#125; for (j = k2; j &lt; n; j++)//从当前森林中求出最小权值树和次最小 &#123; if (b[j] != NULL) &#123; if (b[j]-&gt;data &lt; b[k1]-&gt;data) &#123; k2 = k1; k1 = j; &#125; else if (b[j]-&gt;data &lt; b[k2]-&gt;data) k2 = j; &#125; &#125; //由最小权值树和次最小权值树建立一棵新树，q指向树根结点 q = malloc(sizeof(struct BTreeNode)); q-&gt;data = b[k1]-&gt;data + b[k2]-&gt;data; q-&gt;left = b[k1]; q-&gt;right = b[k2]; b[k1] = q;//将指向新树的指针赋给b指针数组中k1位置 b[k2] = NULL;//k2位置为空 &#125; free(b); //删除动态建立的数组b return q; //返回整个哈夫曼树的树根指针&#125;//3、求哈夫曼树的带权路径长度ElemType WeightPathLength(PBTreeNode FBT, int len)//len初始为0&#123; if (FBT == NULL) //空树返回0 return 0; else &#123; if (FBT-&gt;left == NULL &amp;&amp; FBT-&gt;right == NULL)//访问到叶子结点 return FBT-&gt;data * len; else //访问到非叶子结点，进行递归调用，返回左右子树的带权路径长度之和，len递增 return WeightPathLength(FBT-&gt;left,len+1)+WeightPathLength(FBT-&gt;right,len+1); &#125;&#125;//4、哈夫曼编码（可以根据哈夫曼树带权路径长度的算法基础上进行修改）void HuffManCoding(PBTreeNode FBT, int len)//len初始值为0&#123; static int a[10];//定义静态数组a，保存每个叶子的编码，数组长度至少是树深度减一 if (FBT != NULL)//访问到叶子结点时输出其保存在数组a中的0和1序列编码 &#123; if (FBT-&gt;left == NULL &amp;&amp; FBT-&gt;right == NULL) &#123; int i; printf("结点权值为%d的编码：", FBT-&gt;data); for (i = 0; i &lt; len; i++) printf("%d", a[i]); printf("\n"); &#125; else//访问到非叶子结点时分别向左右子树递归调用，并把分支上的0、1编码保存到数组a &#123; //的对应元素中，向下深入一层时len值增1 a[len] = 0; HuffManCoding(FBT-&gt;left, len + 1); a[len] = 1; HuffManCoding(FBT-&gt;right, len + 1); &#125; &#125;&#125; 运行结果：]]></content>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的性质]]></title>
    <url>%2F2018%2F07%2F09%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2Fbinary-tree-1%2F</url>
    <content type="text"><![CDATA[转载自：https://blog.csdn.net/why_still_confused/article/details/51532222 作者：若明天不见 二叉树（Binary Tree） 定义：一棵二叉树是结点的一个有限集合，该集合或者为空，或者是由一个根结点加上两棵分别称为左子树和右子树的、互不相交的二叉树组成。 特点：每个结点至多只有两棵子树（二叉树中不存在度大于2的结点） 五种形态： 1. 性质1性质1 在二叉树的第 i 层至多有 2^(i －1)个结点。(i&gt;=1) [用数学归纳法证明] ​ 证明：当i=1时，只有根结点，2^(i －1)=2^0=1。 ​ 1) 设：对所有j，i&gt;j&gt;=1，命题成立，即第j层上至多有2^(j-1)个结点。 ​ 2) 由归纳假设第i-1层上至多有2^(i－2)个结点。 ​ 3) 由于二叉树的每个结点的度至多为2，故在第i层上的最大结点数为第i-1层上的最大结点数的2倍，即2* 2^(i－2)= 2^(i-1) 证毕。 ​ 2. 性质2性质2 深度为 k 的二叉树至多有 2^(k-1)个结点(k &gt;=1)。 ​ 证明：由性质1可见，深度为k的二叉树的最大结点数为 3. 性质3性质3 对任何一棵二叉树T, 如果其叶结点数为n0, 度为2的结点数为 n2,则n0＝n2＋1。 ​ 证明：若度为1的结点有 n1个，总结点个数为n，总边数为 e，则根据二叉树的定义， ​ n = n0 + n1 + n2 ​ e = 2n2 + n1 = n - 1 (除了根节点，每个节点对应一条边 ) ​ 因此，有 2n2+ n1 =n0 + n1 + n2- 1 ​ n2= n0 - 1 =&gt; n0= n2+ 1 ​ 空链域：2n0+ n1 = n0 + n2 +1+ n1 = n+1 4. 性质4性质4 具有 n (n&gt;=0) 个结点的完全二叉树的深度为＋1 ​ 证明：设完全二叉树的深度为 h，则根据性质2 和完全二叉树的定义有 ​ 2^(h－1)- 1 &lt; n &lt;= 2^(h- 1)或 2^(h－1)&lt;= n &lt; 2^h ​ 取对数 h－1 &lt; log2n &lt;= h，又h是整数， ​ 因此有 h = ＋1 5. 性质5性质5 如将一棵有n个结点的完全二叉树自顶向下，同层自左向右连续为结点编号0,1, …, n-1，则有： ​ 1）若i = 0, 则 i 无双亲, 若i &gt; 0, 则 i 的双亲为」(i -1)/2」 ​ 2）若2i+1 &lt; n, 则i 的左子女为 2i+1，若2i+2 &lt; n, 则 i 的右子女为2i+2 ​ 3）若结点编号i为偶数，且i != 0,则左兄弟结点i-1. ​ 4）若结点编号i为奇数，且i != n-1,则右兄弟结点为i+1. ​ 5）结点i 所在层次为」log2(i+1) 」]]></content>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中缀表达式转后缀表达式]]></title>
    <url>%2F2018%2F07%2F09%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2Finfix-to-suffix%2F</url>
    <content type="text"><![CDATA[转载自：https://blog.csdn.net/sgbfblog/article/details/8001651 作者：七把刀 一、后缀表达式求值后缀表达式也叫逆波兰表达式，其求值过程可以用到栈来辅助存储。假定待求值的后缀表达式为：6 5 2 3 + 8 * + 3 + *，则其求值过程如下： 1）遍历表达式，遇到的数字首先放入栈中，此时栈如下所示： 2）接着读到“+”，则弹出3和2，执行3+2，计算结果等于5，并将5压入到栈中。 3）读到8，将其直接放入栈中。 4）读到“*”，弹出8和5，执行8*5，并将结果40压入栈中。而后过程类似，读到“+”，将40和5弹出，将40+5的结果45压入栈…以此类推。最后求的值288。 二、中缀表达式转后缀表达式2.1）规则中缀表达式a + bc + (d e + f) g，其转换成后缀表达式则为a b c + d e f + g +。 转换过程需要用到栈，具体过程如下： 1）如果遇到操作数，我们就直接将其输出。 2）如果遇到操作符，则我们将其放入到栈中，遇到左括号时我们也将其放入栈中。 3）如果遇到一个右括号，则将栈元素弹出，将弹出的操作符输出直到遇到左括号为止。注意，左括号只弹出并不输出。 4）如果遇到任何其他的操作符，如（“+”， “*”，“（”）等，从栈中弹出元素直到遇到发现更低优先级的元素(或者栈为空)为止。弹出完这些元素后，才将遇到的操作符压入到栈中。有一点需要注意，只有在遇到” ) “的情况下我们才弹出” ( “，其他情况我们都不会弹出” ( “。 5）如果我们读到了输入的末尾，则将栈中所有元素依次弹出。 2.2）实例规则很多，还是用实例比较容易说清楚整个过程。以上面的转换为例，输入为a + b * c + (d * e + f)*g，处理过程如下： 1）首先读到a，直接输出。 2）读到“+”，将其放入到栈中。 3）读到b，直接输出。 此时栈和输出的情况如下： 4）读到“*”，因为栈顶元素”+”优先级比” * “ 低，所以将” * “直接压入栈中。 5）读到c，直接输出。 此时栈和输出情况如下： 6）读到” + “，因为栈顶元素” “的优先级比它高，所以弹出” \ “并输出， 同理，栈中下一个元素” + “优先级与读到的操作符” + “一样，所以也要弹出并输出。然后再将读到的” + “压入栈中。 此时栈和输出情况如下： 7）下一个读到的为”(“，它优先级最高，所以直接放入到栈中。 8）读到d，将其直接输出。 此时栈和输出情况如下： 9）读到” * “，由于只有遇到” ) “的时候左括号”(“才会弹出，所以” * “直接压入栈中。 10）读到e，直接输出。 此时栈和输出情况如下： 11）读到” + “，弹出”* “并输出，然后将”+”压入栈中。 12）读到f，直接输出。 此时栈和输出情况： 13）接下来读到“）”，则直接将栈中元素弹出并输出直到遇到”(“为止。这里右括号前只有一个操作符”+”被弹出并输出。 14）读到” * “，压入栈中。读到g，直接输出。 15）此时输入数据已经读到末尾，栈中还有两个操作符“*”和” + “，直接弹出并输出。 至此整个转换过程完成。程序实现代码后续再补充了。 2.3）转换的另一种方法1)先按照运算符的优先级对中缀表达式加括号，变成( ( a+(b*c) ) + ( ((d*e)+f) *g ) ) 2)将运算符移到括号的后面，变成((a(bc)*)+(((de)*f)+g)*)+ 3)去掉括号，得到abc*+de*f+g*+]]></content>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大疆嵌入式软件笔试题]]></title>
    <url>%2F2018%2F07%2F05%2Fdji-test%2F</url>
    <content type="text"><![CDATA[一、编程题1. 有如下CAT_s结构体定义，回答： 1) 在一台64位的机器上，使用32位编译，Garfield 变量占用多少内存空间？64位编译又是如何？（总分5分） 2) 使用32位编译情况下，给出一种判断所使用机器大小端的方法。（总分5分） 1234567struct CAT_s&#123; int ld; char Color; unsigned short Age; char *Name; void(*Jump)(void);&#125;Garfield; 2. 描述下面XXX 这个宏的作用。（总分10分） 12345#define offsetof(TYPE,MEMBER)((size_t)&amp;((TYPE*)0)-&gt;MEMBER) // 计算MEMBER在结构体中的偏移量#define container_of(ptr, type, member) (&#123;\ const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr);\ (type *)( (char *)__mptr - offsetof(type,member) );&#125;) 3. 简述C 函数： 1) 参数如何传递（__cdecl调用方式）； 2) 返回值如何传递； 3) 调用后如何 返回到调用前的下一条指令执行。（总分10分） 答： 1) __cdecl调用方式的三个特点： 从右向左压入参数 由调用方负责参数压栈和清除栈(栈帧回退) 函数名会自动添加前导下划线 __stdcall是StandardCall的缩写，是C++的标准调用方式：所有参数从右到左依次入栈，由调用者负责把参数压入栈，最后由被调用者负责清除栈的内容 2) 返回值 返回值小于等于4个字节时，存储在eax中 返回值5~8个字节时，eax和edx联合存储返回 返回值大于8个字节时，创建临时栈，返回值存在临时栈中 3) 如何返回 完整介绍调用和返回的过程 调用过程： 函数调用方将参数从右向左依次压入栈中 压入函数返回地址 pushl %ebp; movl %esp %ebp; 保存在函数调用过程中需要保持不变的寄存器，如ebx,esi,edi 被调用函数保存临时变量 返回过程： movl %ebp, %esp; popl %ebp 弹出函数返回地址到程序计数器PC中 二．嵌入式基本知识1. 简述处理器中断处理的过程（中断向量、中断保护现场、中断嵌套、中断返回等）。（总 分10分） 外设产生中断信号，经过中断控制器进行筛选，选出中断优先级比较高的中断信号，把中断号传给CPU CPU禁用中断 CPU根据中断号，查找中断向量表，获得对应的中断服务程序的地址 CPU将一些重要的寄存器的内容压入堆栈中，如CS,EIP,SS,ESP,EFLAG 跳转到中断服务程序，CPU重新允许中断 执行中断服务例程，如何此时又有其他中断信号产生，重复以上步骤 中断返回时，需要先禁用中断 将堆栈中的寄存器弹回，回到原来的程序中 重新允许中断 2. 简述处理器在读内存的过程中，CPU 核、cache 、MMU 如何协同工作？画出CPU 核、 cache 、MMU 、内存之间的关系示意图加以说明（可以以你熟悉的处理器为例）。（总分10分） 三．基本通信知识1. 请说明总线接口USRT 、I2C 、USB 的异同点（串/并、速度、全/半双工、总线拓扑等）。 （总分5分） UART 通用异步串行口，速率不快，可全双工，结构上一般由波特率产生器、UART发送器、UART接收器组成，硬件上两线，一收一发。 SPI 高速同步串行口，高速，可全双工，收发独立，同步接口，可实现多个SPI设备互联，硬件3~4线。 I2C 双向、两线、串行、多主控接口标准。速率不快，半双工，同步接口，具有总线仲裁机制，非常适合器件间近距离经常性数据通信，可实现设备组网。 USB 通用串行总线，高速，半双工，由主机、hub、设备组成。设备可以与下级hub相连构成星型结构。 以表格总结如下： 2. 列举你所知道的linux 内核态和用户态之间的通信方式并给出你认为效率最高的方式， 说明理由。（总分5分） 四．系统设计有一个使用UART 进行通信的子系统X ，其中UART0进行数据包接收和回复，UART1进行数据包转发。子系统X 的通信模块职责是从UART0接收数据包，如果为本地数据包（receiver 为子系统X ），则解析数据包中的命令码（2字节）和数据域（0~128字节），根据命令码调用内部的处理程序，并将处理结果通过UART0回复给发送端，如果非本地数据包，则通过UART1转发。 如果由你来设计子系统X 的通信模块： 1) 请设计通信数据包格式，并说明各字段的定义；（总分5分） 2) 在一个实时操作系统中，你会如何部署模块中的任务和缓存数据，画出任务间的数据流视图加以说明；（总分5分） 3) 你会如何设置任务的优先级，说说优缺点；（总分5分） 4) 如果将命令码对应的处理优先级分为高、低两个等级，你又会如何设计；（总分5分） 参考文献[1] 2014年大疆创新笔试题目]]></content>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言部分知识点]]></title>
    <url>%2F2018%2F07%2F05%2FC%E5%92%8CC%2B%2B%2FC%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[C语言中带负数的除法 做除法的时候，商是令其与除数相乘的积的绝对值不超过被除数的绝对值且最接近的那个数。 (-10)/3==-3;10/(-3)==-3;(-10)/(-3)==3; (-10)%3==-1;10%(-3)==1;(-10)%(-3)==-1;]]></content>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大话数据结构]]></title>
    <url>%2F2018%2F07%2F04%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2Fdata-structure%2F</url>
    <content type="text"><![CDATA[逻辑结构与物理结构逻辑结构： 线性表 树 图 物理结构： 顺序存储 链式存储 索引存储 散列存储 线性表线性表的抽象数据结构 12345678910111213141516// 初始化线性表InitList(*L);// 判断线性表是否为空IsEmptyList(L);// 获取线性表的长度ListLength(L);// 删除线性表ClearList(*L);// 线性表中插入元素ListInsert(*L, i ,e);// 线性表中删除元素ListDelete(*L, i, *e);// 获取指定位置的元素GetElement(L, i, *e);// 获取某个元素所在的位置LocateElement(L, e);]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-transplant]]></title>
    <url>%2F2018%2F06%2F30%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2Flinux-transplant%2F</url>
    <content type="text"><![CDATA[Linux编译初体验首先下载好100ask提供的Linux内核包和补丁 linux-2.6.22.6.tar.bz2 linux-2.6.22.6_jz2440.patch 编译初体验步骤 打补丁 找到类似的板子，使用其默认配置， 在默认配置基础上make menuconfig做修改,两步配置的结果是生成.config文件 1234$ tar jxvf linux-2.6.22.6.tar.bz2$ cd linux-2.6.22.6$ patch -p1 &lt; ../linux-2.6.22.6_jz2440.patch$ make s3c2410_defconfig # 先做默认配置，位于/arch/arm/configs目录下，配置结果会保存在.config文件中。 make s3c2410_defconfig报错，因为make版本太新 123Makefile:416: *** mixed implicit and normal rules: deprecated syntaxMakefile:1449: *** mixed implicit and normal rules: deprecated syntaxmake: *** No rule to make target 's3c2410_defconfig'。 停止。 根据错误提示修改这两行的内容 12345416 config %config: scripts_basic outputmakefile FORCE改成 %config: scripts_basic outputmakefile FORCE1449 / %/: prepare scripts FORCE改成 %/: prepare scripts FORCE 重新make s3c2410_defconfig，成功。 百问网已经提供了完整的配置文件config_ok(根目录下)，因此可以复制.config 12$ cp config_ok .config$ make menuconfig]]></content>
      <tags>
        <tag>内核</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[uboot移植过程]]></title>
    <url>%2F2018%2F06%2F28%2F%E5%B5%8C%E5%85%A5%E5%BC%8F%2Fuboot-transplant%2F</url>
    <content type="text"><![CDATA[uboot初体验工作环境 make 4.1 arm-linux-gcc 3.4.5 oflash——使用100ask.org提供的Linux下的oflash工具 配置编译过程 解压缩 打补丁：patch -p1 &lt; ../补丁文件 配置：make 100ask24x0_config 编译：make 12345$ tar jxvf u-boot-1.1.6.tar.bz2$ cd u-boot-1.1.6$ patch -p1 &lt; ../u-boot-1.1.6_jz2440.patch$ make 100ask24x0_config$ make 最开始make的时候报错： 1Makefile:327: target 'u-boot-1.1.6' given more than once in the same rule 经过查找，原因在于我的交叉编译链arm-linux-gcc版本太新，最后换成arm-linux-gcc-3.4.5版本，就可以了 同样的道理后面移植Linux内核的时候，make也报错，那是因为make版本太新 123Makefile:416: *** mixed implicit and normal rules: deprecated syntaxMakefile:1449: *** mixed implicit and normal rules: deprecated syntaxmake: *** No rule to make target 's3c2410_defconfig'。 停止。 根据错误提示修改这两行的内容 12345416 config %config: scripts_basic outputmakefile FORCE改成 %config: scripts_basic outputmakefile FORCE1449 / %/: prepare scripts FORCE改成 %/: prepare scripts FORCE 烧录uboot.bin make成功之后会在uboot的根目录下生成u-boot,u-boot.bin,u-boot.srec.可以将u-boot.bin烧录到Nand flash上 12$ oflash u-boot.bin# 根据提示，依次输入 0 1 0 0 0，将u-boot.bin烧录到Nand flash中。 uboot简介 uboot支持菜单和命令 常用命令 print——打印环境变量 menu——显示uboot菜单 set——设环境变量 set bootdelay 10 save——保存环境变量,直接输入 save reset——重启 uboot的核心功能 从flash中读出内核，放到SDRAM中，启动内核。因此uboot需要有以下功能： 硬件初始化，包括关看门狗，初始化时钟，初始化SDRAM等 从Flash中读取内核到SDRAM 启动内核 另外为了开发方便，添加额外的功能 烧写flash 网卡 usb 串口 配置命令分析分析配置命令make 100ask24x0_config，查看Makefile可知 1234100ask24x0_config : unconfig @$(MKCONFIG) $(@:_config=) arm arm920t 100ask24x0 NULL s3c24x0# ./mkconfig 100ask24x0 arm arm920t 100ask24x0 NULL s3c24x0# $0 $1 $2 $3 $4 $5 $6 于是可以知道，会去执行./mkconfig脚本，查看mkconfig，其主要完成的动作为 创建include下的快捷方式 创建include目录 在include目录下为asm-arm创建一个快捷方式为asm 在asm(asm-arm)目录下创建arch-s3c2440目录，同时创建其快捷方式为arch目录 在asm(asm-arm)目录下为proc-arm目录创建其快捷方式为proc目录 在include目录下创建config.mk文件，内容如下 1234ARCH = armCPU = arm920tBOARD = 100ask24x0SOC = s3c24x0 在include目录下创建config.h文件，内容如下 12/* Automatically generated - do not edit */#include &lt;configs/100ask24x0.h&gt; 编译分析编译命令make 执行make命令，在运行时最后面输出的内容，先大概浏览一下 123456UNDEF_SYM=`arm-linux-objdump -x lib_generic/libgeneric.a board/100ask24x0/lib100ask24x0.a cpu/arm920t/libarm920t.a cpu/arm920t/s3c24x0/libs3c24x0.a lib_arm/libarm.a fs/cramfs/libcramfs.a fs/fat/libfat.a fs/fdos/libfdos.a fs/jffs2/libjffs2.a fs/reiserfs/libreiserfs.a fs/ext2/libext2fs.a net/libnet.a disk/libdisk.a rtc/librtc.a dtt/libdtt.a drivers/libdrivers.a drivers/nand/libnand.a drivers/nand_legacy/libnand_legacy.a drivers/usb/libusb.a drivers/sk98lin/libsk98lin.a common/libcommon.a |sed -n -e 's/.*\(__u_boot_cmd_.*\)/-u\1/p'|sort|uniq`;\ cd /media/cheng/work/uboot_transplant/u-boot-1.1.6 &amp;&amp; arm-linux-ld -Bstatic -T /media/cheng/work/uboot_transplant/u-boot-1.1.6/board/100ask24x0/u-boot.lds -Ttext 0x33F80000 $UNDEF_SYM cpu/arm920t/start.o \ --start-group lib_generic/libgeneric.a board/100ask24x0/lib100ask24x0.a cpu/arm920t/libarm920t.a cpu/arm920t/s3c24x0/libs3c24x0.a lib_arm/libarm.a fs/cramfs/libcramfs.a fs/fat/libfat.a fs/fdos/libfdos.a fs/jffs2/libjffs2.a fs/reiserfs/libreiserfs.a fs/ext2/libext2fs.a net/libnet.a disk/libdisk.a rtc/librtc.a dtt/libdtt.a drivers/libdrivers.a drivers/nand/libnand.a drivers/nand_legacy/libnand_legacy.a drivers/usb/libusb.a drivers/sk98lin/libsk98lin.a common/libcommon.a --end-group -L /home/cheng/ProgramFiles/Portable/gcc-3.4.5-glibc-2.3.6/bin/../lib/gcc/arm-linux/3.4.5 -lgcc \ -Map u-boot.map -o u-bootarm-linux-objcopy --gap-fill=0xff -O srec u-boot u-boot.srecarm-linux-objcopy --gap-fill=0xff -O binary u-boot u-boot.bin 可以看到中间部分是编译的主要内容 123arm-linux-ld -Bstatic -T /media/cheng/work/uboot_transplant/u-boot-1.1.6/board/100ask24x0/u-boot.lds -Ttext 0x33F80000 $UNDEF_SYM cpu/arm920t/start.o \ --start-group lib_generic/libgeneric.a board/100ask24x0/lib100ask24x0.a cpu/arm920t/libarm920t.a cpu/arm920t/s3c24x0/libs3c24x0.a lib_arm/libarm.a fs/cramfs/libcramfs.a fs/fat/libfat.a fs/fdos/libfdos.a fs/jffs2/libjffs2.a fs/reiserfs/libreiserfs.a fs/ext2/libext2fs.a net/libnet.a disk/libdisk.a rtc/librtc.a dtt/libdtt.a drivers/libdrivers.a drivers/nand/libnand.a drivers/nand_legacy/libnand_legacy.a drivers/usb/libusb.a drivers/sk98lin/libsk98lin.a common/libcommon.a --end-group -L /home/cheng/ProgramFiles/Portable/gcc-3.4.5-glibc-2.3.6/bin/../lib/gcc/arm-linux/3.4.5 -lgcc \ -Map u-boot.map -o u-boot 分成三个部分，一是链接脚本，二是链接的原材料(包括.o文件和.a文件)，三是输出文件(u-boot) 链接脚本路径 /media/cheng/work/uboot_transplant/u-boot-1.1.6/board/100ask24x0/u-boot.lds 1234567891011121314151617181920212223242526272829303132333435OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")/*OUTPUT_FORMAT("elf32-arm", "elf32-arm", "elf32-arm")*/OUTPUT_ARCH(arm)ENTRY(_start)SECTIONS&#123; . = 0x00000000; // 链接时设置了-Ttext 0x33F80000,因此要加上该偏移量，才是加载时的地址 . = ALIGN(4); .text : &#123; cpu/arm920t/start.o (.text) //整个elf文件从cpu/arm920t/start.o的代码段开始 board/100ask24x0/boot_init.o (.text) *(.text) &#125; . = ALIGN(4); .rodata : &#123; *(.rodata) &#125; . = ALIGN(4); .data : &#123; *(.data) &#125; . = ALIGN(4); .got : &#123; *(.got) &#125; . = .; __u_boot_cmd_start = .; .u_boot_cmd : &#123; *(.u_boot_cmd) &#125; __u_boot_cmd_end = .; . = ALIGN(4); __bss_start = .; .bss : &#123; *(.bss) &#125; _end = .;&#125; 分析make 阅读cpu/arm920t/start.S——因为从链接脚本看出整个elf文件从cpu/arm920t/start.o的代码段开始 board/100ask24x0/u-boot.lds，和 0x33F80000——分析链接地址 JZ2440的SDRAM为64MB，地址从0x3000000开始，最高的512KB的空间用来存放uboot。如果你的uboot比较大，则可以适当调整TextBase 源码分析系统时钟MPLL为400MHz uboot第一阶段——硬件初始化 进入管理模式SVC 关闭看门狗 屏蔽中断 初始化SDRAM 设置栈 时钟 代码重定位（从flash复制到SDRAM中） 清BSS段 调用start_armboot uboot第二阶段 uboot菜单 uboot启动内核 uboot启动内核 分区概念：PC上每个硬盘都有分区表，但是在嵌入式Linux的flash中没有分区表 在arm中“分区”其实是规划好之后，固定好每个分区的起始地址和大小 uboot中输入mtd命令之后，可以查看分区信息 nand flash有64MB，SDRAM为64MB 123456789101112device nand0 &lt;nandflash0&gt;, # parts = 4 #: name size offset mask_flags 0: bootloader 0x00040000 0x00000000 0 1: params 0x00020000 0x00040000 0 2: kernel 0x00200000 0x00060000 0 3: root 0x0fda0000 0x00260000 0active partition: nand0,0 - (bootloader) 0x00040000 @ 0x00000000defaults:mtdids : nand0=nandflash0mtdparts: mtdparts=nandflash0:256k@0(bootloader),128k(params),2m(kernel),-(root) uboot中输入print命令之后，可以查看参数信息 1234567...bootcmd=nand read.jffs2 0x30007FC0 kernel; # bootcmd=nand read.jffs2 0x30007FC0 0x00200000; bootm 0x30007FC0# 这里的kernel用于代替分区的起始地址0x00060000，偏移量0x00200000# 表示从kernel分区中读取bootm 0x30007FC0... 启动内核需要两条命令 nand read.jffs2 0x30007FC0 kernel——将nand flash的kernel分区读到0x30007FC0，读出内核 bootm 0x30007FC0——启动内核 根据头部移动内核到合适的地方（uImage头部定好了加载地址为0x30008000） 启动do_bootm_linux uboot告诉内核，相关的启动参数（参数地址在0x30000100，然后按照固定格式开始存放） 跳到入口地址 flash上存的内核uImage，其格式为：头部+真正的内核 内核参数格式如下： setup_start_tag setup_memory_tags setup_commandline_tag setup_end_tag 环境变量 默认 flash上保存的 uboot的两个主要的功能 （1）uboot启动内核 start_armboot flash_init nand_init main_loop 12s=getenv("boot_cmd"); // 获取boot_cmd环境变量，而boot_cmd环境变量的内容就是启动命令run_command(s,..); // 运行命令 （2）uboot界面 12readline(); // 读串口run_command(); // 运行命令]]></content>
      <tags>
        <tag>arm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[知识点准备]]></title>
    <url>%2F2018%2F06%2F27%2Fpreparing%2F</url>
    <content type="text"><![CDATA[1. DSP和ARM有什么区别？ 2. 设备的独立性 应用程序独立于具体使用的物理设备 3. 进程上下文是进程执行全过程的静态描述 4. 静态优先和动态优先，是否会饥饿 静态优先算法，不管是可抢占的还是不可抢占的，低优先级进程都有可能饥饿 动态优先算法则不会，因为会随着等待时间的增加而提高进程的优先级 5. 死锁的处理方法 鸵鸟策略——系统发生死锁的可能性/频率比较小，则不用管是否会死锁，等发生了死锁导致系统崩溃，重启即可 预防策略 避免策略 检测与解除死锁 ARM嵌入式1. Nand和Nor的区别 指标 Nor Nand 容量 小，1MB~32MB 16MB~512MB 片上运行(XIP) 支持XIP 不支持XIP 性能 读写擦除都很快 读快，写慢，擦除特别慢 生命周期 长 短 接口 RAM接口 I/O接口 访问顺序 随机访问 顺序访问 主要用途 保存代码和关键数据 保存数据（不支持XIP，不能保存程序） 价格 贵 便宜 2. Nand的访问 物理连接： 片选线 数据线 地址锁存线 命令锁存线 读使能线 写使能线 就绪/忙输出线 使用方法 传命令字 -&gt; 传地址 -&gt; 读/写数据 3. Nand参数 64MB，26根地址线 组织方式，一页512B，一块32页，总共4096块，即128K页 4. S3C2440的地址空间 地址空间总共有1GB，分成8个Bank 每个bank可以设置总线位宽（8/16/32bit） 支持外接ROM，SRAM，SDRAM 5. S3C2440的外设 Nor flash,SDRAM,网卡，IDE接口，串口芯片 6. 三种存储器 Nand——I/O接口，程序不能在片上运行，只能存放数据，相当于硬盘 Nor——内存接口，支持片上运行，可以存放程序和数据 SDRAM——内存接口，支持片上运行，相当于内存 7. S3C2440启动方式 启动地址固定为0地址， 从Nor启动——Nor地址会被映射到0地址，因此可以从Nor开始执行程序。 从Nand启动——Nand使用的I/O接口，刚上电时，未进行I/O初始化，不能读取，芯片内部设计，当选择从Nand启动时，硬件自动复制Nand的前4K的内容到steppingstone中，并且此时steppingstone被映射到0地址，因此从steppingstone中开始执行程序。因为SDRAM具有更好的性能，因此，一般会再将steppingstone的内容复制到SDRAM中，运行。 8. 操作SDRAM 关闭看门狗，否则CPU会不断重启 设置存储控制器（13个）：位宽和等待控制寄存器，8个Bank控制寄存器，3个SDRAM的相关寄存器 复制代码到SDRAM中 设置栈（有了栈才可以使用函数） 跳转到SDRAM中运行程序]]></content>
      <tags>
        <tag>找工作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode-skills]]></title>
    <url>%2F2018%2F06%2F25%2F%E6%97%A5%E5%B8%B8%2Fvscode-skills%2F</url>
    <content type="text"><![CDATA[转载自 CSDN博客：VS Code折腾记 - (2) 快捷键大全，没有更全 作者：CRPER vscode列复制： alt + shift + 鼠标左键选择 函数跳转：ctrl+鼠标左键 函数跳转返回：ctrl+alt+- VsCode 快捷键有五种组合方式（科普） Ctrl + Shift + ? : 这种常规组合按钮 Ctrl + V Ctrl +V : 同时依赖一个按键的组合 Shift + V c : 先组合后单键的输入 Ctrl + Click: 键盘 + 鼠标点击 Ctrl + DragMouse : 键盘 + 鼠标拖动 通用快捷键 快捷键 作用 Ctrl+Shift+P,F1 展示全局命令面板 Ctrl+P 快速打开最近打开的文件 Ctrl+Shift+N 打开新的编辑器窗口 Ctrl+Shift+W 关闭编辑器 基础编辑 快捷键 作用 Ctrl + X 剪切 Ctrl + C 复制 Alt + up/down 移动行上下 Shift + Alt up/down 在当前行上下复制当前行 Ctrl + Shift + K 删除行 Ctrl + Enter 在当前行下插入新的一行 Ctrl + Shift + Enter 在当前行上插入新的一行 Ctrl + Shift + \ 匹配花括号的闭合处，跳转 Ctrl + ] / [ 行缩进 Home 光标跳转到行头 End 光标跳转到行尾 Ctrl + Home 跳转到页头 Ctrl + End 跳转到页尾 Ctrl + up/down 行视图上下偏移 Alt + PgUp/PgDown 屏视图上下偏移 Ctrl + Shift + [ 折叠区域代码 Ctrl + Shift + ] 展开区域代码 Ctrl + K Ctrl + [ 折叠所有子区域代码 Ctrl + k Ctrl + ] 展开所有折叠的子区域代码 Ctrl + K Ctrl + 0 折叠所有区域代码 Ctrl + K Ctrl + J 展开所有折叠区域代码 Ctrl + K Ctrl + C 添加行注释 Ctrl + K Ctrl + U 删除行注释 Ctrl + / 添加关闭行注释 Shift + Alt +A 块区域注释 Alt + Z 添加关闭词汇包含 导航 快捷键 作用 Ctrl + T 列出所有符号 Ctrl + G 跳转行 Ctrl + P 跳转文件 Ctrl + Shift + O 跳转到符号处 Ctrl + Shift + M 打开问题展示面板 F8 跳转到下一个错误或者警告 Shift + F8 跳转到上一个错误或者警告 Ctrl + Shift + Tab 切换到最近打开的文件 Alt + left / right 向后、向前 Ctrl + M 进入用Tab来移动焦点 查询与替换 快捷键 作用 Ctrl + F 查询 Ctrl + H 替换 F3 / Shift + F3 查询下一个/上一个 Alt + Enter 选中所有出现在查询中的 Ctrl + D 匹配当前选中的词汇或者行，再次选中-可操作 Ctrl + K Ctrl + D 移动当前选择到下个匹配选择的位置(光标选定) Alt + C / R / W 多行光标操作于选择 快捷键 作用 Alt + Click 插入光标-支持多个 Ctrl + Alt + up/down 上下插入光标-支持多个 Ctrl + U 撤销最后一次光标操作 Shift + Alt + I 插入光标到选中范围内所有行结束符 Ctrl + I 选中当前行 Ctrl + Shift + L 选择所有出现在当前选中的行-操作 Ctrl + F2 选择所有出现在当前选中的词汇-操作 Shift + Alt + right 从光标处扩展选中全行 Shift + Alt + left 收缩选择区域 Shift + Alt + (drag mouse) 鼠标拖动区域，同时在多个行结束符插入光标 Ctrl + Shift + Alt + (Arrow Key) 也是插入多行光标的[方向键控制] Ctrl + Shift + Alt + PgUp/PgDown 也是插入多行光标的[整屏生效] 丰富的语言操作 快捷键 作用 Ctrl + Space 输入建议[智能提示] Ctrl + Shift + Space 参数提示 Tab Emmet指令触发/缩进 Shift + Alt + F 格式化代码 Ctrl + K Ctrl + F 格式化选中部分的代码 F12 跳转到定义处 Alt + F12 代码片段显示定义 Ctrl + K F12 在其他窗口打开定义处 Ctrl + . 快速修复部分可以修复的语法错误 Shift + F12 显示所有引用 F2 重命名符号 Ctrl + Shift + . / , 替换下个值 Ctrl + K Ctrl + X 移除空白字符 Ctrl + K M 更改页面文档格式 编辑器管理 快捷键 作用 Ctrl + F4, Ctrl + W 关闭编辑器 Ctrl + k F 关闭当前打开的文件夹 Ctrl + \ 切割编辑窗口 Ctrl + 1/2/3 切换焦点在不同的切割窗口 Ctrl + K Ctrl &lt;-/-&gt; 切换焦点在不同的切割窗口 Ctrl + Shift + PgUp/PgDown 切换标签页的位置 Ctrl + K &lt;-/-&gt; 切割窗口位置调换 文件管理 快捷键 作用 Ctrl + N 新建文件 Ctrl + O 打开文件 Ctrl + S 保存文件 Ctrl + Shift + S 另存为 Ctrl + K S 保存所有当前已经打开的文件 Ctrl + F4 关闭当前编辑窗口 Ctrl + K Ctrl + W 关闭所有编辑窗口 Ctrl + Shift + T 撤销最近关闭的一个文件编辑窗口 Ctrl + K Enter 保持开启 Ctrl + Shift + Tab 调出最近打开的文件列表，重复按会切换 Ctrl + Tab 与上面一致，顺序不一致 Ctrl + K P 复制当前打开文件的存放路径 Ctrl + K R 打开当前编辑文件存放位置【文件管理器】 Ctrl + K O 在新的编辑器中打开当前编辑的文件 显示 快捷键 作用 F11 切换全屏模式 Shift + Alt + 1 切换编辑布局【目前无效】 Ctrl + =/- 放大 / 缩小 Ctrl + B 侧边栏显示隐藏 Ctrl + Shift + E 资源视图和编辑视图的焦点切换 Ctrl + Shift + F 打开全局搜索 Ctrl + Shift + G 打开Git可视管理 Ctrl + Shift + D 打开DeBug面板 Ctrl + Shift + X 打开插件市场面板 Ctrl + Shift + H 在当前文件替换查询替换 Ctrl + Shift + J 开启详细查询 Ctrl + Shift + V 预览Markdown文件【编译后】 Ctrl + K v 在边栏打开渲染后的视图【新建】 调试 快捷键 作用 F9 添加解除断点 F5 启动调试、继续 F11 / Shift + F11 单步进入 / 单步跳出 F10 单步跳过 Ctrl + K Ctrl + I 显示悬浮 集成终端 快捷键 作用 Ctrl + ` 打开集成终端 Ctrl + Shift + ` 创建一个新的终端 Ctrl + Shift + C 复制所选 Ctrl + Shift + V 复制到当前激活的终端 Shift + PgUp / PgDown 页面上下翻屏 Ctrl + Home / End 滚动到页面头部或尾部]]></content>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP拥塞控制2]]></title>
    <url>%2F2018%2F06%2F24%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2Ftcp-congestion2%2F</url>
    <content type="text"><![CDATA[TCP的拥塞控制转载自网络 来源：gitbook 拥塞控制与流量控制拥塞控制：防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提：网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络传输性能有关的所有因素 流量控制：指点对点通信量的控制，是端到端正的问题。流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收 拥塞控制代价：需要获得网络内部流量分布的信息。在实施拥塞控制之前，还需要在结点之间交换信息和各种命令，以便选择控制的策略和实施控制。这样就产生了额外的开销。拥塞控制还需要将一些资源分配给各个用户单独使用，使得网络资源不能更好地实现共享。 几种拥塞控制方法慢开始( slow-start )、拥塞避免( congestion avoidance )、快重传( fast retransmit )和快恢复( fast recovery )。 慢开始和拥塞避免发送方维持一个拥塞窗口 cwnd ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞 发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数 慢开始算法慢开始算法：当主机开始发送数据时，如果立即所大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。因此，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。通常在刚刚开始发送报文段时，先把拥塞窗口 cwnd 设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。用这样的方法逐步增大发送方的拥塞窗口cwnd ，可以使分组注入到网络的速率更加合理每经过一个传输轮次，拥塞窗口 cwnd 就加倍。一个传输轮次所经历的时间其实就是往返时间RTT。不过“传输轮次”更加强调：把拥塞窗口cwnd所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认另，慢开始的“慢”并不是指cwnd的增长速率慢，而是指在TCP开始发送报文段时先设置cwnd=1，使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况），然后再逐渐增大cwnd为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量（如何设置ssthresh）。慢开始门限ssthresh的用法如下： 当 cwnd &lt; ssthresh 时，使用上述的慢开始算法 当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法 当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法 拥塞避免算法让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕如下图，用具体数值说明了上述拥塞控制的过程。现在发送窗口的大小和拥塞窗口一样大1:当TCP连接进行初始化时，把拥塞窗口cwnd置为1。前面已说过，为了便于理解，图中的窗口单位不使用字节而使用报文段的个数。慢开始门限的初始值设置为16个报文段，即 cwnd = 162:在执行慢开始算法时，拥塞窗口 cwnd的初始值为1。以后发送方每收到一个对新报文段的确认ACK，就把拥塞窗口值另1，然后开始下一轮的传输（图中横坐标为传输轮次）。因此拥塞窗口cwnd随着传输轮次按指数规律增长。当拥塞窗口cwnd增长到慢开始门限值ssthresh时（即当cwnd=16时），就改为执行拥塞控制算法，拥塞窗口按线性规律增长3:假定拥塞窗口的数值增长到24时，网络出现超时（这很可能就是网络发生拥塞了）。更新后的ssthresh值变为12（即变为出现超时时的拥塞窗口数值24的一半），拥塞窗口再重新设置为1，并执行慢开始算法。当cwnd=ssthresh=12时改为执行拥塞避免算法，拥塞窗口按线性规律增长，每经过一个往返时间增加一个MSS的大小4:强调：“拥塞避免”并非指完全能够避免了拥塞。利用以上的措施要完全避免网络拥塞还是不可能的。“拥塞避免”是说在拥塞避免阶段将拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞 快重传和快恢复如果发送方设置的超时计时器时限已到但还没有收到确认，那么很可能是网络出现了拥塞，致使报文段在网络中的某处被丢弃。这时，TCP马上把拥塞窗口 cwnd 减小到1，并执行慢开始算法，同时把慢开始门限值ssthresh减半。这是不使用快重传的情况 快重传算法 快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认接收方收到了M1和M2后都分别发出了确认。现在假定接收方没有收到M3但接着收到了M4。显然，接收方不能确认M4，因为M4是收到的失序报文段。根据可靠传输原理，接收方可以什么都不做，也可以在适当时机发送一次对M2的确认。但按照快重传算法的规定，接收方应及时发送对M2的重复确认，这样做可以让发送方及早知道报文段M3没有到达接收方。发送方接着发送了M5和M6。接收方收到这两个报文后，也还要再次发出对M2的重复确认。这样，发送方共收到了接收方的四个对M2的确认，其中后三个都是重复确认。快重传算法还规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段M3，而不必继续等待M3设置的重传计时器到期。由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20% 快恢复算法快恢复算法，其过程有以下两个要点：1:当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半。这是为了预防网络发生拥塞。请注意：接下去不执行慢开始算法。2:由于发送方现在认为网络很可能没有发生拥塞，因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。下图给出了快重传和快恢复的示意图，并标明了“TCP Reno版本”。区别：新的 TCP Reno 版本在快重传之后采用快恢复算法而不是采用慢开始算法。也有的快重传实现是把开始时的拥塞窗口cwnd值再增大一点，即等于 ssthresh + 3 X MSS . 这样做的理由是：既然发送方收到三个重复的确认，就表明有三个分组已经离开了网络。这三个分组不再消耗网络 的资源而是停留在接收方的缓存中。可见现在网络中并不是堆积了分组而是减少了三个分组。因此可适当把拥塞窗口扩大了些在采用快恢复算法时，慢开始算法只是在TCP连接建立时和网络出现超时时才使用 采用这样的拥塞控制方法使得TCP的性能有明显的改进 接收方根据自己的接收能力设定了接收窗口rwnd，并把这个窗口值写入TCP首部中的窗口字段，传送给发送方。因此，接收窗口又称为通知窗口。因此，从接收方对发送方的流量控制的角度考虑，发送方的发送窗口一定不能超过对方给出的接收窗口rwnd 发送方窗口的上限值 = Min [ rwnd, cwnd ] 当rwnd &lt; cwnd 时，是接收方的接收能力限制发送方窗口的最大值。 当cwnd &lt; rwnd 时，则是网络的拥塞限制发送方窗口的最大值。]]></content>
      <tags>
        <tag>转载</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字节对齐]]></title>
    <url>%2F2018%2F06%2F24%2FC%E5%92%8CC%2B%2B%2F%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%2F</url>
    <content type="text"><![CDATA[C语言的数据对齐什么是数据对齐？为什么要数据对齐？ 如果一个变量的地址是该变量的长度的整数倍的话，则数据对齐。数据对齐的好处是可以加快CPU读取数据的速度。比如x86的CPU的数据读取有三种方式： 按字节读取 按半字读取 按字读取 如果地址是对齐的，那么CPU会寻找最佳的数据读取方式，可以一次就完成数据的读取。如果地址不是对齐的，那么可能需要分几个步骤才能读完。 例子 123456struct stu&#123; char sex; int length; char name[10]; &#125;; struct stu my_stu; 一般编译器都会进行数据对齐操作，gcc默认是4字节对齐，结构体的数据对齐有两点： 使每个结构成员数据对齐 使结构体整体数据对齐 这样可以知道： char sex –&gt; 4字节int length –&gt; 4字节char name[10] –&gt; 10字节 为了对齐结构体，因此还需要在结构体后面补两个字节，从而实现对齐。即结构体总共占用4+4+10+2 = 20字节]]></content>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP拥塞控制]]></title>
    <url>%2F2018%2F06%2F23%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2Ftcp-congestion%2F</url>
    <content type="text"><![CDATA[​ 转载自网络 来源：网络拥塞控制(三) TCP拥塞控制算法 作者：海阔天空 为了防止网络的拥塞现象，TCP提出了一系列的拥塞控制机制。最初由V. Jacobson在1988年的论文中提出的TCP的拥塞控制由“慢启动(Slow start)”和“拥塞避免(Congestion avoidance)”组成，后来TCP Reno版本中又针对性的加入了“快速重传(Fast retransmit)”、“快速恢复(Fast Recovery)”算法，再后来在TCP NewReno中又对“快速恢复”算法进行了改进，近些年又出现了选择性应答( selective acknowledgement,SACK)算法，还有其他方面的大大小小的改进，成为网络研究的一个热点。 TCP的拥塞控制主要原理依赖于一个拥塞窗口(cwnd)来控制，在之前我们还讨论过TCP还有一个对端通告的接收窗口(rwnd)用于流量控制。窗口值的大小就代表能够发送出去的但还没有收到ACK的最大数据报文段，显然窗口越大那么数据发送的速度也就越快，但是也有越可能使得网络出现拥塞，如果窗口值为1，那么就简化为一个停等协议，每发送一个数据，都要等到对方的确认才能发送第二个数据包，显然数据传输效率低下。TCP的拥塞控制算法就是要在这两者之间权衡，选取最好的cwnd值，从而使得网络吞吐量最大化且不产生拥塞。 由于需要考虑拥塞控制和流量控制两个方面的内容，因此TCP的真正的发送窗口=min(rwnd, cwnd)。但是rwnd是由对端确定的，网络环境对其没有影响，所以在考虑拥塞的时候我们一般不考虑rwnd的值，我们暂时只讨论如何确定cwnd值的大小。关于cwnd的单位，在TCP中是以字节来做单位的，我们假设TCP每次传输都是按照MSS大小来发送数据的，因此你可以认为cwnd按照数据包个数来做单位也可以理解，所以有时我们说cwnd增加1也就是相当于字节数增加1个MSS大小。 慢启动：最初的TCP在连接建立成功后会向网络中发送大量的数据包，这样很容易导致网络中路由器缓存空间耗尽，从而发生拥塞。因此新建立的连接不能够一开始就大量发送数据包，而只能根据网络情况逐步增加每次发送的数据量，以避免上述现象的发生。具体来说，当新建连接时，cwnd初始化为1个最大报文段(MSS)大小，发送端开始按照拥塞窗口大小发送数据，每当有一个报文段被确认，cwnd就增加1个MSS大小。这样cwnd的值就随着网络往返时间(Round Trip Time,RTT)呈指数级增长，事实上，慢启动的速度一点也不慢，只是它的起点比较低一点而已。我们可以简单计算下： 开始 —&gt; cwnd = 1 经过1个RTT后 —&gt; cwnd = 2*1 = 2 经过2个RTT后 —&gt; cwnd = 2*2= 4 经过3个RTT后 —&gt; cwnd = 4*2 = 8 如果带宽为W，那么经过RTT*log2W时间就可以占满带宽。 拥塞避免：从慢启动可以看到，cwnd可以很快的增长上来，从而最大程度利用网络带宽资源，但是cwnd不能一直这样无限增长下去，一定需要某个限制。TCP使用了一个叫慢启动门限(ssthresh)的变量，当cwnd超过该值后，慢启动过程结束，进入拥塞避免阶段。对于大多数TCP实现来说，ssthresh的值是65536(同样以字节计算)。拥塞避免的主要思想是加法增大，也就是cwnd的值不再指数级往上升，开始加法增加。此时当窗口中所有的报文段都被确认时，cwnd的大小加1，cwnd的值就随着RTT开始线性增加，这样就可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。 上面讨论的两个机制都是没有检测到拥塞的情况下的行为，那么当发现拥塞了cwnd又该怎样去调整呢？ 首先来看TCP是如何确定网络进入了拥塞状态的，TCP认为网络拥塞的主要依据是它重传了一个报文段。上面提到过，TCP对每一个报文段都有一个定时器，称为重传定时器(RTO)，当RTO超时且还没有得到数据确认，那么TCP就会对该报文段进行重传，当发生超时时，那么出现拥塞的可能性就很大，某个报文段可能在网络中某处丢失，并且后续的报文段也没有了消息，在这种情况下，TCP反应比较“强烈”： 1.把ssthresh降低为cwnd值的一半 2.把cwnd重新设置为1 3.重新进入慢启动过程。 从整体上来讲，TCP拥塞控制窗口变化的原则是AIMD原则，即加法增大、乘法减小。可以看出TCP的该原则可以较好地保证流之间的公平性，因为一旦出现丢包，那么立即减半退避，可以给其他新建的流留有足够的空间，从而保证整个的公平性。 其实TCP还有一种情况会进行重传：那就是收到3个相同的ACK。TCP在收到乱序到达包时就会立即发送ACK，TCP利用3个相同的ACK来判定数据包的丢失，此时进行快速重传，快速重传做的事情有： 1.把ssthresh设置为cwnd的一半 2.把cwnd再设置为ssthresh的值(具体实现有些为ssthresh+3) 3.重新进入拥塞避免阶段。 后来的“快速恢复”算法是在上述的“快速重传”算法后添加的，当收到3个重复ACK时，TCP最后进入的不是拥塞避免阶段，而是快速恢复阶段。快速重传和快速恢复算法一般同时使用。快速恢复的思想是“数据包守恒”原则，即同一个时刻在网络中的数据包数量是恒定的，只有当“老”数据包离开了网络后，才能向网络中发送一个“新”的数据包，如果发送方收到一个重复的ACK，那么根据TCP的ACK机制就表明有一个数据包离开了网络，于是cwnd加1。如果能够严格按照该原则那么网络中很少会发生拥塞，事实上拥塞控制的目的也就在修正违反该原则的地方。 具体来说快速恢复的主要步骤是： 1.当收到3个重复ACK时，把ssthresh设置为cwnd的一半，把cwnd设置为ssthresh的值加3，然后重传丢失的报文段，加3的原因是因为收到3个重复的ACK，表明有3个“老”的数据包离开了网络。 2.再收到重复的ACK时，拥塞窗口增加1。 3.当收到新的数据包的ACK时，把cwnd设置为第一步中的ssthresh的值。原因是因为该ACK确认了新的数据，说明从重复ACK时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态。 快速重传算法首次出现在4.3BSD的Tahoe版本，快速恢复首次出现在4.3BSD的Reno版本，也称之为Reno版的TCP拥塞控制算法。 可以看出Reno的快速重传算法是针对一个包的重传情况的，然而在实际中，一个重传超时可能导致许多的数据包的重传，因此当多个数据包从一个数据窗口中丢失时并且触发快速重传和快速恢复算法时，问题就产生了。因此NewReno出现了，它在Reno快速恢复的基础上稍加了修改，可以恢复一个窗口内多个包丢失的情况。具体来讲就是：Reno在收到一个新的数据的ACK时就退出了快速恢复状态了，而NewReno需要收到该窗口内所有数据包的确认后才会退出快速恢复状态，从而更一步提高吞吐量。 SACK就是改变TCP的确认机制，最初的TCP只确认当前已连续收到的数据，SACK则把乱序等信息会全部告诉对方，从而减少数据发送方重传的盲目性。比如说序号1，2，3，5，7的数据收到了，那么普通的ACK只会确认序列号4，而SACK会把当前的5，7已经收到的信息在SACK选项里面告知对端，从而提高性能，当使用SACK的时候，NewReno算法可以不使用，因为SACK本身携带的信息就可以使得发送方有足够的信息来知道需要重传哪些包，而不需要重传哪些包。 以上方面资料可以参考V. Jacobson的论文，RFC2001、RFC2018、RFC2581、RFC2582、RFC2883等文献。 下一节：TCP拥塞控制的其他方面]]></content>
      <tags>
        <tag>转载</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP的那些事儿（下）]]></title>
    <url>%2F2018%2F06%2F23%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2Ftcp-meaning-2%2F</url>
    <content type="text"><![CDATA[转载自网络 来源：CoolShell 作者：陈皓 这篇文章是下篇，所以如果你对TCP不熟悉的话，还请你先看看上篇《TCP的那些事儿（上）》 上篇中，我们介绍了TCP的协议头、状态机、数据重传中的东西。但是TCP要解决一个很大的事，那就是要在一个网络根据不同的情况来动态调整自己的发包的速度，小则让自己的连接更稳定，大则让整个网络更稳定。在你阅读下篇之前，你需要做好准备，本篇文章有好些算法和策略，可能会引发你的各种思考，让你的大脑分配很多内存和计算资源，所以，不适合在厕所中阅读。 TCP的RTT算法从前面的TCP重传机制我们知道Timeout的设置对于重传非常重要。 设长了，重发就慢，丢了老半天才重发，没有效率，性能差； 设短了，会导致可能并没有丢就重发。于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。 而且，这个超时时间在不同的网络的情况下，根本没有办法设置一个死的值。只能动态地设置。 为了动态地设置，TCP引入了RTT——Round Trip Time，也就是一个数据包从发出去到回来的时间。这样发送端就大约知道需要多少的时间，从而可以方便地设置Timeout——RTO（Retransmission TimeOut），以让我们的重传机制更高效。 听起来似乎很简单，好像就是在发送端发包时记下t0，然后接收端再把这个ack回来时再记一个t1，于是RTT = t1 – t0。没那么简单，这只是一个采样，不能代表普遍情况。 经典算法RFC793 中定义的经典算法是这样的： 1）首先，先采样RTT，记下最近好几次的RTT值。 2）然后做平滑计算SRTT（ Smoothed RTT）。公式为：（其中的 α 取值在0.8 到 0.9之间，这个算法英文叫Exponential weighted moving average，中文叫：加权移动平均） SRTT = ( α * SRTT ) + ((1- α) * RTT) 3）开始计算RTO。公式如下： RTO = min [ UBOUND, max [ LBOUND, (β * SRTT) ] ] 其中： UBOUND是最大的timeout时间，上限值 LBOUND是最小的timeout时间，下限值 β 值一般在1.3到2.0之间。 Karn / Partridge 算法但是上面的这个算法在重传的时候会出有一个终极问题——你是用第一次发数据的时间和ack回来的时间做RTT样本值，还是用重传的时间和ACK回来的时间做RTT样本值？ 这个问题无论你选那头都是按下葫芦起了瓢。 如下图所示： 情况（a）是ack没回来，所以重传。如果你计算第一次发送和ACK的时间，那么，明显算大了。 情况（b）是ack回来慢了，但是导致了重传，但刚重传不一会儿，之前ACK就回来了。如果你是算重传的时间和ACK回来的时间的差，就会算短了。 所以1987年的时候，搞了一个叫Karn / Partridge Algorithm，这个算法的最大特点是——忽略重传，不把重传的RTT做采样（你看，你不需要去解决不存在的问题）。 但是，这样一来，又会引发一个大BUG——如果在某一时间，网络闪动，突然变慢了，产生了比较大的延时，这个延时导致要重转所有的包（因为之前的RTO很小），于是，因为重转的不算，所以，RTO就不会被更新，这是一个灾难。 于是Karn算法用了一个取巧的方式——只要一发生重传，就对现有的RTO值翻倍（这就是所谓的 Exponential backoff），很明显，这种死规矩对于一个需要估计比较准确的RTT也不靠谱。 Jacobson / Karels 算法前面两种算法用的都是“加权移动平均”，这种方法最大的毛病就是如果RTT有一个大的波动的话，很难被发现，因为被平滑掉了。所以，1988年，又有人推出来了一个新的算法，这个算法叫Jacobson / Karels Algorithm（参看RFC6289）。这个算法引入了最新的RTT的采样和平滑过的SRTT的差距做因子来计算。 公式如下：（其中的DevRTT是Deviation RTT的意思） SRTT** = SRTT + α (RTT – SRTT) **—— 计算平滑RTT DevRTT** = (1-β)*DevRTT + β*(|RTT-SRTT|) **——计算平滑RTT和真实的差距（加权移动平均） RTO= µ * SRTT + ∂ *DevRTT —— 神一样的公式 （其中：在Linux下，α = 0.125，β = 0.25， μ = 1，∂ = 4 ——这就是算法中的“调得一手好参数”，nobody knows why, it just works…） 最后的这个算法在被用在今天的TCP协议中（Linux的源代码在：tcp_rtt_estimator）。 TCP滑动窗口需要说明一下，如果你不了解TCP的滑动窗口这个事，你等于不了解TCP协议。我们都知道，TCP必需要解决的可靠传输以及包乱序（reordering）的问题，所以，TCP必需要知道网络实际的数据处理带宽或是数据处理速度，这样才不会引起网络拥塞，导致丢包。 所以，TCP引入了一些技术和设计来做网络流控，Sliding Window是其中一个技术。 前面我们说过，TCP头里有一个字段叫Window，又叫Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。 为了说明滑动窗口，我们需要先看一下TCP缓冲区的一些数据结构： 上图中，我们可以看到： 接收端LastByteRead指向了TCP缓冲区中读到的位置，NextByteExpected指向的地方是收到的连续包的最后一个位置，LastByteRcved指向的是收到的包的最后一个位置，我们可以看到中间有些数据还没有到达，所以有数据空白区。 发送端的LastByteAcked指向了被接收端Ack过的位置（表示成功发送确认），LastByteSent表示发出去了，但还没有收到成功确认的Ack，LastByteWritten指向的是上层应用正在写的地方。 于是： 接收端在给发送端回ACK中会汇报自己的AdvertisedWindow = MaxRcvBuffer – LastByteRcvd – 1; 而发送方会根据这个窗口来控制发送数据的大小，以保证接收方可以处理。 下面我们来看一下发送方的滑动窗口示意图： （图片来源） 上图中分成了四个部分，分别是：（其中那个黑模型就是滑动窗口） #1已收到ack确认的数据。 #2发还没收到ack的。 #3在窗口中还没有发出的（接收方还有空间）。 #4窗口以外的数据（接收方没空间） 下面是个滑动后的示意图（收到36的ack，并发出了46-51的字节）： 下面我们来看一个接受端控制发送端的图示： （图片来源） Zero Window上图，我们可以看到一个处理缓慢的Server（接收端）是怎么把Client（发送端）的TCP Sliding Window给降成0的。此时，你一定会问，如果Window变成0了，TCP会怎么样？是不是发送端就不发数据了？是的，发送端就不发数据了，你可以想像成“Window Closed”，那你一定还会问，如果发送端不发数据了，接收方一会儿Window size 可用了，怎么通知发送端呢？ 解决这个问题，TCP使用了Zero Window Probe技术，缩写为ZWP，也就是说，发送端在窗口变成0后，会发ZWP的包给接收方，让接收方来ack他的Window尺寸，一般这个值会设置成3次，第次大约30-60秒（不同的实现可能会不一样）。如果3次过后还是0的话，有的TCP实现就会发RST把链接断了。 注意：只要有等待的地方都可能出现DDoS攻击，Zero Window也不例外，一些攻击者会在和HTTP建好链发完GET请求后，就把Window设置为0，然后服务端就只能等待进行ZWP，于是攻击者会并发大量的这样的请求，把服务器端的资源耗尽。（关于这方面的攻击，大家可以移步看一下Wikipedia的SockStress词条） 另外，Wireshark中，你可以使用tcp.analysis.zero_window来过滤包，然后使用右键菜单里的follow TCP stream，你可以看到ZeroWindowProbe及ZeroWindowProbeAck的包。 Silly Window SyndromeSilly Window Syndrome翻译成中文就是“糊涂窗口综合症”。正如你上面看到的一样，如果我们的接收方太忙了，来不及取走Receive Windows里的数据，那么，就会导致发送方越来越小。到最后，如果接收方腾出几个字节并告诉发送方现在有几个字节的window，而我们的发送方会义无反顾地发送这几个字节。 要知道，我们的TCP+IP头有40个字节，为了几个字节，要达上这么大的开销，这太不经济了。 另外，你需要知道网络上有个MTU，对于以太网来说，MTU是1500字节，除去TCP+IP头的40个字节，真正的数据传输可以有1460，这就是所谓的MSS（Max Segment Size）注意，TCP的RFC定义这个MSS的默认值是536，这是因为 RFC 791里说了任何一个IP设备都得最少接收576尺寸的大小（实际上来说576是拨号的网络的MTU，而576减去IP头的20个字节就是536）。 如果你的网络包可以塞满MTU，那么你可以用满整个带宽，如果不能，那么你就会浪费带宽。（大于MTU的包有两种结局，一种是直接被丢了，另一种是会被重新分块打包发送） 你可以想像成一个MTU就相当于一个飞机的最多可以装的人，如果这飞机里满载的话，带宽最高，如果一个飞机只运一个人的话，无疑成本增加了，也而相当二。 所以，Silly Windows Syndrome这个现像就像是你本来可以坐200人的飞机里只做了一两个人。 要解决这个问题也不难，就是避免对小的window size做出响应，直到有足够大的window size再响应，这个思路可以同时实现在sender和receiver两端。 如果这个问题是由Receiver端引起的，那么就会使用 David D Clark’s 方案。在receiver端，如果收到的数据导致window size小于某个值，可以直接ack(0)回sender，这样就把window给关闭了，也阻止了sender再发数据过来，等到receiver端处理了一些数据后windows size 大于等于了MSS，或者，receiver buffer有一半为空，就可以把window打开让send 发送数据过来。 如果这个问题是由Sender端引起的，那么就会使用著名的 Nagle’s algorithm。这个算法的思路也是延时处理，他有两个主要的条件：1）要等到 Window Size&gt;=MSS 或是 Data Size &gt;=MSS，2）收到之前发送数据的ack回包，他才会发数据，否则就是在攒数据。 另外，Nagle算法默认是打开的，所以，对于一些需要小包场景的程序——比如像telnet或ssh这样的交互性比较强的程序，你需要关闭这个算法。你可以在Socket设置TCP_NODELAY选项来关闭这个算法（关闭Nagle算法没有全局参数，需要根据每个应用自己的特点来关闭） 另外，网上有些文章说TCP_CORK的socket option是也关闭Nagle算法，这不对。TCP_CORK其实是更新激进的Nagle算汉，完全禁止小包发送，而Nagle算法没有禁止小包发送，只是禁止了大量的小包发送。最好不要两个选项都设置。 TCP的拥塞处理 – Congestion Handling上面我们知道了，TCP通过Sliding Window来做流控（Flow Control），但是TCP觉得这还不够，因为Sliding Window需要依赖于连接的发送端和接收端，其并不知道网络中间发生了什么。TCP的设计者觉得，一个伟大而牛逼的协议仅仅做到流控并不够，因为流控只是网络模型4层以上的事，TCP的还应该更聪明地知道整个网络上的事。 具体一点，我们知道TCP通过一个timer采样了RTT并计算RTO，但是，如果网络上的延时突然增加，那么，TCP对这个事做出的应对只有重传数据，但是，重传会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，于是，这个情况就会进入恶性循环被不断地放大。试想一下，如果一个网络内有成千上万的TCP连接都这么行事，那么马上就会形成“网络风暴”，TCP这个协议就会拖垮整个网络。这是一个灾难。 所以，TCP不能忽略网络上发生的事情，而无脑地一个劲地重发数据，对网络造成更大的伤害。对此TCP的设计理念是：TCP不是一个自私的协议，当拥塞发生的时候，要做自我牺牲。就像交通阻塞一样，每个车都应该把路让出来，而不要再去抢路了。 关于拥塞控制的论文请参看《Congestion Avoidance and Control》(PDF) 拥塞控制主要是四个算法：1）慢启动，2）拥塞避免，3）拥塞发生，4）快速恢复。这四个算法不是一天都搞出来的，这个四算法的发展经历了很多时间，到今天都还在优化中。 备注: 1988年，TCP-Tahoe 提出了1）慢启动，2）拥塞避免，3）拥塞发生时的快速重传 1990年，TCP Reno 在Tahoe的基础上增加了4）快速恢复 慢热启动算法 – Slow Start首先，我们来看一下TCP的慢热启动。慢启动的意思是，刚刚加入网络的连接，一点一点地提速，不要一上来就像那些特权车一样霸道地把路占满。新同学上高速还是要慢一点，不要把已经在高速上的秩序给搞乱了。 慢启动的算法如下(cwnd全称Congestion Window)： 1）连接建好的开始先初始化cwnd = 1，表明可以传一个MSS大小的数据。 2）每当收到一个ACK，cwnd++; 呈线性上升 3）每当过了一个RTT，cwnd = cwnd*2; 呈指数让升 4）还有一个ssthresh（slow start threshold），是一个上限，当cwnd &gt;= ssthresh时，就会进入“拥塞避免算法”（后面会说这个算法） 所以，我们可以看到，如果网速很快的话，ACK也会返回得快，RTT也会短，那么，这个慢启动就一点也不慢。下图说明了这个过程。 这里，我需要提一下的是一篇Google的论文《An Argument for Increasing TCP’s Initial Congestion Window》Linux 3.0后采用了这篇论文的建议——把cwnd 初始化成了 10个MSS。 而Linux 3.0以前，比如2.6，Linux采用了RFC3390，cwnd是跟MSS的值来变的，如果MSS&lt; 1095，则cwnd = 4；如果MSS&gt;2190，则cwnd=2；其它情况下，则是3。 拥塞避免算法 – Congestion Avoidance前面说过，还有一个ssthresh（slow start threshold），是一个上限，当cwnd &gt;= ssthresh时，就会进入“拥塞避免算法”。一般来说ssthresh的值是65535，单位是字节，当cwnd达到这个值时后，算法如下： 1）收到一个ACK时，cwnd = cwnd + 1/cwnd 2）当每过一个RTT时，cwnd = cwnd + 1 这样就可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。很明显，是一个线性上升的算法。 拥塞状态时的算法前面我们说过，当丢包的时候，会有两种情况： 1）等到RTO超时，重传数据包。TCP认为这种情况太糟糕，反应也很强烈。 sshthresh = cwnd /2 cwnd 重置为 1 进入慢启动过程 2）Fast Retransmit算法，也就是在收到3个duplicate ACK时就开启重传，而不用等到RTO超时。 TCP Tahoe的实现和RTO超时一样。 TCP Reno的实现是： cwnd = cwnd /2 sshthresh = cwnd 进入快速恢复算法——Fast Recovery 上面我们可以看到RTO超时后，sshthresh会变成cwnd的一半，这意味着，如果cwnd&lt;=sshthresh时出现的丢包，那么TCP的sshthresh就会减了一半，然后等cwnd又很快地以指数级增涨爬到这个地方时，就会成慢慢的线性增涨。我们可以看到，TCP是怎么通过这种强烈地震荡快速而小心得找到网站流量的平衡点的。 快速恢复算法 – Fast RecoveryTCP Reno 这个算法定义在RFC5681。快速重传和快速恢复算法一般同时使用。快速恢复算法是认为，你还有3个Duplicated Acks说明网络也不那么糟糕，所以没有必要像RTO超时那么强烈。 注意，正如前面所说，进入Fast Recovery之前，cwnd 和 sshthresh已被更新： cwnd = cwnd /2 sshthresh = cwnd 然后，真正的Fast Recovery算法如下： cwnd = sshthresh + 3 * MSS （3的意思是确认有3个数据包被收到了） 重传Duplicated ACKs指定的数据包 如果再收到 duplicated Acks，那么cwnd = cwnd +1 如果收到了新的Ack，那么，cwnd = sshthresh ，然后就进入了拥塞避免的算法了。 如果你仔细思考一下上面的这个算法，你就会知道，上面这个算法也有问题，那就是——它依赖于3个重复的Acks。注意，3个重复的Acks并不代表只丢了一个数据包，很有可能是丢了好多包。但这个算法只会重传一个，而剩下的那些包只能等到RTO超时，于是，进入了恶梦模式——超时一个窗口就减半一下，多个超时会超成TCP的传输速度呈级数下降，而且也不会触发Fast Recovery算法了。 通常来说，正如我们前面所说的，SACK或D-SACK的方法可以让Fast Recovery或Sender在做决定时更聪明一些，但是并不是所有的TCP的实现都支持SACK（SACK需要两端都支持），所以，需要一个没有SACK的解决方案。而通过SACK进行拥塞控制的算法是FACK（后面会讲） TCP New Reno 于是，1995年，TCP New Reno（参见 RFC 6582 ）算法提出来，主要就是在没有SACK的支持下改进Fast Recovery算法的—— 当sender这边收到了3个Duplicated Acks，进入Fast Retransimit模式，开发重传重复Acks指示的那个包。如果只有这一个包丢了，那么，重传这个包后回来的Ack会把整个已经被sender传输出去的数据ack回来。如果没有的话，说明有多个包丢了。我们叫这个ACK为Partial ACK。 一旦Sender这边发现了Partial ACK出现，那么，sender就可以推理出来有多个包被丢了，于是乎继续重传sliding window里未被ack的第一个包。直到再也收不到了Partial Ack，才真正结束Fast Recovery这个过程 我们可以看到，这个“Fast Recovery的变更”是一个非常激进的玩法，他同时延长了Fast Retransmit和Fast Recovery的过程。 算法示意图下面我们来看一个简单的图示以同时看一下上面的各种算法的样子： FACK算法FACK全称Forward Acknowledgment 算法，论文地址在这里（PDF）Forward Acknowledgement: Refining TCP Congestion Control 这个算法是其于SACK的，前面我们说过SACK是使用了TCP扩展字段Ack了有哪些数据收到，哪些数据没有收到，他比Fast Retransmit的3 个duplicated acks好处在于，前者只知道有包丢了，不知道是一个还是多个，而SACK可以准确的知道有哪些包丢了。 所以，SACK可以让发送端这边在重传过程中，把那些丢掉的包重传，而不是一个一个的传，但这样的一来，如果重传的包数据比较多的话，又会导致本来就很忙的网络就更忙了。所以，FACK用来做重传过程中的拥塞流控。 这个算法会把SACK中最大的Sequence Number 保存在snd.fack这个变量中，snd.fack的更新由ack带秋，如果网络一切安好则和snd.una一样（snd.una就是还没有收到ack的地方，也就是前面sliding window里的category #2的第一个地方） 然后定义一个awnd = snd.nxt – snd.fack（snd.nxt指向发送端sliding window中正在要被发送的地方——前面sliding windows图示的category#3第一个位置），这样awnd的意思就是在网络上的数据。（所谓awnd意为：actual quantity of data outstanding in the network） 如果需要重传数据，那么，awnd = snd.nxt – snd.fack + retran_data，也就是说，awnd是传出去的数据 + 重传的数据。 然后触发Fast Recovery 的条件是： ( ( snd.fack – snd.una ) &gt; (3*MSS) ) || (dupacks == 3) ) 。这样一来，就不需要等到3个duplicated acks才重传，而是只要sack中的最大的一个数据和ack的数据比较长了（3个MSS），那就触发重传。在整个重传过程中cwnd不变。直到当第一次丢包的snd.nxt&lt;=snd.una（也就是重传的数据都被确认了），然后进来拥塞避免机制——cwnd线性上涨。 我们可以看到如果没有FACK在，那么在丢包比较多的情况下，原来保守的算法会低估了需要使用的window的大小，而需要几个RTT的时间才会完成恢复，而FACK会比较激进地来干这事。 但是，FACK如果在一个网络包会被 reordering的网络里会有很大的问题。 其它拥塞控制算法简介TCP Vegas 拥塞控制算法这个算法1994年被提出，它主要对TCP Reno 做了些修改。这个算法通过对RTT的非常重的监控来计算一个基准RTT。然后通过这个基准RTT来估计当前的网络实际带宽，如果实际带宽比我们的期望的带宽要小或是要多的活，那么就开始线性地减少或增加cwnd的大小。如果这个计算出来的RTT大于了Timeout后，那么，不等ack超时就直接重传。（Vegas 的核心思想是用RTT的值来影响拥塞窗口，而不是通过丢包） 这个算法的论文是《TCP Vegas: End to End Congestion Avoidance on a Global Internet》这篇论文给了Vegas和 New Reno的对比： 关于这个算法实现，你可以参看Linux源码：/net/ipv4/tcp_vegas.h， /net/ipv4/tcp_vegas.c ##### HSTCP(High Speed TCP) 算法这个算法来自RFC 3649（Wikipedia词条）。其对最基础的算法进行了更改，他使得Congestion Window涨得快，减得慢。其中： 拥塞避免时的窗口增长方式： cwnd = cwnd + α(cwnd) / cwnd 丢包后窗口下降方式：cwnd = (1- β(cwnd))*cwnd 注：α(cwnd)和β(cwnd)都是函数，如果你要让他们和标准的TCP一样，那么让α(cwnd)=1，β(cwnd)=0.5就可以了。 对于α(cwnd)和β(cwnd)的值是个动态的变换的东西。 关于这个算法的实现，你可以参看Linux源码：/net/ipv4/tcp_highspeed.c TCP BIC 算法2004年，产内出BIC算法。现在你还可以查得到相关的新闻《Google：美科学家研发BIC-TCP协议 速度是DSL六千倍》 BIC全称Binary Increase Congestion control，在Linux 2.6.8中是默认拥塞控制算法。BIC的发明者发这么多的拥塞控制算法都在努力找一个合适的cwnd – Congestion Window，而且BIC-TCP的提出者们看穿了事情的本质，其实这就是一个搜索的过程，所以BIC这个算法主要用的是Binary Search——二分查找来干这个事。 关于这个算法实现，你可以参看Linux源码：/net/ipv4/tcp_bic.c TCP WestWood算法westwood采用和Reno相同的慢启动算法、拥塞避免算法。westwood的主要改进方面：在发送端做带宽估计，当探测到丢包时，根据带宽值来设置拥塞窗口、慢启动阈值。 那么，这个算法是怎么测量带宽的？每个RTT时间，会测量一次带宽，测量带宽的公式很简单，就是这段RTT内成功被ack了多少字节。因为，这个带宽和用RTT计算RTO一样，也是需要从每个样本来平滑到一个值的——也是用一个加权移平均的公式。 另外，我们知道，如果一个网络的带宽是每秒可以发送X个字节，而RTT是一个数据发出去后确认需要的时候，所以，X RTT应该是我们缓冲区大小。所以，在这个算法中，ssthresh的值就是est_BD min-RTT(最小的RTT值)，如果丢包是Duplicated ACKs引起的，那么如果cwnd &gt; ssthresh，则 cwin = ssthresh。如果是RTO引起的，cwnd = 1，进入慢启动。 关于这个算法实现，你可以参看Linux源码： /net/ipv4/tcp_westwood.c 其它更多的算法，你可以从Wikipedia的 TCP Congestion Avoidance Algorithm 词条中找到相关的线索 后记好了，到这里我想可以结束了，TCP发展到今天，里面的东西可以写上好几本书。本文主要目的，还是把你带入这些古典的基础技术和知识中，希望本文能让你了解TCP，更希望本文能让你开始有学习这些基础或底层知识的兴趣和信心。 当然，TCP东西太多了，不同的人可能有不同的理解，而且本文可能也会有一些荒谬之言甚至错误，还希望得到您的反馈和批评。 （全文完）]]></content>
      <tags>
        <tag>转载</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP 的那些事儿（上）]]></title>
    <url>%2F2018%2F06%2F22%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2Ftcp-meaning-1%2F</url>
    <content type="text"><![CDATA[转载自网络 来源：CoolShell 作者：陈皓 TCP头格式 TCP的状态机 数据传输中的Sequence Number TCP重传机制 超时重传机制 快速重传机制 SACK 方法 Duplicate SACK – 重复收到数据的问题 TCP是一个巨复杂的协议，因为他要解决很多问题，而这些问题又带出了很多子问题和阴暗面。所以学习TCP本身是个比较痛苦的过程，但对于学习的过程却能让人有很多收获。关于TCP这个协议的细节，我还是推荐你去看W.Richard Stevens的《TCP/IP 详解 卷1：协议》（当然，你也可以去读一下RFC793以及后面N多的RFC）。另外，本文我会使用英文术语，这样方便你通过这些英文关键词来查找相关的技术文档。 之所以想写这篇文章，目的有三个， 一个是想锻炼一下自己是否可以用简单的篇幅把这么复杂的TCP协议描清楚的能力。 另一个是觉得现在的好多程序员基本上不会认认真真地读本书，喜欢快餐文化，所以，希望这篇快餐文章可以让你对TCP这个古典技术有所了解，并能体会到软件设计中的种种难处。并且你可以从中有一些软件设计上的收获。 最重要的希望这些基础知识可以让你搞清很多以前一些似是而非的东西，并且你能意识到基础的重要。 所以，本文不会面面俱到，只是对TCP协议、算法和原理的科普。 我本来只想写一个篇幅的文章的，但是TCP真TMD的复杂，比C++复杂多了，这30多年来，各种优化变种争论和修改。所以，写着写着就发现只有砍成两篇。 上篇中，主要向你介绍TCP协议的定义和丢包时的重传机制。 下篇中，重点介绍TCP的流迭、拥塞处理。 废话少说，首先，我们需要知道TCP在网络OSI的七层模型中的第四层——Transport层，IP在第三层——Network层，ARP在第二层——Data Link层，在第二层上的数据，我们叫Frame，在第三层上的数据叫Packet，第四层的数据叫Segment。 首先，我们需要知道，我们程序的数据首先会打到TCP的Segment中，然后TCP的Segment会打到IP的Packet中，然后再打到以太网Ethernet的Frame中，传到对端后，各个层解析自己的协议，然后把数据交给更高层的协议处理。 TCP头格式接下来，我们来看一下TCP头的格式 TCP头格式（图片来源） 你需要注意这么几点： TCP的包是没有IP地址的，那是IP层上的事。但是有源端口和目标端口。 一个TCP连接需要四个元组来表示是同一个连接（src_ip, src_port, dst_ip, dst_port）准确说是五元组，还有一个是协议。但因为这里只是说TCP协议，所以，这里我只说四元组。 注意上图中的四个非常重要的东西： Sequence Number是包的序号，用来解决网络包乱序（reordering）问题。 Acknowledgement Number就是ACK——用于确认收到，用来解决不丢包的问题。 Window又叫Advertised-Window，也就是著名的滑动窗口（Sliding Window），用于解决流控的。 TCP Flag ，也就是包的类型，主要是用于操控TCP的状态机的。 关于其它的东西，可以参看下面的图示 （图片来源） TCP的状态机其实，网络上的传输是没有连接的，包括TCP也是一样的。而TCP所谓的“连接”，其实只不过是在通讯的双方维护一个“连接状态”，让它看上去好像有连接一样。所以，TCP的状态变换是非常重要的。 下面是：“TCP协议的状态机”（图片来源） 和 “TCP建链接”、“TCP断链接”、“传数据” 的对照图，我把两个图并排放在一起，这样方便在你对照着看。另外，下面这两个图非常非常的重要，你一定要记牢。（吐个槽：看到这样复杂的状态机，就知道这个协议有多复杂，复杂的东西总是有很多坑爹的事情，所以TCP协议其实也挺坑爹的） 很多人会问，为什么建链接要3次握手，断链接需要4次挥手？ 对于建链接的3次握手，主要是要初始化Sequence Number 的初始值。通信的双方要互相通知对方自己的初始化的Sequence Number（缩写为ISN：Inital Sequence Number）——所以叫SYN，全称Synchronize Sequence Numbers。也就上图中的 x 和 y。这个号要作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输的问题而乱序（TCP会用这个序号来拼接数据）。 对于4次挥手，其实你仔细看是2次，因为TCP是全双工的，所以，发送方和接收方都需要Fin和Ack。只不过，有一方是被动的，所以看上去就成了所谓的4次挥手。如果两边同时断连接，那就会就进入到CLOSING状态，然后到达TIME_WAIT状态。下图是双方同时断连接的示意图（你同样可以对照着TCP状态机看）： 两端同时断连接（图片来源） 另外，有几个事情需要注意一下： 关于建连接时SYN超时。试想一下，如果server端接到了clien发的SYN后回了SYN-ACK后client掉线了，server端没有收到client回来的ACK，那么，这个连接处于一个中间状态，即没成功，也没失败。于是，server端如果在一定时间内没有收到的TCP会重发SYN-ACK。在Linux下，默认重试次数为5次，重试的间隔时间从1s开始每次都翻售，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s，总共31s，第5次发出后还要等32s都知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 2^6 -1 = 63s，TCP才会把断开这个连接。 关于SYN Flood攻击。一些恶意的人就为此制造了SYN Flood攻击——给服务器发了一个SYN后，就下线了，于是服务器需要默认等63s才会断开连接，这样，攻击者就可以把服务器的syn连接的队列耗尽，让正常的连接请求不能处理。于是，Linux下给了一个叫tcp_syncookies的参数来应对这个事——当SYN队列满了后，TCP会通过源地址端口、目标地址端口和时间戳打造出一个特别的Sequence Number发回去（又叫cookie），如果是攻击者则不会有响应，如果是正常连接，则会把这个 SYN Cookie发回来，然后服务端可以通过cookie建连接（即使你不在SYN队列中）。请注意，请先千万别用tcp_syncookies来处理正常的大负载的连接的情况。因为，synccookies是妥协版的TCP协议，并不严谨。对于正常的请求，你应该调整三个TCP参数可供你选择，第一个是：tcp_synack_retries 可以用他来减少重试次数；第二个是：tcp_max_syn_backlog，可以增大SYN连接数；第三个是：tcp_abort_on_overflow 处理不过来干脆就直接拒绝连接了。 关于ISN的初始化。ISN是不能hard code的，不然会出问题的——比如：如果连接建好后始终用1来做ISN，如果client发了30个segment过去，但是网络断了，于是 client重连，又用了1做ISN，但是之前连接的那些包到了，于是就被当成了新连接的包，此时，client的Sequence Number 可能是3，而Server端认为client端的这个号是30了。全乱了。RFC793中说，ISN会和一个假的时钟绑在一起，这个时钟会在每4微秒对ISN做加一操作，直到超过2^32，又从0开始。这样，一个ISN的周期大约是4.55个小时。因为，我们假设我们的TCP Segment在网络上的存活时间不会超过Maximum Segment Lifetime（缩写为MSL – Wikipedia语条），所以，只要MSL的值小于4.55小时，那么，我们就不会重用到ISN。 关于 MSL 和 TIME_WAIT。通过上面的ISN的描述，相信你也知道MSL是怎么来的了。我们注意到，在TCP的状态图中，从TIME_WAIT状态到CLOSED状态，有一个超时设置，这个超时设置是 2*MSL（RFC793定义了MSL为2分钟，Linux设置成了30s）为什么要这有TIME_WAIT？为什么不直接给转成CLOSED状态呢？主要有两个原因：1）TIME_WAIT确保有足够的时间让对端收到了ACK，如果被动关闭的那方没有收到Ack，就会触发被动端重发Fin，一来一去正好2个MSL，2）有足够的时间让这个连接不会跟后面的连接混在一起（你要知道，有些自做主张的路由器会缓存IP数据包，如果连接被重用了，那么这些延迟收到的包就有可能会跟新连接混在一起）。你可以看看这篇文章《TIME_WAIT and its design implications for protocols and scalable client server systems》 关于TIME_WAIT数量太多。从上面的描述我们可以知道，TIME_WAIT是个很重要的状态，但是如果在大并发的短链接下，TIME_WAIT 就会太多，这也会消耗很多系统资源。只要搜一下，你就会发现，十有八九的处理方式都是教你设置两个参数，一个叫tcp_tw_reuse，另一个叫tcp_tw_recycle的参数，这两个参数默认值都是被关闭的，后者recyle比前者resue更为激进，resue要温柔一些。另外，如果使用tcp_tw_reuse，必需设置tcp_timestamps=1，否则无效。这里，你一定要注意，打开这两个参数会有比较大的坑——可能会让TCP连接出一些诡异的问题（因为如上述一样，如果不等待超时重用连接的话，新的连接可能会建不上。正如官方文档上说的一样“It should not be changed without advice/request of technical experts”）。 关于tcp_tw_reuse。官方文档上说tcp_tw_reuse 加上tcp_timestamps（又叫PAWS, for Protection Against Wrapped Sequence Numbers）可以保证协议的角度上的安全，但是你需要tcp_timestamps在两边都被打开（你可以读一下tcp_twsk_unique的源码 ）。我个人估计还是有一些场景会有问题。 关于tcp_tw_recycle。如果是tcp_tw_recycle被打开了话，会假设对端开启了tcp_timestamps，然后会去比较时间戳，如果时间戳变大了，就可以重用。但是，如果对端是一个NAT网络的话（如：一个公司只用一个IP出公网）或是对端的IP被另一台重用了，这个事就复杂了。建链接的SYN可能就被直接丢掉了（你可能会看到connection time out的错误）（如果你想观摩一下Linux的内核代码，请参看源码 tcp_timewait_state_process）。 关于tcp_max_tw_buckets。这个是控制并发的TIME_WAIT的数量，默认值是180000，如果超限，那么，系统会把多的给destory掉，然后在日志里打一个警告（如：time wait bucket table overflow），官网文档说这个参数是用来对抗DDoS攻击的。也说的默认值180000并不小。这个还是需要根据实际情况考虑。 Again，使用tcp_tw_reuse和tcp_tw_recycle来解决TIME_WAIT的问题是非常非常危险的，因为这两个参数违反了TCP协议（RFC 1122） 其实，TIME_WAIT表示的是你主动断连接，所以，这就是所谓的“不作死不会死”。试想，如果让对端断连接，那么这个破问题就是对方的了，呵呵。另外，如果你的服务器是于HTTP服务器，那么设置一个HTTP的KeepAlive有多重要（浏览器会重用一个TCP连接来处理多个HTTP请求），然后让客户端去断链接（你要小心，浏览器可能会非常贪婪，他们不到万不得已不会主动断连接）。 数据传输中的Sequence Number下图是我从Wireshark中截了个我在访问coolshell.cn时的有数据传输的图给你看一下，SeqNum是怎么变的。（使用Wireshark菜单中的Statistics -&gt;Flow Graph… ） 你可以看到，SeqNum的增加是和传输的字节数相关的。上图中，三次握手后，来了两个Len:1440的包，而第二个包的SeqNum就成了1441。然后第一个ACK回的是1441，表示第一个1440收到了。 注意：如果你用Wireshark抓包程序看3次握手，你会发现SeqNum总是为0，不是这样的，Wireshark为了显示更友好，使用了Relative SeqNum——相对序号，你只要在右键菜单中的protocol preference 中取消掉就可以看到“Absolute SeqNum”了 TCP重传机制TCP要保证所有的数据包都可以到达，所以，必需要有重传机制。 注意，接收端给发送端的Ack确认只会确认最后一个连续的包，比如，发送端发了1,2,3,4,5一共五份数据，接收端收到了1，2，于是回ack 3，然后收到了4（注意此时3没收到），此时的TCP会怎么办？我们要知道，因为正如前面所说的，SeqNum和Ack是以字节数为单位，所以ack的时候，不能跳着确认，只能确认最大的连续收到的包，不然，发送端就以为之前的都收到了。 超时重传机制一种是不回ack，死等3，当发送方发现收不到3的ack超时后，会重传3。一旦接收方收到3后，会ack 回 4——意味着3和4都收到了。 但是，这种方式会有比较严重的问题，那就是因为要死等3，所以会导致4和5即便已经收到了，而发送方也完全不知道发生了什么事，因为没有收到Ack，所以，发送方可能会悲观地认为也丢了，所以有可能也会导致4和5的重传。 对此有两种选择： 一种是仅重传timeout的包。也就是第3份数据。 另一种是重传timeout后所有的数据，也就是第3，4，5这三份数据。 这两种方式有好也有不好。第一种会节省带宽，但是慢，第二种会快一点，但是会浪费带宽，也可能会有无用功。但总体来说都不好。因为都在等timeout，timeout可能会很长（在下篇会说TCP是怎么动态地计算出timeout的） 快速重传机制于是，TCP引入了一种叫Fast Retransmit 的算法，不以时间驱动，而以数据驱动重传。也就是说，如果，包没有连续到达，就ack最后那个可能被丢了的包，如果发送方连续收到3次相同的ack，就重传。Fast Retransmit的好处是不用等timeout了再重传。 比如：如果发送方发出了1，2，3，4，5份数据，第一份先到送了，于是就ack回2，结果2因为某些原因没收到，3到达了，于是还是ack回2，后面的4和5都到了，但是还是ack回2，因为2还是没有收到，于是发送端收到了三个ack=2的确认，知道了2还没有到，于是就马上重转2。然后，接收端收到了2，此时因为3，4，5都收到了，于是ack回6。示意图如下： Fast Retransmit只解决了一个问题，就是timeout的问题，它依然面临一个艰难的选择，就是，是重传之前的一个还是重传所有的问题。对于上面的示例来说，是重传#2呢还是重传#2，#3，#4，#5呢？因为发送端并不清楚这连续的3个ack(2)是谁传回来的？也许发送端发了20份数据，是#6，#10，#20传来的呢。这样，发送端很有可能要重传从2到20的这堆数据（这就是某些TCP的实际的实现）。可见，这是一把双刃剑。 SACK 方法另外一种更好的方式叫：Selective Acknowledgment (SACK)（参看RFC 2018），这种方式需要在TCP头里加一个SACK的东西，ACK还是Fast Retransmit的ACK，SACK则是汇报收到的数据碎版。参看下图： 这样，在发送端就可以根据回传的SACK来知道哪些数据到了，哪些没有到。于是就优化了Fast Retransmit的算法。当然，这个协议需要两边都支持。在 Linux下，可以通过tcp_sack参数打开这个功能（Linux 2.4后默认打开）。 这里还需要注意一个问题——接收方Reneging，所谓Reneging的意思就是接收方有权把已经报给发送端SACK里的数据给丢了。这样干是不被鼓励的，因为这个事会把问题复杂化了，但是，接收方这么做可能会有些极端情况，比如要把内存给别的更重要的东西。所以，发送方也不能完全依赖SACK，还是要依赖ACK，并维护Time-Out，如果后续的ACK没有增长，那么还是要把SACK的东西重传，另外，接收端这边永远不能把SACK的包标记为Ack。 注意：SACK会消费发送方的资源，试想，如果一个攻击者给数据发送方发一堆SACK的选项，这会导致发送方开始要重传甚至遍历已经发出的数据，这会消耗很多发送端的资源。详细的东西请参看《TCP SACK的性能权衡》 Duplicate SACK – 重复收到数据的问题Duplicate SACK又称D-SACK，其主要使用了SACK来告诉发送方有哪些数据被重复接收了。RFC-2883 里有详细描述和示例。下面举几个例子（来源于RFC-2883） D-SACK使用了SACK的第一个段来做标志， 如果SACK的第一个段的范围被ACK所覆盖，那么就是D-SACK 如果SACK的第一个段的范围被SACK的第二个段覆盖，那么就是D-SACK 示例一：ACK丢包 下面的示例中，丢了两个ACK，所以，发送端重传了第一个数据包（3000-3499），于是接收端发现重复收到，于是回了一个SACK=3000-3500，因为ACK都到了4000意味着收到了4000之前的所有数据，所以这个SACK就是D-SACK——旨在告诉发送端我收到了重复的数据，而且我们的发送端还知道，数据包没有丢，丢的是ACK包。 示例二，网络延误 下面的示例中，网络包（1000-1499）被网络给延误了，导致发送方没有收到ACK，而后面到达的三个包触发了“Fast Retransmit算法”，所以重传，但重传时，被延误的包又到了，所以，回了一个SACK=1000-1500，因为ACK已到了3000，所以，这个SACK是D-SACK——标识收到了重复的包。 这个案例下，发送端知道之前因为“Fast Retransmit算法”触发的重传不是因为发出去的包丢了，也不是因为回应的ACK包丢了，而是因为网络延时了。 可见，引入了D-SACK，有这么几个好处： 1）可以让发送方知道，是发出去的包丢了，还是回来的ACK包丢了。 2）是不是自己的timeout太小了，导致重传。 3）网络上出现了先发的包后到的情况（又称reordering） 4）网络上是不是把我的数据包给复制了。 知道这些东西可以很好得帮助TCP了解网络情况，从而可以更好的做网络上的流控。 Linux下的tcp_dsack参数用于开启这个功能（Linux 2.4后默认打开） 好了，上篇就到这里结束了。如果你觉得我写得还比较浅显易懂，那么，欢迎移步看下篇《TCP的那些事（下）》]]></content>
      <tags>
        <tag>转载</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wireshark权限问题]]></title>
    <url>%2F2018%2F06%2F21%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2Fwireshark-permission%2F</url>
    <content type="text"><![CDATA[第1章 wireshark安装和启动1. 权限问题：wireshark安装之后，以普通用户身份打开，提示以下错误： 12The capture session could not be initiated on interface 'enp3s0'(You don't have permission to capture on that device). 解决方案：方案一：添加工作组 12345678910111213141516# 创建wireshark用户组，并将当前用户加入到wireshark用户组中sudo groupadd wiresharksudo usermod -a -G wireshark $USER# 设置/usr/bin/dumpcap目录所属的用户组为wireshark，且设置权限为754sudo chgrp wireshark /usr/bin/dumpcapsudo chmod 754# 设置sudo setcap 'CAP_NET_RAW+eip CAP_NET_ADMIN+eip' /usr/bin/dumpcap# 在当前会话中，登录到wireshark用户组中newgrp wireshark# 测试wireshark能否正常使用wireshark 你会发现在当前的终端运行wireshark不会报错了。而如果重新打开另一个终端，运行wireshark，会提示： 1couldn't run /usr/bin/dumpcap in child process 这是因为新打开的终端会话窗口并没有登录到wireshark中。我们前面已经将$USER添加到wireshark用户组中了，只不过重启系统之后才会登录到wireshark用户组 也可以用newgrp wireshark命令在当前会话窗口中登录wireshark用户组，这样不重启也能正常工作，不过只能在当前会话窗口启动wireshark 方案二：直接设置允许非root用户运行 1sudo dpkg-reconfigure wireshark-common 使用此方法，非root用户也可以执行所有操作。 而方案一，添加工作组之后，有一部分功能仍然要求root权限 2. wireshark支持的网络类型wireshark捕获网络信息使用的libpcap/WinPcap库。在各个平台下支持的网络类型如下： 图片来源 第2章 初试TCP捕获(1) 设置并启动捕获 在菜单栏中选择，捕获-&gt;选项 其中port 443是指https所使用的端口号。 点击开始 (2) 查看捕获的信息 然后在浏览器中访问csdn博客，就可以捕获到流量了。 (3) 关注TCP的连接过程 菜单栏中统计-&gt;流量图 记得将底部的流类型选为TCP流。 从图中可以看出，这一次访问一共建立了4个TCP连接（相同颜色的是一组连接过程）。每一个连接的简建立都有三个步骤： SYN SYN,ACK ACK 按道理应该1个连接就可以了。 参考链接[1] Ubuntu下Wireshark普通权限不足之解决方案]]></content>
      <tags>
        <tag>日常</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[deepin更换字体]]></title>
    <url>%2F2018%2F06%2F21%2F%E6%97%A5%E5%B8%B8%2Fdeepin%E6%9B%B4%E6%8D%A2%E5%AD%97%E4%BD%93%2F</url>
    <content type="text"><![CDATA[deepin系统有个奇怪的现象： chrome非常卡，打开标签页卡，上下滚动卡。 google搜索之后知道更改字体可以解决。于是在系统设置中更换字体，确实chrome不卡了，更神奇的是：整个系统都变得流畅多了！！！ 更换字体过程： 控制中心-&gt;个性化-&gt;字体-&gt;标准字体-&gt;选择自己喜欢的字体。]]></content>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浮点数]]></title>
    <url>%2F2018%2F06%2F19%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%2Ffloat-number%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[clion使用技巧]]></title>
    <url>%2F2018%2F06%2F19%2F%E6%97%A5%E5%B8%B8%2FClion%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[快捷键参考：https://www.cnblogs.com/tonycody/p/3257601.html 自定义代码模板：http://ice1000.org/2016/08/28/IDEAAdvance1/ 函数跳转：ctrl+鼠标左键点击 函数跳转返回：ctrl+alt+ ←→方向键 代码补全：ctrl + 空格 智能补充提示：ctrl +shift +空格 查找类：ctrl+N，输入类名 快速打开工程的某个文件：ctrl + shift + N,输入文件名 任意搜索(search everything)：连续两下shift 如果要查看一个函数，变量在工程中哪里使用：鼠标移到该函数，alt + F7 浮动窗口预览函数，变量定义：ctrl+shift+I 高亮函数，变量在工程中的位置：ctrl + shift + F7，然后可以用F3和 shift + F3在高亮处来回切换，ESC退出高亮 跳转到函数声明处：ctrl + B 编译： ctrl + F9 调试运行：shift + F9 step over：F8 step into：F7 step out：shift + F8 智能提示：点击灯泡或 alt + enter 将代码用if，for等语句包围起来：菜单栏 code -&gt; surround with 复制行：ctrl+D 删除行：ctrl+X 从函数中抽出一部分作为新的函数：选中-&gt;ctrl+alt+M 选中代码作为宏：选中-&gt; ctrl+alt+D 查看文件中的函数，类，结构体等：ctrl + F12； 选中之后按下enter或者F4跳转]]></content>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[stm32+串口蓝牙]]></title>
    <url>%2F2018%2F06%2F15%2F%E5%B5%8C%E5%85%A5%E5%BC%8F%2Fstm32-BTStethoscope%2F</url>
    <content type="text"><![CDATA[项目简介 使用ADC1的2个通道 每个按照2KHz的采样频率进行采样 ADC1的采样精度为12bits，数据寄存器为16bits 串口设置为 115200bps, 1个停止位，没有校验位，8个数据位，禁用流控制 使用双缓冲，用于改善数据从ADC -&gt; 内存 -&gt; 串口的传输 流程总结 设置系统时钟 设置定时器TIM3 设置ADC1 设置串口USART1 设置DMA 设置中断控制器，允许定时器中断，串口中断 开启定时器 定时时间到，产生定时器中断 定时器中断中启动ADC采样一次 采样完成，通过DMA将采样数据传送到串口发送缓冲区中 串口发送缓冲区满，启动串口发送 发送成功，产生串口发送中断，表示串口数据发送成功 第一，设置系统时钟stm32的系统时钟(SYSCLK)有三个时钟源选择： 外部高速时钟(HSE) 内部高速时钟(HSI) 锁相环时钟(PLL)——其实是由外部高速时钟演变而来 通常，使用8MHz的晶振作为stm32的时钟源，然后一生二，二生三，三生万物，最终形成一个完整的时钟系统。 8MHz晶振 -&gt; SYSCLK -&gt; AHB和APB -&gt; 各种外设的时钟 我的项目里的时钟设置，简化如下： TIM3的时钟挂载在APB1下，此外它还有自己的分频器 ADC1的时钟挂载在APB2下，它也有自己的分频器 USART1的时钟挂载在APB2下 GPIO的时钟也挂载在APB2下 第二，设置定时器理论知识点 通用定时器有三个核心的寄存器 计数寄存器(TIMx_CNT)——计数 自动重装载寄存器(TIMx_ARR)——每次计数到0都会从这个寄存器读入新的计数值 预分频寄存器(TIMx_PSC)——用于设置定时器的预分频器 此外，就是一些设置定时器工作方式的寄存器了 定时器控制寄存器(TIMx_CR1、TIMx_CR2)——设置定时器时钟源的分频器、向上/下计数、使能计数器，选择定时器的通道等定时器状态寄存器(TIMx_SR) 定时器中断/DMA使能寄存器——决定是否开启中断或DMA功能 定时器事件产生寄存器(TIMx_EGR)——设置什么时候会产生事件，比如，计数寄存器更新的时候 定时器捕获和比较寄存器 (TIMx_CCMR1) 项目设置 我的项目里设置定时器的三个核心寄存器如下： 设置定时器时钟源的分频器为/1 预分频器为/72 计数寄存器和自动重装载寄存器的计数值为500 而在第一步中可以知道，定时器挂载在APB1中，时钟频率为72MHz，因此可以得到定时器计时频率为2KHz 至于工作模式 设置定时器向上计数，即从0开始计数 ，计数值到达自动重装载寄存器的500-1之后，又回到0重新计数 设置当发生计数更新时，产生一个TRGO信号，后面会用该TRGO信号来触发ADC采样。 1234567891011121314151617void TIM3_Config(u16 psc, u16 arr)&#123; TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure; RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE); TIM_TimeBaseStructure.TIM_ClockDivision = 1; TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up; TIM_TimeBaseStructure.TIM_Period = arr; TIM_TimeBaseStructure.TIM_Prescaler = psc; TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseStructure); TIM_SelectOutputTrigger(TIM3, TIM_TRGOSource_Update); //使用TIM3的TRGO触发ADC进行转换,步骤1(4) TIM_Cmd(TIM3,ENABLE);&#125; 第三，设置ADC1理论知识点 ​ 一个ADC往往会有几个通道可以使用，且每个通道都有一条采样的输入线，每条输入线与GPIO口共用stm32的某个引脚。比如ADC1的通道1和通道2的输入线分别与GPIOA0和GPIOA1共用引脚，那么引脚就是用来做ADC的采样输入线还是做GPIO呢？这就需要我们还设置引脚的复用功能。 ​ ADC有两种好用的功能 可以有多个通道依次采样，即多通道扫描功能 可以设置循环采样； 结合多通道扫描功能和循环采样功能，可以实现多通道循环扫描，也就是多个通道不停地轮流采样。 ​ 不过要使用ADC的多通道扫描功能，就必须启用DMA功能，这样才能快速地将采样的数据从ADC中保存到内存中，避免被下一通道的数据覆盖。开启DMA功能后，会在每一次转换结束后产生DMA请求，DMA就立马行动起来。（当然我们还需要设置DMA。后面再说） ​ ADC的启动也是有多种方式的，一种是通过写某个寄存器的某个位，手动启动ADC，也可以设置用外部信号来触发ADC采样。比如可以用定时器产生的TRGO信号来触发。 ​ stm32的ADC1采样精度为12bits，而ADC1的数据寄存器有16bits，那么采样的12bits数据怎么放到16bits中呢？这就产生了两种存放的方法，你可以将12bits放在16位寄存器的高12位（左对齐），也可以放在16位寄存器的低12位（右对齐）。 ​ ADC采样的时候并不是一瞬间就完成的，而是在一个较短的时间内采样，然后ADC内部将模拟量转成数字量。stm32内部可以设置采样的时间，但模拟量转成数字量的时间是固定的12.5个周期。从采样到最后变成数字量的这段时长就称为ADC的转换时间。 $转换时间 = 采样时间 + 12.5周期$ ​ 注意上面的采样时间和采样频率是不一样的概念。采样频率表示的是多久采一次，而采样时间是采一次要花多长时间。 项目设置 开通了ADC1的两个通道用来采样，当定时器产生TRGO信号时，触发ADC进行采样，设置ADC1用多通道循环采样的方式来采，每个通道采完都会产生一个DMA请求。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * @brief Configures the ADC1: * ADC_Mode_Independent,non-ContinuousConvMode,ScanConvMode, * ExternalTrigConv_T3_TRGO,DataAlign_Right,2 channels(PA0,PA1) * @param None * @retval None */void ADC1_Config()&#123; /* ADC,GPIO 初始化结构体 */ ADC_InitTypeDef ADC_InitStructure; GPIO_InitTypeDef GPIO_InitStructure; /* ADC的时钟要单独设置，通常设为72/6 = 12MHz */ RCC_ADCCLKConfig(RCC_PCLK2_Div6); /* 所有外设都要开启时钟，才能使用 */ RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_ADC1,ENABLE); /* ADC1的两个通道PA0和PA1配置为模拟输入(共18个通道))*/ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOA, &amp;GPIO_InitStructure); /* ADC1工作方式配置：*/ ADC_DeInit(ADC1); ADC_InitStructure.ADC_Mode = ADC_Mode_Independent; ADC_InitStructure.ADC_ContinuousConvMode= DISABLE; //使用TIM3的TRGO触发ADC进行转换,步骤2(4) ADC_InitStructure.ADC_ScanConvMode = ENABLE; ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_T3_TRGO; //使用TIM3的TRGO触发ADC进行转换,步骤3(4) ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right; ADC_InitStructure.ADC_NbrOfChannel = 2; ADC_Init(ADC1, &amp;ADC_InitStructure); /* 两个通道配置 */ ADC_RegularChannelConfig(ADC1, ADC_Channel_0, 1, ADC_SampleTime_13Cycles5); ADC_RegularChannelConfig(ADC1, ADC_Channel_1, 2, ADC_SampleTime_13Cycles5); /* 使能ADC的外部触发转换（外部触发源将在tim.c文件中设置成TIM1更新事件）*/ ADC_ExternalTrigConvCmd(ADC1,ENABLE); //使用TIM3的TRGO触发ADC进行转换,步骤4(4) /* ADC必须开启DMA功能才能使用扫描模式 */ ADC_DMACmd(ADC1, ENABLE); ADC_Cmd(ADC1, ENABLE); /* ADC内置校准电路，上电后都要进行校准 */ ADC_ResetCalibration(ADC1); while(ADC_GetResetCalibrationStatus(ADC1)); ADC_StartCalibration(ADC1); while(ADC_GetCalibrationStatus(ADC1)); &#125; 第四，设置ADC1对应的DMA通道​ DMA包含有多个通道，可以设置每个通道用来处理不同的事务。比如前面我们设置ADC会产生DMA请求，那么DMA怎么处理呢？ ​ 我们知道，DMA的功能是可以将数据从外设传送到内存中，或者从一片内存传送到另一片内存中。 ​ 而ADC开启DMA功能的原因就是：希望ADC产生DMA请求之后，DMA可以帮忙将ADC的数据寄存器里的数据保存到内存中。知道这个目标，我们就可以分析出这个DMA通道需要知道哪些信息才能完成工作了。 数据的来源在哪里？——ADC的数据寄存器 数据送到哪里去？——内存的buffer数组 一个数据有多大？——ADC的数据寄存器为16位，说明一个数据占2个字节 送多少个数据过去？——ADC希望每采一个通道就立马把数据保存到内存中，说明一次只要传一个数据 怎么知道数据到底传出去没有？——DMA通道也可以启动中断功能，一旦传送完成，就产生一个中断 1234567891011121314151617181920212223242526272829303132333435/** * @brief Configures DMA of ADC1: * from peripheral(ADC1) to memory, * datasize of peripheral and memory are both halfword, * MemoryInc_Enable, PeripheralInc_Disable * DMA_Mode_Circular! * enable DMA_IT_TC * @param memBaseAddr: Where you want to store values of ADC convertion. * periphBaseAddr: DR of ADC1 * bufferSize: Its unit depends on direction of transmission * @retval None */void ADC1_DMA_Config(u32 memBaseAddr, u32 periphBaseAddr, u32 bufferSize)&#123; DMA_InitTypeDef DMA_InitStructure; RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE); DMA_DeInit(DMA1_Channel1); DMA_InitStructure.DMA_Mode = DMA_Mode_Circular; //循环模式，每次传输完成，都会重新指向缓冲区的开头 DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC ; //ADC1-&gt;DR &gt;&gt; 缓冲区 DMA_InitStructure.DMA_BufferSize = bufferSize; //设定缓冲区大小，单位与MemoryDataSize或者PeripheralDataSize相同 DMA_InitStructure.DMA_MemoryBaseAddr = memBaseAddr; // DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord ; //缓冲区数据宽度为半字(16bits) DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable; //缓冲区地址递增 DMA_InitStructure.DMA_PeripheralBaseAddr = periphBaseAddr; // DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord; //ADC1-&gt;DR的数据宽度也是半字(16bits),实际上，ADC分辨率只有12bits DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable; //外设地址不增 DMA_InitStructure.DMA_Priority = DMA_Priority_Medium; // DMA_InitStructure.DMA_M2M = DMA_M2M_Disable; // DMA_Init(DMA1_Channel1, &amp;DMA_InitStructure); DMA_ITConfig(DMA1_Channel1, DMA_IT_TC, ENABLE); //开启DMA传输完成中断 DMA_Cmd(DMA1_Channel1, ENABLE);&#125; 第五，设置串口USART1（1）设置串口的时钟源 串口也需要设置时钟，它的时钟源挂载在APB2下（36MHz）。 （2）设置stm32的引脚复用作为USART1的Tx和Rx 串口的Tx和Rx分别与GPIOA9和GPIO10共用引脚，因此需要设置引脚的复用功能。 （3）设置串口的参数 一般串口需要设置以下的参数： 串口的波特率是多少？ 串口是用来接收的，发送的，还是既能接收又能发送的？ 串口接收或者发送的数据是否有奇偶校验位？有的话，是奇校验还是偶校验？ 数据有几个停止位？ 真实数据的长度有多长？8bits？9bits？ 串口要不要使用流量控制的功能？ 串口设置如下：115200bps, 没有校验位，1个停止位，8位数据长度，禁用流控制 12345678910111213141516171819202122232425262728293031323334353637/** * @brief Configures the USART1: * 1.Configure PA9 and PA10; * 2.Configure USART1 * @param None * @retval None */void USART1_Config(u32 bound)&#123; GPIO_InitTypeDef GPIO_InitStructure; USART_InitTypeDef USART_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA, ENABLE); /* GPIO configuration*/ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOA, &amp;GPIO_InitStructure); GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOA, &amp;GPIO_InitStructure); /* USART1 configuration*/ USART_InitStructure.USART_BaudRate = bound; USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx ; //收发模式 USART_InitStructure.USART_Parity = USART_Parity_No; USART_InitStructure.USART_StopBits = USART_StopBits_1; //1位停止位 USART_InitStructure.USART_WordLength = USART_WordLength_8b; //8bits数据宽度 USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; USART_Init(USART1, &amp;USART_InitStructure); USART_DMACmd(USART1, USART_DMAReq_Tx, ENABLE); USART_Cmd(USART1, ENABLE); //使能串口 &#125; 第六，设置USART1对应的DMA通道串口是用来发送数据的，那数据是什么呢？ 我的项目里串口是用来发送ADC的采样数据的。为了方便快捷，我为USART1也开了一个DMA通道，可以将前面保存到buffer中的ADC采样数据通过DMA送到串口的发送缓冲寄存器中。同样面临一样的DMA该怎么设置的问题： 数据的来源是什么？——保存在内存buffer中的ADC采样数据 数据送到哪里去？——送到USART1的发送缓冲寄存器中 一个数据有多大？——因为串口的发送缓冲寄存器只有8位，因此一次只能传8bits 传多少数据？——buffer的作用就是缓存。所以我等ADC的两个通道每个通道采56次数据，然后再加上帧头跟帧尾6个字节，组成一个数据帧，一共有$2通道 56次/通道 16bits/次 + 6bytes = 230 bytes$，也就是说每次传230个字节的数据 什么时候串口对应的DMA通道开始工作？——缓冲区满了以后。我们知道缓冲区有多大，知道每个数据有多大，自然就知道什么时候缓冲区会满 12345678910111213141516171819202122232425262728293031323334/** * @brief Configures DMA of USART1: * from memory to peripheral(USART1), * datasize of peripheral and memory are both Byte(8bits), * MemoryInc_Enable, PeripheralInc_Disable * DMA_Mode_Circular! * enable DMA_IT_TC * @param memBaseAddr: Where you contents your data. * periphBaseAddr: DR of USART1 * bufferSize: Its unit depends on direction of transmission * @retval None */void USART1_TX_DMA_Config(u32 memBaseAddr, u32 periphBaseAddr, u32 bufferSize)&#123; DMA_InitTypeDef DMA_InitStructure; RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE); DMA_DeInit(DMA1_Channel4); DMA_InitStructure.DMA_BufferSize = bufferSize; DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST ; DMA_InitStructure.DMA_M2M = DMA_M2M_Disable; DMA_InitStructure.DMA_MemoryBaseAddr = memBaseAddr; DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte ; DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable; DMA_InitStructure.DMA_Mode = DMA_Mode_Circular; DMA_InitStructure.DMA_PeripheralBaseAddr = periphBaseAddr; DMA_InitStructure.DMA_PeripheralDataSize = DMA_MemoryDataSize_Byte; DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable ; DMA_InitStructure.DMA_Priority = DMA_Priority_Medium; DMA_Init(DMA1_Channel4, &amp;DMA_InitStructure); DMA_ITConfig(DMA1_Channel4, DMA_IT_TC, ENABLE);&#125; 第七，启动定时器，一切按部就班开始运行 定时时间到，触发ADC开始采样 ADC每次采样后触发DMA，DMA将采样数据保存到内存缓冲区buffer中 buffer满了以后，就触发DMA，将buffer中的数据一个一个送到串口的发送寄存器中 串口发送寄存器有了数据，就会触发发送功能。于是数据源源不断发送出去。 后记​ 为了采样和数据发送可以同时进行，我在内存中开辟了两个buffer，上面为了解释方便，我并没有说明这一点。我们已经知道内存中的buffer有两个作用 保存ADC的采样数据到buffer中 从buffer中将数据送到串口中 ​ 假设只使用一个buffer，那么buffer满了之后，就需要暂停采样，才能用DMA将buffer的数据送到串口中。而暂停采样将会导致采样断断续续，很不合理。 ​ 如果使用两个buffer，事情就好办了。可以让采样的数据保存在buffer1中，而将buffer2中的数据送到串口。等buffer1满了，反过来，将采样的数据保存在buffer2中，而将buffer1中的数据送到串口。 ​ 当然，这还涉及到采样数据产生的速度和数据发送出去的速度。很容易理解，数据发送的速度必须比数据产生的速度快才行，不然会有一部分数据丢失。 分析两者： （1）数据产生的速度 采样频率为2KHz，2个通道，每次采样数据长度为2个字节，则数据产生的速度为 $2000Hz 2通道 2字节/次 = 8000字节/s = 64000bps$ ADC产生数据后我们还会加上帧头帧尾，而且串口在发送的时候会加入停止位，导致每秒要发送的实际数据产生量比ADC每秒产生数据量要多一些，但也大不了太多。 （2）串口发送的速度 串口发送的速度115200bps &gt; 64000bps很多，即使算上帧头帧尾和串口发送时加入的停止位导致的开销，也完全可以满足串口发送的速度大于数据产生的速度]]></content>
      <tags>
        <tag>stm32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[stm32中断]]></title>
    <url>%2F2018%2F06%2F15%2F%E5%B5%8C%E5%85%A5%E5%BC%8F%2Fstm32-interrupt%2F</url>
    <content type="text"><![CDATA[stm32的中断控制器NVIC可以设置不同的中断配置方案，即抢占优先级和响应优先级的配比。 这两种优先级的含义： 抢占优先级：高优先级的中断可以抢占低优先级的中断 响应优先级：假设有多个中断，抢占优先级相同。如果在一个中断运行期间，来了很多个抢占优先级相同，但响应优先级不同的中断，那么后续来的这些中断将会根据响应优先级排序，等当前的中断处理后，选择最高响应优先级的中断去处理。]]></content>
      <tags>
        <tag>stm32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Arm开发环境搭建]]></title>
    <url>%2F2018%2F06%2F14%2F%E5%B5%8C%E5%85%A5%E5%BC%8F%2Farm%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[在Linux下搭建2440的开发环境 一，构建arm-linux交叉编译工具链有三种方法构建工具链 直接下载别人编译好的交叉工具链arm-linux-gcc-4.4.3 apt-get下载gcc-arm-linux-gnueabi 自己下载arm-linux-gcc的源码，编译安装 法1，下载编译好的arm-linux-gcc（1） 下载 下载地址：http://www.arm9.net/download.asp 假设下载后解压放在目录/home/cheng/arm-linux/中 （2）配置PATH路径 编辑/etc/profile文件 123$ sudo vim /etc/profile# 在文件中添加一下内容export PATH=$PATH:/home/cheng/arm-linux/bin/ 执行命令 1source /etc/profile # 使/etc/profile生效 法2，apt-get下载交叉编译工具链1sudo apt-get install gcc-arm-linux-gnueabi 法3，源码编译安装arm-linux-gcc sudo apt-get install build-essential #基本开发环境 sudo apt-get install bison flex#分别是语法、词法分析器 sudo apt-get install manpages-dev#安装C函数库man 手册 sudo apt-get install libncurses5-dev 安装交叉编译工具链(自己利用crosstool工具制作)下载crosstoolwget http://crosstool-ng.org/download/crosstool-ng/crosstool-ng-1.21.0.tar.xz解压并进入源码目录tar vxf crosstool-ng-1.21.0.tar.xzcd crosstool-ng-1.21.0打补丁在源码目录中执行lzcat contrib/openrisc-or32.patch.lzma | patch -p1先安装crosstool-NG的依赖项： gperf bison flex texinfo gawk libtool automake libncurses5-dev g++ 执行编译三部曲./configure –prefix=/home/cheng/Programs/Crosstoolmakemake install确认/opt/cross/bin已经安装，当然你可以用你习惯的路径替代/opt/cross 在三部曲第一步中提示缺少什么依赖项就安装什么。 如缺少makeinfo,在网上查阅知道sudo apt-get install texinfo （注意这里不是makeinfo，可能是包含在texinfo里了）configure: error: missing required tool: gperf则sudo apt-get install gperfconfigure: error: missing required tool: makeinfo则sudo apt-get install texinfoconfigure: error: could not find GNU awk则sudo apt-get install gawk configure: error: could not find GNU automake &gt;= 1.10则sudo apt-get install automake configure: error: could not find curses header, required for the kconfig frontends则sudo apt-get install libncurse5-dev 设置环境变量export PATH=$PATH:/home/cheng/Programs/Crosstool/bin 检查是否安装成功ct-ng -v 配置crosstoolcrosstool-NG配置 二，串口调试安装串口驱动 Linux会自动安装PL2303的驱动 12$&gt; ls /dev/ttyUSB*/dev/ttyUSB0 //这就是我们的串口 串口调试工具 minicom：命令行界面 cutecom：图形界面 picocom：命令行界面（我比较喜欢这个） picocom的使用 1$&gt; sudo picocom -b 115200 /dev/ttyUSB0 //具体是ttyUSB* 可以去/dev目录下查看 退出picocom 先按ctrl+a(表示转义)再按ctrl+q 三，烧录程序JZ2440有两种烧录程序的方法， 使用调试下载器EOP+OpenOCD 使用调试下载器EOP+oflash 使用uboot+dnw，则可通过usb线烧录程序，不过前提是必须先用EOP烧录uboot到芯片中 官方介绍 参考博客 法1，EOP+OpenOCD烧录（1）下载安装OpenOCD 1$ sudo apt-get install openocd 安装成功后，会识别出eop 123$&gt; lsusb //查看usb设备Bus 001 Device 009: ID 067b:2303 Prolific Technology, Inc. PL2303 Serial PortBus 001 Device 010: ID 1457:5118 First International Computer, Inc. OpenMoko Neo1973 Debug board (V2+) OpenMoko Neo1973 Debug board，是eop。加下ID号为 14567:5118，后面要使用 （2）配置OpenOCD openocd的默认配置文件是openocd.cfg，当启动openocd时，会在安装目录openocd/scripts下搜索openocd.cfg。如何没有创建openocd.cfg，则需要使用-f 参数指定配置文件。为了方便，直接在/usr/share/openocd/scripts/中创建openocd.cfg文件，配置如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071$ cd /usr/share/openocd/scripts/$ sudo vim openocd.cfg //复制以下内容interface ftdi #通过描述来指定设备，应当和dmesg中的Product一致 #ftdi_device_desc "USB&lt;=&gt;JTAG&amp;RS232" #通过PID VID指定调试器，比描述更准确些 ftdi_vid_pid 0x1457 0x5118 #如果有多个同样的调试器，还可以指定要使用的调试器序列号 #ftdi_serial #引脚定义，相当于旧版中的 ft2232_layout jtagkey ftdi_layout_init 0x0c08 0x0f1b ftdi_layout_signal nTRST -data 0x0100 -noe 0x0400 ftdi_layout_signal nSRST -data 0x0200 -noe 0x0800 # Target configuration for the Samsung 2440 system on chip # Tested on a S3C2440 Evaluation board by keesj # Processor : ARM920Tid(wb) rev 0 (v4l) # Info: JTAG tap: s3c2440.cpu tap/device found: 0x0032409d (Manufacturer: 0x04e, Part: 0x0324, Version: 0x0) if &#123; [info exists CHIPNAME] &#125; &#123; set _CHIPNAME $CHIPNAME &#125; else &#123; set _CHIPNAME s3c2440 &#125; if &#123; [info exists ENDIAN] &#125; &#123; set _ENDIAN $ENDIAN &#125; else &#123; # this defaults to a bigendian set _ENDIAN little &#125; if &#123; [info exists CPUTAPID ] &#125; &#123; set _CPUTAPID $CPUTAPID &#125; else &#123; # force an error till we get a good number set _CPUTAPID 0x0032409d &#125; #jtag scan chain jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0x0f -expected-id $_CPUTAPID # #jtag_rclk 3000 adapter_khz 1234 #set _TARGETNAME $_CHIPNAME.cpu #target create $_TARGETNAME arm920t -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm920t #$_TARGETNAME configure -work-area-phys 0x200000 -work-area-size 0x4000 -work-area-backup 0 #arm7_9 fast_memory_access enable set _TARGETNAME $_CHIPNAME.cpu target create $_TARGETNAME arm920t -chain-position $_TARGETNAME $_TARGETNAME configure -work-area-phys 0x00200000 \ -work-area-size 0x4000 -work-area-backup 0 #reset configuration reset_config trst_and_srst #Flash CFG&lt;openocd.pdf P[74~] #flash bank name driver base size chip_width bus_width target [driver_options] #usage: flash bank &lt;name&gt; &lt;driver&gt; &lt;base&gt; &lt;size&gt; &lt;chip_width&gt; &lt;bus_width&gt; &lt;target&gt; #flash bank bank_id driver_name base_address size_bytes chip_width_bytes bus_width_bytes target [driver_options ...] flash bank 0 cfi 0x0 0x200000 2 2 $_TARGETNAME #NAND CFG &lt;openocd.pdf P[88~92]&gt; #nand device name driver target [ configparams... ] nand device 0 s3c2440 $_TARGETNAME 其实openocd/script/interface目录下包含多种调试器的配置文件，其下，board目录中的配置文件是比较有名的开发板(如mini2440)的配置文件，如果可以在里面找到自己的开发板，就直接用。而JZ2440需要自己配置。 （3）启动OpenOCD 1openocd 出现libusb_open()错误，其实是没有权限写设备 123456789$&gt; sudo openocd -f cheng-openjtag.cfg...Info : Listening on port 6666 for tcl connectionsInfo : Listening on port 4444 for telnet connectionsInfo : clock speed 1234 kHzInfo : JTAG tap: s3c2440.cpu tap/device found: 0x0032409d (mfg: 0x04e (Samsung), part: 0x0324, ver: 0x0)Info : Embedded ICE version 2Info : s3c2440.cpu: hardware has 2 breakpoint/watchpoint unitsInfo : Listening on port 3333 for gdb connections 表明已经成功了 （4）烧录 烧录方法参考：http://d1.amobbs.com/bbs_upload782111/files_38/ourdev_631472V6X051.pdf 法2，EOP+oflash烧录u-boot（1）安装oflash 下载oflash工具：百度网盘 假设下载后放在/home/cheng/ProgramFiles/Portable/oflash/bin/oflash 设置PATH路径 123$ sudo vim /etc/profile# 添加PATH路径export PATH=$PATH:/home/cheng/ProgramFiles/Portable/oflash/bin/ （2）烧录程序 进入想要烧录的程序所在的目录 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960$ oflash u-boot.bin# 根据提示，输入# 1.选择JTAG类型为：OpenJTAG# 2.选择CPU为：S3C2440# 3.选择烧录到：Nor flash# 4.选择偏移量为：0+---------------------------------------------------------+| Flash Programmer v1.3 for OpenJTAG of www.100ask.net || OpenJTAG is a USB to JTAG &amp; RS232 tool based FT2232 || This programmer supports both of S3C24X0 &amp; S3C6410 || Author: Email/MSN(thisway.diy@163.com), QQ(17653039) |+---------------------------------------------------------+Usage: 1. oflash, run with cfg.txt or prompt2. oflash [file], write [file] to flash with prompt3. oflash [-f config_file]4. oflash [jtag_type] [cpu_type] [flash_type] [read_or_write] [offset] [file]Select the JTAG type: 0. OpenJTAG1. Dongle JTAG(parallel port)2. Wiggler JTAG(parallel port)Enter the number: 0Select the CPU:0. S3C24101. S3C24402. S3C6410Enter the number: 1'ft2232' interface using libftdi with 'jtagkey' layout (1457:5118)current latency timer: 2FTDI chip type: 2 "2232C"S3C2440 detected, cpuID = 0x0032409d[Main Menu] 0:Nand Flash prog 1:Nor Flash prog 2:Memory Rd/Wr 3:Exit Select the function to test:1Detect Nor Flash ...MXIC MX29LV160B Size: 2 MBImage Size: 0x304bcAvailable Target Offset:Bank # 1: MXIC MX29LV160B FLASH (16 x 16) Size: 2 MB in 35 Sectors AMD Standard command set, Manufacturer ID: 0xC2, Device ID: 0x2249 Erase timeout: 30000 ms, write timeout: 100 msSector Start Addresses:00000000 00004000 00006000 00008000 00010000 00020000 00030000 00040000 00050000 00060000 00070000 00080000 00090000 000A0000 000B0000 000C0000 000D0000 000E0000 000F0000 00100000 00110000 00120000 00130000 00140000 00150000 00160000 00170000 00180000 00190000 001A0000 001B0000 001C0000 001D0000 001E0000 001F0000 Input target offset:0Erasing ....... donewrite ...100%done 法3，使用uboot+dnw烧录程序​ dnw实现USB传输文件的功能，可以结合dnw和u-boot的USB功能，快速的将文件下载，烧录到开发板中。 直接使用现成dnw （1）下载安装 下载地址：百度网盘 可以去github上下载，自己编译安装：dnw-linux，按照其中的步骤，make，makeinstall，安装完毕。 （2）配置PATH路径 1234$ sudo vim /etc/profile# 添加以下内容export PATH=$PATH:/home/cheng/ProgramFiles/Portable/dnw/bin/ （3）烧录程序 烧录程序之前，确保： 已经安装picocom、oflash、dnw 已经将uboot烧录到JZ2440上 已经将启动的拨码开关拨到Nor启动（即用于启动uboot） 已经将板子的USB口和COM口连上电脑 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071# 1.打开串口调试工具sudo picocom -b 115200 /dev/ttyUSB0# 2.按下复位按键，进入uboot+---------------------------------------------+| S3C2440A USB Downloader ver R0.03 2004 Jan |+---------------------------------------------+USB: IN_ENDPOINT:1 OUT_ENDPOINT:3FORMAT: &lt;ADDR(DATA):4&gt;+&lt;SIZE(n+10):4&gt;+&lt;DATA:n&gt;+&lt;CS:2&gt;NOTE: Power off/on or press the reset button for 1 sec in order to get a valid USB device address.Hit any key to stop autoboot: 2# 3.在上面2s的倒计时计数之前，按下空格，进入uboot菜单，如下：##### 100ask Bootloader for OpenJTAG #####[n] Download u-boot to Nand Flash[o] Download u-boot to Nor Flash[c] Re-scan Nor Flash[u] Copy bootloader from nand to nor[v] Copy bootloader from nor to nand[k] Download Linux kernel uImage[j] Download root_jffs2 image[y] Download root_yaffs image[d] Download to SDRAM &amp; Run[z] Download zImage into RAM[g] Boot linux from RAM[f] Format the Nand Flash[s] Set the boot parameters[b] Boot the system[r] Reboot u-boot[q] Quit from menuEnter your selection: # 4.选择n，表示通过uboot下载程序到Nand flash中，正处于等待从USB下载程序的状态Enter your selection: nUSB host is connected. Waiting a download.# 5.打开另一个终端窗口，使用dnw下载程序$ dnw /home/cheng/led/led.bin # 可以使用相对路径也可以使用绝对路径# 6.一瞬间下载成功，此时可以看到第一个终端窗口又显示uboot菜单Now, Downloading [ADDRESS:30000000h,TOTAL:46]RECEIVED FILE SIZE: 46 (0KB/S, 1S)NAND erase: device 0 offset 0x0, size 0x40000Erasing at 0x20000 -- 100% complete.OKNAND write: device 0 offset 0x0, size 0x24Writing data at 0x0 -- 100% complete. 36 bytes written: OK##### 100ask Bootloader for OpenJTAG #####[n] Download u-boot to Nand Flash[o] Download u-boot to Nor Flash[c] Re-scan Nor Flash[u] Copy bootloader from nand to nor[v] Copy bootloader from nor to nand[k] Download Linux kernel uImage[j] Download root_jffs2 image[y] Download root_yaffs image[d] Download to SDRAM &amp; Run[z] Download zImage into RAM[g] Boot linux from RAM[f] Format the Nand Flash[s] Set the boot parameters[b] Boot the system[r] Reboot u-boot[q] Quit from menuEnter your selection: # 7.将启动拨码开关，拨到Nand启动，复位，则可以看到led亮了，说明下载成功 O(∩_∩)O~~]]></content>
      <tags>
        <tag>arm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo更换NexT主题]]></title>
    <url>%2F2018%2F06%2F13%2F%E6%97%A5%E5%B8%B8%2Fgithub-page-theme%2F</url>
    <content type="text"><![CDATA[使用next主题 下载主题123$ cd ~/Documents/Hexo$ mkdir themes/next$ curl -s https://api.github.com/repos/iissnan/hexo-theme-next/releases/latest | grep tarball_url | cut -d '"' -f 4 | wget -i - -O- | tar -zx -C themes/next --strip-components=1 开启next主题1234$ vim _config.yml# 修改文件中theme字段，主题改为nexttheme: next 清除一下，然后重新启动hexo本地站点，并开启调试 1$ hexo clean | hexo s --debug 浏览器登陆 https://localhost:4000 添加第三方插件搜索(1) 安装hexo-generator-searchdb插件 进入站点的根目录，执行命令 1$ npm install hexo-generator-searchdb --save (2) 编辑站点配置文件 在根目录下的_config.yml，插入以下内容 123456# local searchsearch: path: search.xml field: post format: html limit: 10000 (3) 编辑主题配置文件 NexT主题目录下的_config.yml，找到以下内容，设置enable: true 123# Local searchlocal_search: enable: true 阅读统计使用不蒜子统计 编辑主题配置文件的busuanzi_count的配置项 123456busuanzi_count: enable: false # 全局总开关 site_uv: true # 用户访问量开关 site_pv: true # 站点访问量开关 page_pv: true # 页访问量开关 参考文献[1] NexT开始使用 [2] 第三方服务集成 [3] Next github详细介绍]]></content>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux的内核线程，普通进程和普通线程]]></title>
    <url>%2F2018%2F06%2F11%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2Flinux-task-thread%2F</url>
    <content type="text"><![CDATA[进程/线程的描述 ​ 严格来说，Linux中并没有真正的线程，而是共享地址空间的一组进程来实现线程的功能，不过我们还是使用线程这个术语。在操作系统原理中我们知道，操作系统既有进程控制块PCB又有线程控制块TCB。然而在Linux中，进程和线程的控制块都用数据结构task_struct来表示，线程并没有自己独立的线程控制块。 ​ 同一个进程中的线程共享地址空间，共享堆，但是并不共享栈。由于地址空间是由mm_struct和页表描述的，也就是说线程间也共享页表。 mm_struct负责描述进程/线程的虚拟地址空间，页表则负责将虚拟地址空间描述成物理地址空间。 每个进程/线程在内核中都有一个与之相对应的内核栈。当创建一个新的进程/线程时，内核为进程/线程创建了 进程/线程描述符(task_struct) 在内核地址空间中申请了两页的空间作为该进程/线程的内核栈。 准确的说，这两页的空间低地址处放了一个thread_info数据结构，指向进程描述符，剩下的空间才是真的拿来做内核栈的。 进程描述符其实也有一个指针指向thread_info数据结构 内核栈，进程栈，线程栈和中断栈 （1）操作系统创建进程时，会在用户地址空间创建进程栈，同时在内核空间为该进程也创建一个内核栈。 用户进程在用户态下运行，使用进程栈。 当其陷入内核态时，使用内核栈。 （2）操作系统创建线程时，除了复制主进程的地址空间外，还会为每个线程创建一个独立的线程栈，当然在内核空间也创建了一个内核栈。 （3）操作系统初始化时，就已经在内核空间中创建了一个中断栈，中断服务例程调用函数时就会用到该中断栈。 系统启动时的内核线程 系统正式启动时，会执行 start_kernel 函数，其中创建了第一个进程，名为init_task，其PID=0，运行于内核态。 然后init_task会创建内核线程init，其PID=1，运行于内核态，完成内核空间的初始化。完成内核空间初始化后，载入/sbin/init可执行程序，变成普通进程，仍有PID=1，运行于用户态。 接着init_task进程演变成idle进程，仍有PID=0。 idle进程又会创建kthreadd内核线程，其PID=2，用来创建并管理其他内核线程。 虚拟内存地址空间 系统内核常驻于物理内存中，并不会被换出。 页表 有两种页表，一种是内核页表，一种是进程页表 内核页表，称为主内核页全局目录，它的作用应该是作为一个模板，不管是普通进程还是内核线程都不能访问。 进程页表，最开始的部分映射0~3G的地址空间，后面部分映射内核地址空间3~4G，其内容就是从内核页表中复制过来的，完全一样。所以普通进程只要陷入内核态，就可以处理系统调用和中断/异常。即当系统调用，中断或异常发生时，只需要切换CPU上下文，而不需要切换进程上下文。 内核线程如何访问页表 尽管内核中存在内核页表，但是不管是普通进程还是内核线程都不能访问它。普通进程有自己的页表，要访问页表自然是轻而易举。但是内核线程没有自己的页表，它该如何是好？ 既然普通进程有页表，内核页表却不能访问，那内核线程访问普通进程的页表不就可以了吗？普通进程对应于内核空间的页表内容是从内核页表中复制过来的，因此内核线程可以找到内核空间。 参考文献[1] Linux 内核线程及普通进程总结 [2] Linux 中的各种栈：进程栈 线程栈 内核栈 中断栈 这两篇博客都写得非常好！]]></content>
      <tags>
        <tag>操作系统</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统关键词]]></title>
    <url>%2F2018%2F06%2F09%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2Fos-keywords%2F</url>
    <content type="text"><![CDATA[第1章 计算机系统概述 第2章 操作系统概述 第3章 进程描述和控制 第4章 线程、对称多处理和微内核 第5章 并发性：互斥和同步 第6章 并发：死锁和饥饿 第7章 内存管理 第8章 虚拟内存 第9章 单处理器调度 第10章 多处理器和实时调度 第11章 I/O管理和磁盘调度 第12章 文件管理 第13章 嵌入式操作系统 第14章 计算机安全威胁 第15章 计算机安全技术 第16章 分布式处理、客户/服务器和集群 第1章 计算机系统概述 第2章 操作系统概述 第3章 进程描述和控制 第4章 线程、对称多处理和微内核 第5章 并发性：互斥和同步 第6章 并发：死锁和饥饿 第7章 内存管理 第8章 虚拟内存 第9章 单处理器调度 第10章 多处理器和实时调度 第11章 I/O管理和磁盘调度 第12章 文件管理 第13章 嵌入式操作系统 第14章 计算机安全威胁 第15章 计算机安全技术 第16章 分布式处理、客户/服务器和集群]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ucore实验环境搭建]]></title>
    <url>%2F2018%2F06%2F09%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2Fucore%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[安装工具 配置eclipse 使用eclipse调试 使用命令行运行 使用命令行调试 安装gitbook 下载实验手册 参考文献 安装工具 qemu 硬件模拟器 eclipse c/c++代码阅读器 understand 代码分析工具 meld 文件对比工具（图形界面） 123sudo apt-get install qemu-system-x86sudo apt-get install eclipse-cdtsudo apt-get install meld 配置eclipse安装插件 “Zylin Embedded CDT” 进入菜单help-&gt; install new software，填上以下内容，然后next直到完成。 在eclipse的工具栏中显示debug按钮 我安装好的eclipse中并没有debug按钮，所以才需要设置。如果已经有了，就不用管 window -&gt; open perspective -&gt; other 下载ucore项目 github地址：ucore_os_lab 12# 进入你的工作目录，执行git clone https://github.com/chyyuu/ucore_os_lab 导入工程 选择菜单file -&gt; import 因为我的workspace中已经导入了lab1_result，所以才会提示project already exists Debug configurations 选择菜单Run -&gt; Debug configurations （1）配置main Name可以随便起 （2）配置debugger stop on startup at: bootmain 表示启动后在bootmain处暂停 这里也可以不用设，因为后面的commands配置中有设了在 bootmain处暂停 （3）配置commands ‘initialize’ commands 区域 123456target remote:1234file /home/cheng/Mooc-OS/ucore_os_lab/labcodes_answer/lab1_result/obj/bootblock.obreak bootmain#file /home/cheng/Mooc-OS/ucore_os_lab/labcodes_answer/lab1_result/bin/kernel#break kern_init#break print kerninfo 第1行表示连接qemu 第2行表示把bootloader的程序加载到qemu中 第3行表示在bootmain处暂停，这里要用到bootmain，该符号在bootloader中 ’Run‘ commands 区域 1continue External tools configurations 选择菜单 run -&gt; external tools -&gt; external tools configurations 使用eclipse调试（1）运行external tools 第一次使用先进入external tools configurations,点击右下角的run。以后就可以在工具栏中的图标直接点击运行(下图中右边那个) 弹出qemu窗口，进入等待连接的状态 出现的警告不要紧 （2）运行debug 第一次使用先进入debug configurations,点击右下角的run。以后就可以在工具栏中的图标直接点击运行（下图中左边那个） 可以看到红色的部分是前面在debug configurations中设置的命令 （3）在console中添加kernel，并执行到kern_init，断点break，然后cont跳转过去 在console中依次输入命令 123file bin/kernelbreak kern_initcont （4）自己调试 使用命令行运行123cd labcodes_answer/lab1_resultmakemake qemu # 直接运行 使用命令行调试123cd labcodes_answer/lab1_resultmakemake debug # 会启动qemu，和一个cgdb的窗口，如果报错，则安装cgdb即可 在cgdb窗口中，可以执行gdb命令,如 n -&gt; next 执行下一步 p 变量名 -&gt; print 变量名 打印变量的值 continue -&gt; 持续执行 按下ctrl+c -&gt; 暂停 where -&gt; 显示当前运行位置 quit -&gt; 退出调试 安装gitbook 需要安装nodejs，npm 12sudo apt-get install nodejs,npmsudo npm install gitbook -g 下载实验手册https://github.com/chyyuu/ucore_os_docs 参考文献[1]清华大学Ucore操作系统实验记实1-实验环境]]></content>
      <tags>
        <tag>操作系统</tag>
        <tag>ucore</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的deepin15.5配置]]></title>
    <url>%2F2018%2F06%2F09%2F%E6%97%A5%E5%B8%B8%2Fmy-deepin%2F</url>
    <content type="text"><![CDATA[1.设置网络省略 2. 下载各种软件(1) 可以在终端下载的软件： sudo apt-get install locate guake typora git xmind keepass2 meld zeal vscode sublime cutecom picocom albert xscreensaver bleachbit stacer mpv virtualbox netease-cloud-music alacarte gnome-sushi uget xpad draw.io catfish calibre whatever teamviewer npm &amp;&amp; wget -qO- https://raw.github.com/ma6174/vim/master/setup.sh | sh -x &amp;&amp; sudo npm install -g hexo (2) 下载安装包，用深度软件包管理器的软件： stacer netease understand cd ~/Downloads wget http://d1.music.126.net/dmusic/netease-cloud-music_1.1.0_amd64_deepin.deb \ https://github.com/oguzhaninan/Stacer/releases/download/v1.0.9/stacer_1.0.9_amd64.deb \ http://builds.scitools.com/all_builds/b944/Understand/Understand-5.0.944-Linux-64bit.tgz 这两个软件用命令行下载的版本有问题，因此去官网下最新的版本 (3) 应用商店安装的软件： TIM 坚果云 go-for-it sublime text 3 3. 破解understand打开understand，选择使用legacy license 进入软件界面后，help-&gt;legacy licensing，选择输入注册码：D59E41A3360B 4. 设置软件启动 guake go-for-it 坚果云 albert xscreensaver（需要在stacer中设置开机启动命令：xscreensaver -nosplash&amp;） 5. 显示网速小插件如何安装：https://jingyan.baidu.com/article/90808022004c15fd90c80f4f.html 下载地址：https://pan.baidu.com/s/17gEBP1ABln_USwrg9MgpBA 6. 安装qluqlo(1) 下载xscreensaver，并设置开机启动 1sudo apt-get install xscreensaver 启动stacer，在里面设置开机软件，添加启动命令为：xscreensaver -nosplash&amp; (2) 下载编译gluqlo 12345cd ~/Downloadsgit clone https://github.com/alexanderk23/gluqlo.gitcd gluqlo/sudo apt-get install build-essential libsdl1.2-dev libsdl-ttf2.0-dev libsdl-gfx1.2-dev libx11-devmake &amp;&amp; sudo make install (3) 配置xscreensaver 123vim ~/.xscreensaver在库中添加：-GL: gluqlo -root \n\ 在启动器中打开xscreensaver,选择onl one screen saver,并选中gluqlo (4) 设置锁屏快捷键 在控制中心中修改系统默认的锁屏快捷键为ctrl+alt+l (系统原本为super + L，但是我不想用系统自带的锁屏，因此腾出该快捷键给xscreensaver用) 自定义快捷键： 名称：Xscreensaver 命令：xscreensaver-command -lock 快捷方式：super + L 7. VS code配置印象笔记插件(1) 安装插件 evermonkey (2) 安装markdown all in one]]></content>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于操作系统的一些疑问]]></title>
    <url>%2F2018%2F06%2F07%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2Fos-questions%2F</url>
    <content type="text"><![CDATA[关于内存管理1.既要有物理内存管理，又要有虚拟内存管理，两者分别管理什么？ 2.如果产生了缺页异常，该怎么处理？ 根据缺页异常的中断向量号，去查询中断描述符表IDT，可以找到对应的ISR所在的地址。其中进行了相应的处理。缺页异常一共有三个原因： 虚拟地址不合法 虚拟页不在内存中，也不在硬盘中，即第一次访问，没有建立过映射 虚拟页在硬盘中 针对三种情况，分别处理： 直接报错 分配空闲页，并填写虚拟页对应的页表项。如果当前没有空闲页，还需要执行置换算法 将虚拟页从硬盘中换入到内存中。 3.ISR的地址是虚拟地址，线性地址还是物理地址？ 我想应该时线性地址，因为是通过查询全局描述符表GDT获得的。而GDT的作用就是获得段的起始地址 4.虚拟内存区域vma是什么意思？ 我们知道linux虚拟内存的布局如下： 用户空间占用3G，内核空间占用1G。其实这3G的用户空间也不是虚拟内存能够使用。只有申请为vma的区域才是可以合法的区域。如果没有申请为vma，相当于没有这块虚拟内存。比如申请了一块vma为0x10000000~0x10001000,那么位于该虚拟区间的虚拟地址合法（如0x10000FFF）。 5.连续内存如何分配？ 动态分配策略： first-fit best-fit worst-fit 伙伴系统 操作系统需要维护的数据结构： 空闲物理区域 已分配给各个进程的物理页 连续内存分配的缺点：外部碎片——可以使用碎片紧凑的方法克服外部碎片，不过前提是所有的应用程序都是可重定位的。 6.非连续内存分配方法有哪些？ 段式存储——不连续的二维结构，需要知道每个段的起始地址和长度 页式存储 7.快表的作用是什么？ ​ 可以缓存近期访问过的页表项，如果这里能找到，那就不用去内存中查找，提高响应速度。 8.多级页表的作用是什么？ ​ 建立页表树，等到用到的时候再创建相应的页表，没有用到的就不用创建，这样可以大大减少页表数量。 9.什么是反置页表？ ​ 反置页表又称倒置页表，倒排页表。传统的方法用页表来表示4G的虚拟内存空间，页表按照虚拟页号排序，页表项内容为该虚拟页对应的物理页帧。如果只用一个页表来表示，显然页表会非常长，所以目前多采用多级页表。 ​ 但是现在的64bit系统允许使用非常大的虚拟内存空间，用多级页表页也会占用很大的内存空间。因此采用逆向思维，反过来，用页表来表示实际物理内存空间，而不是虚拟内存空间，页表按照物理页帧号排序，页表项的内容为该物理页帧对应的虚拟页号和所属的进程PID。我们可以检索进程PID和要访问的虚拟地址的页号来找到对应的物理页帧号。不过要检索进程PID和虚拟页号还是比较费时的，可以使用hash映射来加快速度。 ​ 给定虚拟地址后，对进程PID和虚拟地址的页号进行hash映射，得到物理页帧号，如果hash结果冲突，就去遍历冲突项链表，这样可以很快找到虚拟地址对应的物理地址。 10.如何进行物理内存管理？操作系统怎么记录已分配的物理页？ 操作系统有数据结构用来记录物理内存空间中的连续物理内存区域。Linux采用伙伴系统来管理物理内存。 伙伴系统的原理如下： 伙伴系统的zone数据结构中有一个数据结构数组free_area[]就是用来记录连续的物理内存区域的。物理内存区域的基本单位是页帧。数组free_area[]的第n个元素存放的是所有长度为2^n个页帧的连续空闲物理内存区域构成的链表。如free_area[0]存放的是长度为1个页帧的所有空闲区域构成的链表,ree_area[1]存放的是长度为2个页帧的空闲区域构成的链表。 11.缺页异常的发生和处理过程是怎么样的？ 访问虚拟地址 查询页表 页表项中没有映射关系，或者该页不在物理内存中 产生缺页异常 根据缺页异常的中断向量号跳转对应的ISR中 判断属于哪种原因导致的缺页异常，这里假设是页表项中没有映射关系导致的 由物理内存管理器选择一个物理页帧，分配给虚拟页 填写对应的页表项 根据虚拟地址找到其所在的虚拟页在磁盘中的位置（可以根据文件系统找到可执行文件在磁盘中的位置） 磁盘驱动器将虚拟页从磁盘中复制到物理内存中 12.如果缺页时，物理内存已经没有空间了，怎么办？ ​ 这个时候需要使用页面置换算法，从物理内存中选出一个物理页帧换出到磁盘中，再把该物理页帧分配给造成缺页异常的虚拟页。 13.有哪些页置换算法？ 可以分成两大类：一种是从当前的进程占用的物理页帧中选择，一种是从整个物理内存中未锁定的物理页帧选择。 第一大类有以下几种： 最优算法——理想中的算法，选择未来最不可能使用的虚拟页对应的物理页帧。遗憾的是，无法知道未来。 先入先出算法——选择分配时间最久的物理页帧。但是在内存中待的最久的虚拟页常常也是使用比较频繁的页，这种方法不好。 最近最久未使用算法——接近最优算法。我们没办法知道未来，但是可以根据最近使用的情况来预测对应的物理页在未来是否会被访问。如果最近都没有使用，可以假设短期的未来也不会访问。 时钟算法——最近最久算法实现起来比较麻烦，开销比较大，因为要根据过去的一段时间的访问情况来预测。为了简单，时钟算法只统计上一次扫描周期是否被访问过。 改进时钟算法——最近最久未使用算法和时钟算法都没考虑到一点，如果一个物理页被修改过，那么置换出去的时候就必须将页帧写回磁盘中，这样就得等它写完之后才能把该物理页重新分配，太慢了。于是在最近最久未使用的规则上再加一条限制：该物理页没有修改过。也就是说选出最近最久未使用且没有修改的物理页帧。用二元组 (是否访问过， 是否修改 ) 来表示一个页帧的使用情况，通常按照以下顺序选择置换的页： (0, 0) &gt; (0,1) &gt; (1, 0) &gt; (1, 1) 第二大类有以下几种： 工作集算法 缺页率算法 386编程模型1.中断、异常和系统调用有什么区别和联系？ 中断——来自硬件设备的请求，又称硬件中断，外部中断，异步中断 异常——非法指令或者其他原因导致当前的指令执行失败，包含traps,faults,aborts 系统调用——应用程序主动向操作系统请求系统服务。 系统调用是有了操作系统后的一个叫法，在裸机的时候应该称之为“软中断”。系统调用的处理方法与异常相同。 广义上讲，硬件中断、异常和系统调用都属于“中断”，都有相应的中断号与之相对应。 2.中断/异常与CALL指令的异同？ 3.产生中断/异常之后的处理过程？ 首先需要保护现场，然后跳转到中断服务例程进行中断处理，最后恢复现场。详细过程如下： (1) 产生中断，硬件自动设置中断标志位，CPU切换特权级 (2) 硬件自动保护现场，入栈：标志寄存器EFLAGS、返回地址CS和EIP、栈地址SS和ESP (3) 切换堆栈：设置SS和ESP 保护现场有两个含义： (1) 硬件执行：中断隐指令自动保存重要的现场信息：标志寄存器EFLAGS、返回地址CS和EIP、栈地址SS和ESP(产生特权级转换才需要) (2) 软件编程执行：由中断服务例程中保存通用寄存器。而中断服务例程是操作系统的一部分 4.产生中断/]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[磁盘调度]]></title>
    <url>%2F2018%2F06%2F05%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[磁盘性能参数 寻道时间——磁头定位到目标磁道所需要的时间 旋转延迟——磁头到达目标扇区做需要的时间 传送时间——读写数据所需要的时间 磁盘调度策略 随机调度(RSS) 先进先出(FIFO) 进程优先级(PRI) 后进先出(LIFO) 最短服务时间优先(SSTF) 电梯算法(SCAN)——来回扫 循环扫描算法(C-SCAN)——一个方向扫 N-step-SCAN 分步电梯算法(FSCAN) RAID分成7个级别，RAID 0~6]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[I/O管理]]></title>
    <url>%2F2018%2F06%2F05%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2Fio-manager%2F</url>
    <content type="text"><![CDATA[一、I/O设备的基本概念 二、操作系统关于I/O的设计 I/O缓冲 一、I/O设备的基本概念I/O设备分类 一般可以分成三种类型： 人可读：适用于计算机与用户之间的交互，例如打印机，终端，显示器，键盘，鼠标等 机器可读：适用于与电子设备通信，例如磁盘驱动器，传感器，控制器和执行器 通信：适用于与远程设备通信，例如数字线路驱动器和调制解调器 执行I/O的三种技术 可编程I/O——处理器代表进程向I/O模块发出一个I/O命令，查询方式 中断驱动I/O DMA I/O功能的发展 处理器直接控制外围设备 I/O控制器或I/O模块 I/O控制器或I/O模块，中断方式 DMA I/O通道——特殊的处理器，可以执行专用的I/O指令，但没有内存，与CPU共用内存 I/O处理器——完整的处理器功能，具有自己的内存 后面三种方式，广义来讲，都可以称为DMA方式，都让CPU从I/O的任务中解脱出来。 DMA机制的配置 三种配置： 单总线，分离的DMA —— 共用系统总线，使用DMA在I/O模块和内存之间传送数据时，将会占用系统总线，导致处理器暂停工作 单总线，集成的DMA和I/O —— 将DMA和I/O集成在一块，减少系统总线的占用时间 I/O总线 —— 进一步扩展上面的方法，使得DMA中的I/O接口数量减少 二、操作系统关于I/O的设计设计目标 效率 通用性 I/O功能的逻辑结构 为了追求通用性，将I/O功能分层，其中有三个重要的层次 逻辑I/O——用户可以根据设备标识符，使用打开，关闭，读，写等逻辑功能 设备I/O——将逻辑功能转换成具体的I/O指令序列，通道命令和控制器命令 调度和控制——处理中断，收集并报告I/O状态，执行控制 稍微复杂一点的设备，如文件系统的管理，则有如下的结构 I/O缓冲 这里的缓冲，是指在内核空间中增加数据缓冲区，而不是指用户空间中使用的数据缓冲区，称为系统缓冲。 如果没有系统缓冲，那么用户进程在读写I/O设备时，被阻塞了，需要注意，不能将进程空间中的I/O传送数据区置换出去。因为如果置换出去，那么I/O操作就不能执行，就永远无法解除阻塞了。 而有了系统缓冲区之后，用户进程就可以完全地置换出去，因为操作系统会代替用户进程先接收数据，等完成之后，再解除用户进程的阻塞，并将数据送给用户进程。]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[deepin添加HP网络打印机]]></title>
    <url>%2F2018%2F06%2F04%2F%E6%97%A5%E5%B8%B8%2Fdeepin%E5%AE%89%E8%A3%85%E6%89%93%E5%8D%B0%E6%9C%BA%E9%A9%B1%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[环境 打印机型号：HP Laserjet Pro M126nw 系统：deepin 15.5 安装打印机驱动程序 方法一： deepin系统默认安装了hplip，如果没有，则先安装hplip 终端运行命令 123$ sudo apt-get install hplip# hplip安装成功后，运行$ hp-setup 弹出打印机设置界面 实验室的打印机是固定分配IP地址的，输入IP查找 可以轻易查找到实验室的打印机，往后一直next，直到完成。 方法二： （1）按下Win键，输入打印设置，打开应用 选择“添加” （2）输入网络打印机IP 弹出身份认证，由于打印机没有设置权限，按取消键，关掉该窗口 点击forword （3）选择驱动程序 注意上面选择第二项，选择第一项不成功。 选择forword 选择apply （4）添加成功，可以打印测试页]]></content>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实时调度]]></title>
    <url>%2F2018%2F06%2F04%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2Freal-time-scheduling%2F</url>
    <content type="text"><![CDATA[一、实时调度的概念定义 实时计算可以定义成这样一类计算：即系统的正确性不仅取决于计算的逻辑结果，而且还依赖于产生结果的时间 分类 硬实时任务：必须在规定期限内完成，否则将出现致命错误 软实时任务：尽量在规定期限内完成，超过期限也还可以接受 周期性任务 非周期性任务 实时操作系统的要求 可确定性：从高优先的设备产生中断到操作系统开始服务的延迟，表示操作系统感知中断之前的延迟 可响应性：中断之后操作系统提供中断服务的时长。 用户控制：允许用户细粒度地控制任务优先级，以及指定其他的一些特性 可靠性：非实时系统如果出现故障，通过重启解决。实时系统如果故障，代价非常昂贵，因此要求可靠性高 故障弱化操作：实在出现故障了，实时操作系统将尝试改正问题或最小化它的影响，并继续执行。当需要关机时，也必须维护文件和数据的一致性 实时操作系统的特点 实时操作系统有以上五个要求，因此一般具有以下特征： 快速的进程或线程切换 体积小 迅速响应外部中断的能力 通过诸如信号量、信号、事件之类进程间通信工具，实现多任务处理 使用特殊的顺序文件，可以快速存储数据 基于优先级的抢占式调度 最小化禁止中断的时间 用于使任务延迟一段固定的时间或暂停/恢复任务的原语 特定的报警和超时设定 二、实时调度考虑的问题 一个系统是否执行可调度性分析 如果执行，是静态的还是动态的 根据分析的结果是否产生一个调度或计划 根据以上三个问题，可以把各种实时调度算法分成以下几类： 静态表法：执行静态的可调度性分析。分析的结果是一个调度，用于确定一个任务何时必须开始执行 静态优先级抢占法：执行静态分析。分析的结果不是一个直接的调度，而是指定任务的优先级。然后再使用传统的基于优先级的抢占式调度器 基于动态规划的调度法：动态分析可调度性。任务到达之后，才开始分析，只有当它能够满足时间约束，才被接受执行。分析结果是一个调度或计划，用于确定何时分派任务 动态尽力调度法：不执行可调度性分析。只是试图满足所有的最后期限。如果实在满足不了，错过了最后期限，就把该进程终止了。 三、限期调度实时应用程序通常不关注绝对速度，关注的是在最有价值的时间启动或完成任务 采用最早最后期限优先的调度策略，超过最后期限的任务数最少。 四、速率单调调度(RMS)为周期性任务解决多任务调度冲突。 RMS基于任务的周期给它们指定优先级。最短周期的任务具有最高优先级…. 当同时有多个任务可以被执行时，最短周期的任务优先执行。 速率是周期的倒数，因此可以说速率越快的任务优先级越高。如果将任务的优先级看做速率的函数，那么这就是一个单调递增函数。因此得名速率单调调度。 五、优先级反转较高优先级必须等待较低优先级任务时，称为优先级反转。 例子： 假设优先级满足任务A&lt;任务B。 任务A先运行，它占用了共享资源； 任务B到来，因为优先级更高，抢占了任务A，开始执行……. 任务B想要使用共享资源，发现被占用，阻塞； 任务A恢复执行，使用完资源后，释放共享资源； 任务B解除阻塞，抢占任务A执行 该例子中，因为共享资源被低优先级任务占用的缘故，导致高优先级的任务B要等待低优先级的任务A，出现了优先级反转。 更严重的一种情况是无界限优先级反转：优先级反转的持续时间不仅依赖于处理处理共享资源的时间，还依赖于其他不相关任务的不可预测的行为 例子： 优先级顺序满足：任务A&lt;任务B&lt;任务C 任务A先运行，占用了共享资源； 任务C到来，抢占任务A，发现共享资源被占用，阻塞； 任务A运行 任务B到来，抢占任务A，运行 任务B结束，任务A运行，使用玩共享资源，释放资源； 任务C解除阻塞，抢占任务A，运行….. 任务C结束，任务A运行 这种情况下，高优先级的任务C不仅因为共享资源被占用而等待，还因为在等待的过程中，占用资源的任务被中等优先级的任务抢占了，还得等中等优先级运行完。加重了优先级反转。 解决办法 方法一：优先级继承策略 低优先级任务A占用了共享资源，此时高优先级任务B进来，却因为资源被占用而阻塞。 此时，赋予任务A与任务B同等级别的优先级。这时中等优先级的任务不能抢占任务A。 等到任务A释放资源后，又将任务A的优先级改回去。 方法二：优先级置顶策略 低优先级任务A占用了共享资源后，优先级立马提高到可能使用该资源的最高优先级。 两种方法的特点： 优先级继承策略——水涨船高 优先级置顶策略——一步登天]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多处理器调度]]></title>
    <url>%2F2018%2F06%2F04%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2Fmul-processor-scheduling%2F</url>
    <content type="text"><![CDATA[一、多处理器系统 二、多处理器调度的设计问题 三、多处理器的线程调度 一、多处理器系统 松耦合、分布式多处理器、集群 专门功能的处理器 紧耦合多处理 粒度的概念 描述系统中多个进程的并行和同步程度。可分为： 无约束并行性 粗粒度和非常粗粒度并行性 中等粒度并行性 细粒度并行性 二、多处理器调度的设计问题三个相互关联的问题： 把进程分配到处理器 在单个处理器上使用多道程序设计 一个进程的实际分派 （1）把进程分配到处理器 两种方式： 静态分配——进程从激活到完成，一直都分配给同一个处理器 动态分配——所有进程进入一个全局队列，然后调度到任何一个可用的处理器上运行。在不同的时间可以在不同的处理器上运行 （2）在单个处理器上使用多道程序设计 如果使用动态分配方式将进程分配给处理器，那么单个处理器不需要再实现多道程序设计了，因为调度已经是在上一步完成了。 但如果使用静态分配方式，即把单个进程与处理器绑定，就需要考虑该问题。因为进程可能因为I/O阻塞而使得其绑定的处理器经常空闲，这时候就需要多个进程来使用该处理器，以提高使用率 （3）进程分派问题 多处理器系统的进程调度尽量选用简单的分配策略。因为时间轮转法、优先级调度法等复杂的调度算法在多处理器上的提升效果不明显，甚至 三、多处理器的线程调度通常有四种方式： 负载共享 组调度 专用处理器调度 动态调度 （1）负载共享 不是把进程分配给处理器，而是把线程分配给处理器，并且使用动态分配的方式。 系统维护一个全局的就绪线程队列。当某个处理器空闲时，就从该队列中选择一个线程。 负载共享的方法有： FCFS：即按顺序排队，选队首线程投入运行。 最少线程优先：即共享就绪队列按优先级构造，具有未调度线程个数最少的作业其线程的优先级最高。 抢占式最少线程优先：是对最少线程数优先法的改造。如果新到来的作业所拥有的线程个数比当前运行作业的还少，就发生抢占。 优点： 负载分布在不同的处理器上； 不需要集中调度，操作系统的调度程序可以运行在不同的处理器上。 缺点： 对该全局队列占用的内存区必须互斥访问，可能成为瓶颈问题； 由于被抢占的线程未必能在相同的处理器上恢复执行，因而降低本地高速缓存的效率； 把所有线程看做公用线程池，一个进程的所有线程未必能同时获得处理器，从而严重损害处理器性能。 （2）组调度 一组相关线程作为一个单位同时调到一组处理器上运行，一一对应，所有成组线程一起开始和结束它们的时间片。 成组调度可使一个进程的所有线程一起运行，若其中一个线程向另一个发出请求，能立即得到该信息且能立即回答。因此在一个时间片中，同一个进程的各线程间可以发送和接收大量的信息，大大方便了线程间的通信。 优点 对于中等粒度到细粒度的并行应用程序，组调度非常必要。因为这种应用程序，如果一部分开始运行，而另一部分还没有开始，为了同步，必须等待，性能会严重下降。 并且，合作线程一起占用一组处理器，同步时，一个线程先运行，另一个线程占用另一个处理器，等着前一个进程发来同步信号，而不去切换别的进程。这样减少切换开销 减少同步等待时间 减少进程切换开销 （3）专用处理器调度 这是成组调度的极端形式。当一个进程被调度时，它的每个线程被分配到一个处理器上，在该进程完成之前，处理器由相应的线程专用。 这种方法会浪费处理器的时间。当一个线程为了与另一个线程同步而等待I/O时，该线程专用的处理器就闲置了。但是，在由几十甚至上百个处理器组成的高度并行系统中，处理器的利用率不再是最重要的问题。此外，在一个应用程序的生存期中完全避免了进程切换，因而大大加速了程序的执行。 （4）动态调度 某些应用程序允许动态地改变进程中的线程数目，因此操作系统可以通过天正负载情况来提高利用率。 操作系统和应用程序共同进行调度决策。 操作系统负责把处理器分配给作业。 应用程序决定运行进程中的哪些线程，以及当该进程被抢占时应该挂起哪个线程 每个作业通过把它的一部分可运行任务映射到线程，使用当前划分给它的处理器执行任务。]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单处理器调度]]></title>
    <url>%2F2018%2F06%2F04%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2Fsing-processor-scheduling%2F</url>
    <content type="text"><![CDATA[单处理器调度 一、调度类型 二、调度准则 三、调度策略 1. 先来先服务 2. 时间片轮转 3. 最短进程优先 4.最短剩余时间优先 5. 最高响应比优先 6. 优先级调度 7. 多级反馈队列 单处理器调度一、调度类型三种类型： 长程调度——将新建的进程加入到就绪队列 中程调度——将挂起的进程从交换空间换入到内存中，并加入到就绪队列 短程调度——选择某个确切的就绪进程运行 名字反映了执行相应功能的时间长短。主要关注短程调度 二、调度准则考虑两种方向的调度准则， 面向用户的准则：提供好的用户体验，处理器的利用率和吞吐量等系统性能相对次要 面向系统的准则：重点关注系统的性能 有如下几种评价准则： CPU利用率 系统吞吐量——单位时间内CPU完成的进程数量 周转时间——进程开始到结束所花费的时间，包含了等待时间 等待时间——进程等待处理器的时间 响应时间——进程创建到系统首次响应的时间 三、调度策略六种调度策略 先来先服务（FCFS——First come first sevice） 时间片轮转（RR——Round Robin） 最短进程优先（SPN——Shortest process next） 最短剩余时间（SRT——Shortest remaining time） 最高响应比优先（HRRN——Highest response ratio next） 优先级 多级反馈队列 1. 先来先服务每次调度都选择就绪队列最前面的进程，分配处理器。该进程一直运行直到完成或者阻塞。阻塞后回到就绪队列队尾重新排队。 缺点：如果短进程排在长进程之后，那么短进程要等很久才能运行；I/O密集型进程会经常被阻塞，等解除阻塞之后又要重新会队尾排队，浪费在排队的时间很长。 2. 时间片轮转周期性，按照先来先服务的方法调度。原理上，也可以归属于FCFS策略 与FCFS调度的方法区别在于：FCFS选择进程之后，该进程会一直运行直到完成或阻塞；而时间片轮转会周期性打断，切换下一个进程执行。 缺点：对I/O密集型进程不利，原因同FCFS，经常阻塞，阻塞之后又要重新排队 改进——虚拟轮转法 增加一个辅助队列。I/O阻塞解除之后，进入辅助队列而不是就绪队列，并且处理器每次先调度辅助队列里的进程。这样就可以减少I/O密集型进程的排队时间。 3. 最短进程优先预估每个进程需要的服务时长。从队列中选择预估时间最短的进程运行。 缺点：需要预估服务时长；短进程优先，那么长进程可能一直饥饿 4.最短剩余时间优先预估每个进程还需要多长时间，从队列中选择预估还需要的时间最短的进程运行 缺点：同最短进程优先一样 5. 最高响应比优先响应比越高优先权越高。 $R = (等待时间 + 要求服务时间)/要求服务时间$ 从公式中可以看出： 等待时间相同时，要求服务时间越短，响应比越大，优先权越高。即短进程优先 要求服务时间相同时，等待时间越长，响应比越大，优先权越高，即先来先服务 虽然短进程优先，但长进程等待时间越长，其优先权逐渐升高，因此兼顾了长进程 该算法综合考虑了多种因素。 缺点：需要预估服务时长；调度前需要计算响应比，因此增加了系统开销 6. 优先级调度分成两种 静态优先级：优先级确定以后不可改变。可以由系统确定，也可以由用户确定优先级。 动态优先级：优先级在运行的过程中不断调整。 7. 多级反馈队列多级队列有以下特点： （1）设置多个优先级队列。使用优先级选择队列 （2）使用时间轮转法选择队列内部某个进程运行 （3）每个优先级队列的时间片不一样。优先级越高的队列，其内部轮转的时间片越短。 调度过程： 新进程加入到第一队列的队尾，然后按时间轮转法调度执行。时间片用完后，加入下一队列的队尾，同样按时间轮转法等待调度。时间片用完继续加到下一队列……直到最后一个队列。最后的队列中，时间片用完后会加到最后队列的队尾。 从上图可以看出， 新进程优先级高 短进程会先运行完 长进程到最后一个队列，变成时间轮转算法 多级反馈队列不需要预估服务时长，兼顾长短进程，因此该方法使用较多。]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程与线程]]></title>
    <url>%2F2018%2F06%2F02%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2Fprocess-thread%2F</url>
    <content type="text"><![CDATA[进程与线程的比较 进程是资源分配的基本单位，线程是CPU调度的基本单位 进程拥有一个完整的资源平台，线程只是独享指令流执行的必要资源，如寄存器和栈 线程能减少并发执行的时间和空间开销，体现在： 线程的创建时间比较短 线程的终止时间比较短 线程的切换时间比进程短 由于同一进程的各个线程间共享内存和文件资源，可不通过内核进行直接通信 线程的三种来实现方式（1）用户线程：在用户空间实现 （2）内核线程：在内核中实现 （3）轻量级线程：在内核中实现，支持用户线程 最开始操作系统没有线程，但有人需要在进程中实现资源的共享和并发执行，于是开发了函数库来支持线程。这就是用户线程。 用户有了需求，于是操作系统就加入了线程的功能，这就是内核线程。 用户线程和内核线程各有优缺点，为了取长补短，于是把两者结合起来，产生了轻量级线程 第一，用户线程有一组用户级的线程库函数来完成线程的管理，包括线程的创建，终止，同步和调度]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统练习题]]></title>
    <url>%2F2018%2F06%2F01%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2Fos-exercize%2F</url>
    <content type="text"><![CDATA[CPU执行操作系统代码的时候称为处理机处于 管态（又称内核态）]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[任务状态段TSS]]></title>
    <url>%2F2018%2F06%2F01%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2Ftss%2F</url>
    <content type="text"><![CDATA[TSS任务状态段中记录了处理器为了管理任务所需要的信息。 其中包含两类信息： 动态信息：即在切换任务的时候，处理器会更新的信息。包括： 通用寄存器 段寄存器 标志寄存器 指令寄存器 上一任务的TSS对应的段选择子 静态信息：即处理器只读，但不会修改的信息。包括 任务的LDT对应的段选择子 任务的页目录表的基地址 (PDBR) 栈指针 (从特权级0到2都有) T标志位（debug标志位） I/O映射基地址 TSS描述符 TR寄存器(Task register) TR寄存器里存放的是逻辑地址。因此跟普通的由逻辑地址-&gt;线性地址步骤一样 任务门描述符 任务可以通过人物们描述符或TSS描述符被访问，LDT中任务门，LDT中的任务门可指向相同的任务 何时才会执行任务切换？四种情况： 当前task执行JMP或CALL指令——指向TSS描述符 当前task执行JMP或CALL指令——指向任务门 产生中断或异常——IDT中的任务门 当前task执行iret指令，且NT标志位置位 总之就是JMP/CALL指令，中断，异常，IRET指令四种情况 任务切换步骤 检查是否有权限跳转到目标任务。JMP/CALL情况需要检查CPL和RPL权限是否高于DPL权限。而其他三种情况不用 检查新任务的TSS描述符是否标记为present，且limit有效 保存当前任务的状态。根据TR寄存器找到TSS所在的线性地址，将信息记录到TSS中 将新任务的TSS的选择子加载到TR寄存器中 通过TR寄存器新的选择子，加载新任务的TSS信息到各个寄存器中]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[386的中断机制]]></title>
    <url>%2F2018%2F05%2F31%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2Fx86-interrupt%2F</url>
    <content type="text"><![CDATA[中断门描述符 查找中断服务例程入口点 产生中断，得到中断向量号 查询中断描述符表，得到中断门或陷阱门描述符 根据门描述符去查找LDT或GDT，得到段描述符(也就是TSS描述符) 根据段描述符可以找到中断服务例程的入口点 中断入栈 分成两种情况： • 没有特权级变换：不需要压入 SS和ESP • 产生特权级转换：需要压入 SS和ESP]]></content>
      <tags>
        <tag>操作系统</tag>
        <tag>ucore</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ucore内存管理]]></title>
    <url>%2F2018%2F05%2F31%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2Fucore-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[defalut_pmm.c default_init —— 初始化free_list default_init_memmap —— 将空闲区域的Page结构体 default_alloc_pages —— 分配页 default_free_pages —— 释放页 default_nr_free_pages —— 获取有多少空闲页 memlayout.h描述了内存布局相关的数据结构： e820map —— e820中断探测内存返回的数据结构体 Page —— 用于管理物理内存的数据结构 free_area_t —— 记录空闲区域的数据结构 mmu.h描述了用于内存管理的变量和数据结构体 Eflags寄存器每一位的宏定义 段类型的宏定义 gatedesc —— 中断和陷阱的门描述符 segdesc —— 普通段描述符 taskstate —— 任务状态段 线性地址 用于内存管理的函数 SETGATE —— 设置中断/陷阱门描述符 SETCALLGATE —— 设置调用门描述符 SEG —— 设置段描述符 SEGTSS ——设置状态段描述符 PDX(la), PTX(la), and PGOFF(la) ,PPN(la) —— 根据线性地址获得页目录索引，页表索引，页内偏移，页号 PGADDR(d,t,o) —— 根据页目录索引，页表索引，页内偏移构造出线性地址 pmm.c自映射机制 把页目录表和页表放在一个连续的4MB虚拟地址空间中， 并设置页目录表自身的虚地址物理地址映射关系。 已知虚拟地址可以找到页目录索引，因为连续存储，可以直接计算出页表的位置，而不用去读取页目录的内容。加快速度 数据结构 全局描述符 伪描述符 —— lgdt指令加载gdt的起始地址，用的是16位的limit+32位的base ​ 方法 gdt初始化 —— 设置堆栈（ESP和SS），加载gdt，初始化TSS，加载TSS init_pmm_manager —— 初始化物理内存管理器。将空闲区域链表设置为空（双向链表指向自己） init_memmap —— 对这个空闲区域的所有页对应的Page数据结构进行初始化。空闲区域的第一个页的property属性 = n，其他为0 alloc_pages —— 分配n个连续的页 free_pages —— 释放n个连续的页 nr_free_pages —— 获取空闲区域的页数量 page_init —— 建立并初始化空闲区域所有页的Page数据结构，调用init_memmap boot_map_segment —— 根据给定的页目录表对线性地址进行映射（物理内存管理都是一整个区域映射） get_pte —— 获取页表项 系统段类型有： 123456789101112#define STS_T16A 0x1 // Available 16-bit TSS#define STS_LDT 0x2 // Local Descriptor Table#define STS_T16B 0x3 // Busy 16-bit TSS#define STS_CG16 0x4 // 16-bit Call Gate#define STS_TG 0x5 // Task Gate / Coum Transmitions#define STS_IG16 0x6 // 16-bit Interrupt Gate#define STS_TG16 0x7 // 16-bit Trap Gate#define STS_T32A 0x9 // Available 32-bit TSS#define STS_T32B 0xB // Busy 32-bit TSS#define STS_CG32 0xC // 32-bit Call Gate#define STS_IG32 0xE // 32-bit Interrupt Gate#define STS_TG32 0xF // 32-bit Trap Gate]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gcc-attribute]]></title>
    <url>%2F2018%2F05%2F31%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%2Fgcc-attribute%2F</url>
    <content type="text"><![CDATA[GNU C有一种_attribute_ 的机制，用于辅助编译器检查和编译，可以设置： 函数属性 变量属性 类型属性 （1）_attribute_ format format属性告诉编译器，按照指定的风格对该函数的参数进行检查。 1234format(archetype, string-index, first-to-check)// archetype:指定风格// string-index: 告诉编译器传入函数的第几个参数是格式化字符串// firsttocheck指定从函数的第几个参数开始检查 （2）_attribute_ noreturn 该属性通知编译器函数从不返回值 （3）_attribute_ packed 不要进行数据对齐]]></content>
      <tags>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[页替换算法]]></title>
    <url>%2F2018%2F05%2F30%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2Fpage-replacement%2F</url>
    <content type="text"><![CDATA[页置换机制综合考虑问题： 何时执行页换入换出？ 换出哪些页？ 怎么换入换出？ 虚拟页怎么跟硬盘扇区对应起来？ 如何设计数据结构以支持页置换？ 第一，哪些页可以换出？操作系统设计中，一般遵循如下原则： 映射到虚拟用户空间的物理页才能换出 映射到虚拟内核空间的物理页不能换出 第二，虚拟页怎么跟硬盘扇区对应起来？充分利用页表项PTE。PTE中有一个标志位：PTE_P，可以用来表示物理页是否被置换出去了。 如果一个页（4KB）被置换到了硬盘的某8个扇区（512B/扇区），则设置PTE_P = 0。然后取高24位来表示此页(虚拟页)在swap中的起始扇区号。 1234567swap_entry_t-------------------------| offset | reserved | 0 |------------------------- 24 bits 7 bits 1 bit虚拟页对应的PTE的索引值 = swap page的扇区起始位置 * 8 第三，何时执行换入换出？换入时机：当产生page fault异常时 换出时机：两种策略不同。一种是积极换出策略，即操作系统周期性地主动换出。一种是消极换出策略，找不到空闲页的时候，执行换出。 第四，换出哪些页？按照第一次访问时间的先后进行排序，替换的时候选择距离第一次访问时间最久的页。 第五，如何设计数据结构基于Page数据结构构造的全局数组pages，其中每一个元素记录了对应的物理页的使用情况。 Page数据结构如下： 12345struct Page &#123; ... list_entry_t pra_page_link; // 按照该物理页第一次被访问的时间先后排序的链表 uintprt_t pra_vaddr; // 该物理页对应的虚拟地址&#125; 设计了页替换算法的框架 1234567891011121314struct swap_manager&#123;const char *name;int (*init) (void); // swap管理器的初始化int (*init_mm) (struct mm_struct *mm); // 初始化mm_structint (*tick_event) (struct mm_struct *mm); // tick中断服务例程int (*map_swappable) (struct mm_struct *mm, uintptr_t addr, struct Page *page, int swap_in); // 将页映射到mm_struct中/* When a page is marked as shared, this routine is called to delete the addr entry from the swap manager */int (*set_unswappable) (struct mm_struct *mm, uintptr_t addr);/* Try to swap out a page, return then victim */int (*swap_out_victim) (struct mm_struct *mm, struct Page *ptr_page, int in_tick);/* check the page relpacement algorithm */int (*check_swap)(void);&#125;;]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数栈帧]]></title>
    <url>%2F2018%2F05%2F29%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%2Fstack-frame%2F</url>
    <content type="text"><![CDATA[栈帧函数调用时，依次压栈保存： 参数 返回地址 上一层函数的EBP 如果需要，还可以保存可能会被修改的寄存器 这些动作都是有编译器帮用户程序生成压栈指令，然后由硬件执行压栈的。 函数调用惯例一个调用惯例一般会规定如下几个方面的内容： 函数参数的传递顺序和方式 栈的维护方式 名字修饰的策略 调用惯例 出栈方 参数传递 名字修饰 cdecl 函数调用方 右→左 下划线+函数名 stdcall 被调用函数 左→右 下划线+函数名+@+参数的字节数 fastcall 被调用函数 头两个≤4字节的参数传给寄存器，后面的右→左 @+函数名+@参数的字节数 pascal 被调用函数 左→右 复杂 cdecl是默认的调用惯例 函数返回值传递 1~4字节：eax 5~8字节：edx，eax >8字节：栈]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统调用]]></title>
    <url>%2F2018%2F05%2F28%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2Fsystem-call%2F</url>
    <content type="text"><![CDATA[系统调用的入口： linux —— 0x80号中断 windows——0x2E号中断 一个0x80中断，通过eax传递系统调用号，衍生出多个系统调用服务例程。 Linux系统调用Linux内核版本2.6.19共有319个系统调用。 eax —— 传递系统调用号 ebx、ecx、edx、esi、edi、ebp —— 传递参数 Linux系统调用实现过程 （1）使用系统调用函数，触发中断 1234int main()&#123; fork();&#125; fork()是并非系统调用，而是系统调用服务例程fork经过层层封装之后的库函数。 _syscall0(pid_t, name) 调用不带参数的系统调用 _syscall1(pid_t, name, type, arg1) 调用带一个参数的系统调用，参数在ebx中 _syscall2(pid_t, name, type, arg1, type, arg2) 调用带两个参数的系统调用，参数在ebx,ecx中 ……. 参数依次使用 ebx、ecx、edx、esi、edi、ebp传递 （2）切换堆栈 系统调用，CPU从用户态切换到内核态。在执行系统调用服务例程之前需要切换到内核堆栈。 ”当前栈“，指的是EFP所在的栈空间。如果ESP的值位于用户栈的范围内，那么程序的当前栈就是用户栈，反之亦然。此外，寄存器SS的值还应该指向当前栈所在的页。 当0x80号中断发生时，CPU做出如下反应： CPU从用户态切换到内核态（设置CPU中某个寄存器的某位） 找到当前进程的内核栈（每一个进程都有自己的内核栈） 硬件实现在内核栈中一次压入用户态寄存器：SS、ESP、EFLAGS、CS、EIP（硬件只保存中断前最重要的三个信息：下一条指令地址，栈，标志寄存器） 如果还需要保存其他寄存器，那么在中断服务例程中手动压栈。 （3）中断处理 ​ Linux将中断处理分成上下半部，上半部会暂时禁用中断，主要处理必须短时间内完成的工作。下半部不会禁用中断，能够允许稍后完成的工作会被推迟到下半部才执行。上半部只有中断处理程序机制，下半部则实现系统软中断。这种设计可以使系统处于中断屏蔽状态的时间尽可能短，从而提高系统的响应能力。 函数调用和系统调用的不同处 int和iret指令用于系统调用，系统调用时，需要切换堆栈，转换特权级 call和ret指令用于函数调用，常规函数调用不需要切换堆栈 参考文献[1] 程序员的自我修养]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[结构体使用方法]]></title>
    <url>%2F2018%2F05%2F28%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%2Fstruct-usage%2F</url>
    <content type="text"><![CDATA[结构体的声明及定义方法一：直接声明结构体类型 12345struct book &#123; char title[MAXTITL]; char author[MAXAUTH]; float value;&#125;; 这种方法下，定义结构体变量,需要使用struct book 1struct book Operating_System; 方法二：声明结构体类型同时定义结构体变量 12345struct book &#123; char title[MAXTITL]; char author[MAXAUTH]; float value;&#125; Operating_System; 这里定义了一个结构体变量Operating_System，后续如果需要定义其他结构体变量，同方法一，仍然需要用struct book 方法三：通过匿名结构体定义结构体变量 12345struct &#123; char title[MAXTITL]; char author[MAXAUTH]; float value;&#125; Operating_System; 直接定义了结构体变量Operating_System，而不定义结构体类型，因此无法再定义其他这种类型的结构体变量。 方法四：typedef声明结构体类型 12345typedef struct book&#123; char title[MAXTITL]; char author[MAXAUTH]; float value;&#125; sci_book; 相当于给struct book 起了别名为：sci_book，从此可以用sci_book代替struct book 因此，下面两种定义结构体变量的方法意思一样 12struct book Operating_System;sci_book Operating_System; 方法五：typedef声明匿名结构体类型 12345typedef struct &#123; char title[MAXTITL]; char author[MAXAUTH]; float value;&#125; sci_book; 相当于给匿名结构体起了别名为：sci_book，定义结构体变量的方法同方法四。 初始化结构体方法一：按顺序初始化 12345struct book Operating_System = &#123; "Operating Systems"; "William"; 100;&#125; 方法二：使用初始化器 12345struct book Operating_System = &#123; .title = "Operating Systems"; .author = "William"; .value = 100;&#125; 访问结构体成员通过”.”访问和”-&gt;”访问的区别 结构体变量使用”.”访问成员； 结构体指针通过“-&gt;”访问成员 123456struct book Operating_System;struct book *pbook = &amp;Operating_System; // 使用.访问结构体变量的成员Operating_System.author = "William";// 使用-&gt;访问结构体指针所指的成员pbook-&gt;value = 100; C和C++结构体的细微差异C中定义结构体变量，必须使用struct book，C++则不需要加struct 1234567891011struct book &#123; char title[MAXTITL]; char author[MAXAUTH]; float value;&#125;;// C中定义结构体变量struct book Operating_System;// C++中定义结构体变量,加不加struct都可以struct book Operating_System;book Operating_System;]]></content>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优雅的代码片段]]></title>
    <url>%2F2018%2F05%2F27%2Felegant-code%2F</url>
    <content type="text"><![CDATA[1.计算某个成员变量在结构体中的偏移量 123/* Return the offset of 'member' relative to the beginning of a struct type */#define offsetof(type, member) \ ((size_t)(&amp;((type *)0)-&gt;member)) 解析： ANSI C标准允许值为0的常量被强制转换成任何一种类型的指针，(type )0转换结果是一个type类型的NULL指针。&amp;((type )0)-&gt;member则是取member成员的地址。因为首地址为0，因此结果相当于结构体成员在结构体中的偏移量。 来源: ucore_os_lab/labcodes_answer/lab2_result/libs/defs.h 2.根据某个结构体指针得到另一个结构体指针 12345678/* * * to_struct - get the struct from a ptr * @ptr: a struct pointer of member * @type: the type of the struct this is embedded in * @member: the name of the member within the struct * */#define to_struct(ptr, type, member) \ ((type *)((char *)(ptr) - offsetof(type, member))) 解析： offsetof可以就是第一个代码片段中的方法，可以求出成员在结构体类型中的偏移量。(char )(ptr)转换成char 类型，是因为指针的减法并不是简单的地址相减，如 int * ptr，ptr - 2，实际上是减去2个int的大小。]]></content>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序内存布局]]></title>
    <url>%2F2018%2F05%2F27%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%2Fmemory-layout%2F</url>
    <content type="text"><![CDATA[Linux的进程空间布局 主要分成两部分： 内核空间：占用1GB 用户空间：占用3GB 只读段 读写段 堆 栈 动态链接库映射区 进程堆管理堆的分配有两种方式： 通过brk()系统调用。可以设置数据段的结束地址（Linux下将.data，.bss合并在一起统称数据段）。将数据段的结束地址向高地址移动后，多出来的空间就可以用作堆空间使用。 通过mmap()系统调用。通过匿名映射虚拟地址申请空间。 malloc函数申请空间的原理： 若申请的空间&lt;128K，在堆空间中分配 若申请的空间&gt;128K，申请匿名空间给用户使用]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ELF文件分析命令]]></title>
    <url>%2F2018%2F05%2F27%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%2Felf-analysis%2F</url>
    <content type="text"><![CDATA[命令总结 1234objdump # 查看目标文件的信息readelf # 查看elf文件的信息size # 查看目标文件各个section的大小和目标文件总大小nm # 查看目标文件的符号 objdump命令常用选项： 12345678-d # 反汇编-f # 目标文件头部-h # 目标文件section头部-s # 所有section的内容-t # 符号表-T # 动态符号表-r # 重定位符号信息-R # 动态重定位符号信息 readelf命令1234567-a # 显示elf文件所有信息-h # 文件头-l # 程序头(segment header、program header)-S # 节头(section header)-e # 所有头部，包括文件头、程序头、节头-s # 符号表-r # 重定位表 size命令123$ size a.o text data bss dec hex filename 100 20 0 120 78 a.o nm命令12345678$ nm ab0000000000601004 D __bss_start0000000000601004 D _edata0000000000601008 D _end0000000000601000 d _GLOBAL_OFFSET_TABLE_00000000004000e8 T main0000000000601000 D shared0000000000400114 T swap]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译链接装载]]></title>
    <url>%2F2018%2F05%2F26%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%2Fcompile-link-load%2F</url>
    <content type="text"><![CDATA[一、目标文件的格式目标文件的格式，以前有很多种格式，当前比较流行的是linux的ELF格式，Windows下的PE格式，两种都是源自unix的COFF格式 主要讲解ELF格式 目标文件有三种类型 可重定位文件(relocatable file，如.o)：可与其他可重定位文件链接，创建可执行文件或共享库文件 可执行文件(executable file，如.exe)：规定了exec[]如何创建进程映像 共享目标文件(shared object file，如.so)：分成两种，一种用于静态链接，一种用于动态链接 目标文件的内容： 代码 数据 链接时需要的信息，如符号表、调试信息、字符串等 为什么要将代码和数据分开存放呢？ 代码一般只读，数据一般可读写，将代码和数据分别映射到不同的虚拟空间区域，设置读写属性，防止代码被误改 代码和数据各自都满足局部性原理，分开存放，可以用指令cache和数据cache分别缓存，提高效率 分开存储，可以设置共享代码，如动态库。因为指令和数据混合存放，无法只共享指令。 ELF格式的目标文件结构 经过简化，挑选出最重要的几个section (1) ELF header 描述了目标文件的运行环境： 文件机器字节长度、数据存储方式、版本、运行平台、ABI版本、ELF重定位类型、硬件平台、入口地址、程序头入口和长度、段表的位置和长度、段的数量 (2) Section header table中的记录了ELF文件中各个section的名称，所在虚拟地址，大小及其他属性，称为段描述符 (3) .bss段的意义 存放未初始化或者初始值为0的全局变量、静态变量。只是在ELF文件的文件头中记录了.bss段在ELF文件中的位置和大小等信息，而ELF文件中的.bss段并没有实际的内容，不占空间。等到运行时才会分配空间。 (4) section和segment的区别 这两个在很多地方都翻译成“段”，但意义略有不同。 ELF中的.text，.data，.bss，.strtab等等都是section。 而可能几个相同读写属性的的section放在一块，就组成一个segment 为什么能够知道每个符号（如变量或者函数）的地址，知道变量的大小？ 这是因为编译生成的目标文件都有一个符号表，其中记录了目标文件用到的所有符号及其属性： 符号名 符号值——对于变量和函数来说，就是符号值就是它们的虚拟地址 符号大小——数据类型大小 符号类型和绑定信息 符号所在的段(section) 符号修饰与函数签名 一个程序中可能包含多个相同的符号，如何区分呢？比如C++中的重载函数，函数名相同，但参数列表不同，编译器和链接器如何区分？ 答案是用符号修饰的方法。按照函数签名的不同修饰函数名称，以区别各个函数。 ”函数签名“ 包含了一个函数的信息：函数名，函数参数，所在类，所在名称空间，及其他信息。 根据函数签名对符号进行修饰，例子如下：（不需要知道符号修饰的规则，只要知道有符号修饰就可以了） 123456// 函数签名 符号修饰int foo(int); ------&gt; _Z3fooifloat foo(float); ------&gt; _Z3foofint C::foo(int); ------&gt; _ZN1C3fooEiint N::foo(int); ------&gt; _ZN1N3fooEiint N::C::foo(int); ------&gt; _ZN1N1C3fooEi 二、编译编译器的工作： 词法分析 语法分析 语义分析 中间语言生成 目标代码生成与优化 编译生成目标文件，elf格式，结构如上面描述。在编译阶段，符号地址都暂时用0x00000000代替。等到链接的时候再确定符号的虚拟地址。 全局变量、函数名都是符号 有些版本的gcc 0x00000000 —–&gt; 代替外部变量的地址 0xFFFFFFFC —–&gt; 代替外部函数的地址 三、静态链接​ 静态链接是将多个目标文件，合并成一个目标文件（如可执行文件，共享库文件）。合并的方法一般是：相似段合并。即，将多个目标文件相同性质的段合并成一个。如多个.text段合并成一个.text段，多个.data段合并成一个.data段….. 静态链接分成三个步骤： 空间和地址的分配 符号决议 重定位 第一，空间和地址的分配 扫描所有的输入目标文件，收集它们各个段的信息：段所在位置，段长度，段属性。 收集各个目标文件的符号表，统一放到一个全局的符号表中。 根据这些信息，组织输出目标文件的布局。即确定各个段在输出目标文件的起始地址和结束地址 第二，符号决议 ​ 计算各个符号的虚拟地址。各个符号相对于所在段的偏移量是固定，因此可以以此重新计算各个符号的地址，并更新全局符号表中。这个过程称为“符号地址的确定”。 第三，重定位 ​ 虽然符号的地址已经“确定”，记录在全局符号表中，但是各个段中的符号(全局变量和函数)仍然是用0x00000000代替。重定位就是根据全局符号表中记录的符号地址，替换掉各个段中的临时的符号地址。 链接生成的ELF可执行文件描述了如何创建一个进程映像。 四、装载装载是把硬盘中的可执行文件加载内存中，目前都用虚拟页映射的方法来实现加载。 可执行文件描述了如何创建一个进程映像。我们可以从进程的创建来看装载，步骤如下： 创建一个独立的虚拟地址空间。其实就创建虚拟地址映射到物理地址的数据结构，即页目录。 读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系——&gt;即把可执行文件加载到内存中，也就是装载。 跳转到程序的入口地址，开始运行 当出现页错误的时候，操作系统会到硬盘中读取可执行文件，把相应的页加载到内存中，这就是装载。 Linux内核装载ELF的过程从用户程序的角度来看进程创建的过程 bash进程调用fork()系统调用创建一个进程。 调用execve()系统调用运行进程 execve()中Linux开始进行真正的装载过程： 跳转到execve()系统调用的入口点sys_execve()，进行参数检查 调用do_execve()，检查可执行文件是否存在。如果存在，读取可执行文件的前128字节，获知可执行文件的格式，如ELF格式。 调用search_binary_handler()搜索和匹配合适的可执行文件装载处理过程。比如，ELF文件的装载处理过程是load_elf_binary() 调用load_elf_binary()装载ELF可执行文件 装载ELF可执行文件的过程如下： 检查ELF可执行文件格式的有效性，比如魔术数、程序头表中segment的数量 寻找动态链接的”.interp”段，设置动态链接器路径 根据ELF可执行文件程序头表的描述，对ELF文件进行映射，比如代码、数据、只读数据 初始化ELF进程环境，比如进程启动时EDX寄存器的地址应该是DT_FINI的地址 将系统调用的返回地址修改成ELF可执行文件的入口点。对于静态链接的ELF，入口点为文件头中e_entry所指地址；对于动态链接的ELF，入口点为动态链接器 1234567891011121314151617181920进程创建过程├── fork()└── execve() └── sys_execve() ├── 进行参数检查 └── do_exeve() ├── 检查可执行文件是否存在 ├── 读取可执行文件的前128字节，获知文件格式，如ELF ├── search_binary() # 匹配可执行文件对应的装载处理过程 └── load_elf_binary() # 装载ELF可执行文件 ├── 检查ELF格式有效性 ├── 设置动态链接器路径 ├── ELF文件映射到虚拟地址空间 ├── 初始化ELF进程环境 └── 设置系统调用的返回地址为ELF可执行文件的入口点 └── 返回 └── 返回 └── 返回 └── 返回，跳转到ELF程序└── 返回，结束进程 常用的命令123file foobar.o # 查看文件的格式objdump -s -d simpleSection.o # -s以16进制打印目标文件，-d反汇编readelf -s simpleSection.o # 查看目标文件的各个section的信息 参考文献[1] 程序员的自我修养 [2] ELF文件格式分析]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[i386知识点]]></title>
    <url>%2F2018%2F05%2F23%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2Fi386%2F</url>
    <content type="text"><![CDATA[地址转换i386的虚拟地址—-&gt;物理地址的转换过程：经过段转换、页转换两个过程。 较详细过程 段转换过程段转换需要四个要素： 段描述符 段描述符表 选择子 段寄存器 段描述符格式 数据结构如下： 1234#define SEG_ASM(type,base,lim) \ .word (((lim) &gt;&gt; 12) &amp; 0xffff), ((base) &amp; 0xffff); \ .byte (((base) &gt;&gt; 16) &amp; 0xff), (0x90 | (type)), \ (0xC0 | (((lim) &gt;&gt; 28) &amp; 0xf)), (((base) &gt;&gt; 24) &amp; 0xff) 段描述符主要由三部分组成： base: 段基址，占32位 limit：段限制，占20位，实际段限制 = limit &gt;&gt; 12 access：段属性，占12位 段描述符表分成全局描述符表(GDT)和局部描述符表(LDT) 注意：全局描述符表的第一个段描述符不使用。 段选择子 段寄存器 页转换过程 页目录表项和页表项格式页目录表和页表本身也是一个页，因此页目录表项和页表项格式相同。]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ucore启动过程分析]]></title>
    <url>%2F2018%2F05%2F23%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2Fucore%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[ucore启动过程简介 CPU上电，CS = F000，EIP = FFF0,而CS 的影子寄存器Base = FFFF0000；i386的启动地址为Base + EIP = FFFFFFF0 物理地址0xFFFFFFF0是BIOS的起始地址，其中存放一条长跳转指令，跳转到物理地址0xFFFF0（为了兼容8086,80286），从0xFFFF0开始执行BIOS程序，自检，查找启动设备 BIOS加载bootloader到物理地址0x7C00（这是BIOS厂商和操作系统厂商共同约定的地址），加载后跳转到0x7c00，开始执行bootloader程序 bootloader设置段表，开启段机制，进入保护模式，因为段表的设置，虚拟地址 = 线性地址 = 物理地址 bootloader读取硬盘加载内核文件kern的前8个扇区到物理地址0x10000，（8个扇区，共4K字节，即一个block)，分析ELF文件头，得到内核程序的起始地址 bootloader正式加载内核的程序部分（包含数据段、代码段、bss段等…）到物理地址 0x100000，跳转到内核程序的起始地址，即0x100000，开始执行内核程序 内核设置页表，开启页机制，从此虚拟地址 = 线性地址 ==&gt; 物理地址，（虚拟地址不再直接等于物理地址） 内核初始化：控制台初始化，物理内存管理初始化，中断控制器初始化，IDT初始化，时钟初始化，中断使能。 物理内存探测​ 操作系统需要知道计算机有多大的物理内存，才能进行管理。这一工作在bootloader中完成，利用BIOS中断调用来实现（BIOS中断INT 15h，参数为e820h）。 ​ INT 15中断调用原型如下： int 15中断调用输入参数1.eax：INT 15的中断调用参数，这里输入e820h2.edx：534D4150h (即4个ASCII字符“SMAP”)，固定签名3.ebx：若为第一次调用或内存区域扫描完毕，则为0；否则，存放上次调用之后的计数值4.ecx：指定输出缓冲区的大小，应该大于等于20字节5.es:di：指定输出缓冲区的地址 输出参数1.cflags的CF位：int 15执行成功–&gt;0；int 15执行失败–&gt;12.eax：534D4150h (‘SMAP’)3.es:di：输出缓冲区（BIOS将扫描结果放在其中）4.ebx：下一个地址范围描述符的计数地址5.ecx：返回BIOS往输出缓冲区写入的字节数6.ah：失败时的错误代码 BIOS一次返回的数据格式，共20字节 +—————————–+&lt;——-8字节| 系统内存 || 块基地址 |+—————————–+&lt;——–8字节| 系统 || 内存大小 |+—————————–+&lt;——–4字节| 内存类型 |+—————————–+ 用结构体来存返回的数据 12345678struct e820map &#123; int nr_map; struct &#123; uint64_t addr; // 对应上图的系统内存基地址 uint64_t size; // 对应上图的系统内存大小 uint32_t type; // 对应上图的内存类型 &#125; __attribute__((packed)) map[E820MAX];&#125;; 源码对照上面的调用原型理解 12345678910111213141516171819probe_memory: movl $0, 0x8000 # 0x8000 ---&gt; nr_map = 0 xorl %ebx, %ebx movw $0x8004, %di # 0x8004 ---&gt; start_probe: movl $0xE820, %eax movl $20, %ecx movl $SMAP, %edx int $0x15 jnc cont movw $12345, 0x8000 jmp finish_probecont: addw $20, %di incl 0x8000 cmpl $0, %ebx jnz start_probefinish_probe: ......]]></content>
      <tags>
        <tag>操作系统</tag>
        <tag>ucore</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[存储管理]]></title>
    <url>%2F2018%2F05%2F21%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%2Fmemory-manage%2F</url>
    <content type="text"><![CDATA[逻辑地址的生成 地址检查 连续存储分配方式 非连续存储分配方式 段式存储 页式存储 页式存储的两个问题 解决方法1：快表 解决方法2：多级页表 段页式存储 虚拟存储技术 逻辑地址的生成 编译 汇编 链接 加载(重定位) 一步一步生成程序的逻辑地址，但还没到物理地址。经过硬件MMU的转换之后才能得到真正的物理地址。 地址检查 得到逻辑地址之后硬件会先检查逻辑地址的偏移量是否超过了对应段的长度，如果超过，访问异常。如果没有超过，则由MMU生成物理地址，访问内存。 连续存储分配方式 固定分区 动态分区 伙伴系统 连续存储分配存在的问题： 分配给程序的物理内存必须连续 存在内部碎片和外部碎片 内存分配的动态修改困难 内存利用效率低 非连续存储分配方式非连续存储分配的设计目标： 允许使用非连续的物理地址空间 允许共享代码和数据 支持动态加载和动态链接 三种非连续存储分配方式: 段式 页式 段页式 段式存储逻辑地址 = 段号| 偏移量 检索段表，获得段号对应的段描述符，其中包含了段基址和段长度。 比较段长度和偏移量，确定是否越界访问。 如果没有，根据段基址和段偏移量可以得到实际的物理地址。 页式存储逻辑地址 = 页号 | 偏移量 检索页表，获得页号所对应的页描述符，其中包含页标志位和页对应的帧号。 根据帧号和偏移量，可以得到物理地址。 页式存储的两个问题 访问性能问题：需要访问两次内存，第一次，获取页表项，第二次，访问数据 页表大小问题：大内存，需要很多页表项，导致页表很大。 解决以上两个问题的方法： 使用缓存：快表 间接访问：多级页表，反置页表 解决方法1：快表CPU发出逻辑地址 查找快表 如果快表命中，则从快表中获得页号 如果没有命中，则查内存中的页表，获得页号，同时更新快表，记录对应的页表项。 根据获得的页号，访问物理内存。 解决方法2：多级页表 段页式存储 段页式存储的内存共享 两个进程的段表中有一个段描述符指向同一个页表，就能实现段共享。 虚拟存储技术​ 虚拟存储技术是在非连续内存分配的基础上，可以把进程的一部分放到外存的做法。可以让用户程序感觉自己的内存空间很大。 （1）虚拟存储技术的目标： 进程只要有一部分在内存中，就可以启动，运行。 可以把进程的一部分内容搬到外存中。 （2）虚拟存储的基本特征： 不连续性：物理内存和虚拟地址空间都是非连续的 大用户空间：虚拟地址空间可以大于实际的物理内存 部分交换：只对部分虚拟地址空间进行调入、调出 （3）虚拟存储中的外存管理：如何记录进程调出的部分，在外存中的位置 代码段：直接记录进程对应的可执行文件在硬盘中的位置 动态加载的共享库程序段：直接记录动态调用的库文件在硬盘中的位置 其他：交换空间 （4）虚拟存储的思路： 用户程序只装入进程的部分内容，就可以启动 进程发现需要的代码/数据不在内存中，发出缺页异常 操作系统将缺少的页从外存中调入到内存 进程可以继续运行 产生缺页异常之后的处理方式如下图所示]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机启动过程]]></title>
    <url>%2F2018%2F05%2F19%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2Fos-boot%2F</url>
    <content type="text"><![CDATA[知识点汇编（1）.word和.long bootasm.S中 123gdtdesc: .word 0x17 # sizeof(gdt) - 1 .long gdt # address gdt .word代表2个字节，.long代表4个字节。因此gdtdesc下占用了6个字节。 （2）ljmp 1ljmp $PROT_MODE_CSEG, $protcseg ljmp 段选择子，段偏移量 _attribute_GNU C有一种_attribute_ 的机制，用于辅助编译器检查和编译，可以设置： 函数属性 变量属性 类型属性 （1）_attribute_ format format属性告诉编译器，按照指定的风格对该函数的参数进行检查。 1234format(archetype, string-index, first-to-check)// archetype:指定风格// string-index: 告诉编译器传入函数的第几个参数是格式化字符串// firsttocheck指定从函数的第几个参数开始检查 （2）_attribute_ noreturn 该属性通知编译器函数从不返回值 ELF文件头格式123456789101112131415161718/* file header */struct elfhdr &#123; uint32_t e_magic; // must equal ELF_MAGIC uint8_t e_elf[12]; uint16_t e_type; // 1=relocatable, 2=executable, 3=shared object, 4=core image uint16_t e_machine; // 3=x86, 4=68K, etc. uint32_t e_version; // file version, always 1 uint32_t e_entry; // entry point if executable uint32_t e_phoff; // file position of program header or 0 uint32_t e_shoff; // file position of section header or 0 uint32_t e_flags; // architecture-specific flags, usually 0 uint16_t e_ehsize; // size of this elf header uint16_t e_phentsize; // size of an entry in program header uint16_t e_phnum; // number of entries in program header or 0 uint16_t e_shentsize; // size of an entry in section header uint16_t e_shnum; // number of entries in section header or 0 uint16_t e_shstrndx; // section number that contains section name strings&#125;; elf头部占52字节； program header中有3个entry，每个entry32字节； section header中有11个entry，每个entry40字节； 函数堆栈函数调用可以分解成以下三个动作： 压栈传参 call指令，硬件压入返回地址 编译器压入上一层函数的栈底ebp，并把当前esp ==&gt; ebp 编译器默认会在每个函数体之前插入如下汇编指令： 12pushl %ebpmovl %esp %ebp 经过以上动作之后，函数栈如下： 1234567891011+------------------+| 栈底方向 | 高位地址| ... || ... || 参数3 || 参数2 || 参数1 || 返回地址 || 上一层[ebp] | &lt;-------- [ebp]| 局部变量 | 低位地址+-------------------+ 内联汇编GCC的内联汇编结构如下： 12345asm ( assembler template : output operands (optional) : input operands (optional) : list of clobbered registers (optional) ); input operands相当于C函数的输入参数 output operands相当于C函数的输出参数 给出一个简单的例子 12345678&#123; int a=10, b; asm ("movl %1, %%eax; movl %%eax, %0;" :"=r"(b) /* output */ :"r"(a) /* input */ :"%eax"); /* clobbered register */&#125; 第5行表示：给变量b分配任意通用寄存器，=代表这是输出操作数，r代表gcc可以分配任意通用寄存器 第6行表示：给变量a分配任意通用寄存器，r代表任意通用寄存器 第7行表示：上面的汇编中会使用到eax寄存器，通知gcc不要分配eax给输出操作数和输入操作数。（所以上面说的任意其实也不算任意）。 注意gcc会给上面分配出去的寄存器编号，按照出场的顺序以此编号。 分配给变量b的寄存器编号为%0，假设分配了ebx 分配给变量a的寄存器编号为%1，假设分配了ecx 将寄存器编号代入到第3，4行的汇编代码中 12movl %ecx, %eaxmovl %eax, %ebx 整段内联汇编代码可以这样等效; 12345678int a=10, b;foo(a);int foo(int a)&#123; int b = a; return b;&#125; 内存地址空间分配对于1G的物理内存来说，其物理空间分配如下： 1234567891011121314151617181920212223242526272829+------------------+ &lt;- 0xFFFFFFFF (4GB)| 无效空间 || |+------------------+ &lt;- addr:3G+256M| 256MB || IO外设地址空间 || |+------------------+ &lt;- 0xC0000000(3GB)| |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\| 无效空间 |+------------------+ &lt;- 0x40000000(1GB)| || 实际有效内存 || |+------------------+ &lt;- 0x00100000 (1MB)| BIOS ROM |+------------------+ &lt;- 0x000F0000 (960KB)| 16-bit devices, || expansion ROMs |+------------------+ &lt;- 0x000C0000 (768KB)| VGA Display |+------------------+ &lt;- 0x000A0000 (640KB)| || Low Memory || |+------------------+ &lt;- 0x00000000 bootasm.Sbootasm.S文件内容： 总结来说，bootasm.S的主要工作为： 实模式 —-&gt; 保护模式 —-&gt; 跳转到bootmain 实模式切换到保护模式 使能A20，使用32条地址线 设置GDTR，以后查找GDT的基地址 设置CR0的bit0，进入保护模式 跳转到保护模式的代码段 重新设置数据段寄存器，段寄存器中保存的不再是实模式下的段基址，而是段选择子 跳转到bootmain 调用C函数，必须设置栈。源码中将栈设置为0–0x7c00 0x7c00是bootasm.S的起始地址，因为bootasm.S已经跑完了，可以覆盖。 bootmain.c工作： 加载内核ucore前8个扇区（4KB，即1页）到虚拟地址0x10000处。注意ucore是从第2个扇区开始的。(第1扇区被bootloader用了) 判断加载进来的东西是否是ELF文件头。 加载ucore的程序段 跳转到ucore程序入口点 kern/init.c 控制台初始化： 初始化CGA接口 初始化串口 关闭FIFO功能 设置波特率 设置数据格式 关闭调制模式 串口中断使能 中断控制器允许串口中断（不屏蔽） 初始化键盘]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建githubpage博客]]></title>
    <url>%2F2018%2F05%2F19%2F%E6%97%A5%E5%B8%B8%2F%E6%90%AD%E5%BB%BAgitpage%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[1. 创建仓库登录github，创建仓库：用户名.github.io 2. 配置SSH2.1 生成SSH密钥和公钥通过ssh方式来保证安全性。 1ssh-keygen -t rsa -C "邮件地址" 连按三次enter键，使用默认配置即可。这样会生成 ~/.ssh目录，其中包含 id_rsa——密钥 id_rsa.pub——公钥 2.2 将公钥添加到github账号上1cat ~/.ssh/id_rsa.pub # 得到生成的公钥 将生成的公钥复制粘贴到github账号上 2.3 测试公钥是否添加成功1234$ ssh -T git@github.com ......Are you sure you want to continue connecting (yes/no)? yesHi WeetCheng! You've successfully authenticated, but GitHub does not provide shell access. 提示：Are you sure you want to continue connecting (yes/no)? 输入：yes 返回以下结果表明成功添加SSH公钥： 1Hi WeetCheng! You've successfully authenticated, but GitHub does not provide shell access. 3. 配置本地git客户端12$ git config --global user.name "weetcheng" # 双引号内替换成你的github用户名$ git config --global user.email "xxx@qq.com" # 双引号内替换成你的注册邮箱 4. hexo使用4.1 安装hexo12sudo apt-get install npmsudo npm install -g hexo 4.2 初始化hexo创建hexo的工作目录，以后博客内容也会放在这里面。比如我放在~/Documents/Hexo/ 然后初始化，生成博客的整个框架。至于主题后面再改。 123mkdir ~/Documents/Hexocd ~/Documents/Hexohexo init 初始化完成后，查看文件如下： 12$ ls_config.yml node_modules package.json scaffolds source themes 4.3 生成博客12hexo g # 生成博客hexo s # 开启本地预览服务 开启预览后，到浏览器输入：http://localhost:4000/可以查看 4.4 更换主题hexo官网 比如选择hexo-theme-yilia 主题, 首先下载主题： 12cd ~/Documents/Hexogit clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 然后配置hexo使用yilia主题 1234vim ~/Documents/Hexo/_config.yml## theme: landscape 修改成## theme: yilia 重新生成博客，预览博客 12hexo ghexo s 如果提示4000端口被占用，说明前面已经开启的服务还没关，ctrl+c就可以终止。 4.5 配置博客发布服务配置~/Documents/Hexo/_config.yml中的deploy部分 1234deploy: type: git repository: git@github.com:WeetCheng/weetcheng.github.io.git branch: master 这时会报错： 1ERROR Deployer not found: git 只需要再安装一个插件就可以了, 1npm install hexo-deployer-git --save 重新输入hexo d发布 5. 写博客5.1 新建博客1hexo new "build-my-blog" 会在~/Documents/Hexo/source/_post/ 目录下生成build-my-blog.md文件，这就是博客的文章内容，现在可以打开该文件，开始编辑你的文章。 编辑完成后，编译开启本地服务 12hexo ghexo s hexo g编译，做了如下工作： 将~/Documents/Hexo/source/_post/目录下的.md文件编译成html文件，保存在~/Documents/Hexo/public目录下。 tips: ~/Documents/Hexo/source/目录下可以存放你的博客需要的资源。只有.md文件会被编译成html文件，其他格式的文件会保留。 5.2 给文章添加目录安装hexo-toc插件 1npm install hexo-toc --save 配置toc显示的目录深度 1234vim ~/Documents/Hexo/_config.yml## 添加以下内容：toc: maxDepth: 3 使用toc 在文章开头使用\&lt;!– toc –> 5.3 给文章添加readmore在适当位置使用\&lt;!– more –> 在博客根目录，我的是~/Documents/Hexo下执行命令： 12cd ~/Documents/Hexonpm i hexo-generator-json-content --save 再修改根目录下的_config_yml，添加: 123456789101112131415161718jsonContent: meta: false pages: false posts: title: true date: true path: true text: false raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true 5.4 博客添加文章列表5.5 设置博客模板修改Hexo/scaffolds/post.md的内容 123456---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags:categories: --- 6. Hexo常用命令12345678hexo new "文章名" ====&gt; hexo nhexo new page "页名" hexo generate ====&gt; hexo ghexo server ====&gt; hexo shexo deploy ====&gt; hexo dhexo s -g # 生成并本地预览hexo d -g # 生成并发布 7. Hexo目录组织123456789~/Documents/Hexo├── _config.yml├── db.json├── node_modules├── package.json├── public├── scaffolds├── source└── themes _config.yml 全局配置文件，可以配置网站名称，作者，主题，部署等参数。前面还没配网站名称和作者，可以自己打开文件去配置。 package.json hexo版本参数 scanffolds 博客框架 source 博客源文件 themes 主题 参考文献[1] 使用hexo+github搭建免费个人博客详细教程 [2] hexo的目录结构及作用]]></content>
      <categories>
        <category>折腾</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
</search>
